/**
* @file mmi_messagemanagersrv_priv.h
*
* Service without using State Machine - SMI
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_SMI
* Interface Id: IID_SMI
*
* @version $Id: mmi_smi_priv.h 41408 2009-09-25 06:11:18Z joe.hsu $
*/
#ifndef __MMI_MESSAGEMANAGERSRV_PRIV_H__
#define __MMI_MESSAGEMANAGERSRV_PRIV_H__

#include "mmi_mae_common_def.h"
#include "mmi_messagemanagersrv.h"
#include "mmi_mae_filemgr.h"
#include "mmi_smstransactionsrv.h"
#include "mmi_simsrv_def.h"
#include "mmi_evtcentersrv.h"
#include "mmi_mae_arraymodel.h"
#include "mmi_mmstransactionsrv.h"
#include "mmi_smssrv.h"
#include "mmi_accessorysrv.h"
/*=============================================================*/
// type, enum, and define
/*=============================================================*/
#ifndef MEMCMP
#define MEMCMP(s,t,n) memcmp(s,t,n)
#endif

#define SMI_NOTIFYARRAY_ENSURE_CAPACITY_UPDATELIST 250
#define SMI_NOTIFYARRAY_GROW_NUM_UPDATELIST  20

#define SMI_NOTIFYARRAY_ENSURE_CAPACITY_SINGLE 1
#define SMI_NOTIFYARRAY_GROW_NUM_SINGLE  1
#define SMI_DUAL_SIM    2

#define SMI_IEVT_QuerySIMCapacityCnf    (CLSID_SMI << 16 | 0xFFFF)

#define SMI_WAITFORSENDARRAY_ENSURE_CAPACITY 20
#define SMI_WAITFORSENDARRAY_GROW_NUM  5
enum
{
    idxNULL = -1
};

typedef enum
{
    SMI_MASTER_START = 0x00
   ,SMI_MASTER_INBOX = 0x00
   ,SMI_MASTER_OUTBOX
   ,SMI_MASTER_SENT
   ,SMI_MASTER_DRAFT
   ,SMI_MASTER_PMBOX
   ,SMI_MASTER_TNBOX
   ,SMI_MASTER_PHONE_MASTER_TOTAL
   ,SMI_MASTER_SIM1 = SMI_MASTER_PHONE_MASTER_TOTAL
   ,SMI_MASTER_SIM2
   ,SMI_MASTER_TOTAL
   ,SMI_MASTER_UNKNOWN = SMI_MASTER_TOTAL
}SMI_MasterLocation_e;

typedef enum
{
    SMI_CMD_ADD = 0x00
   ,SMI_CMD_DEL
   ,SMI_CMD_DEL_LOCATION
   ,SMI_CMD_UPDATE_READ_STATUS
   ,SMI_CMD_UPDATE_SENT_STATUS
   ,SMI_CMD_UPDATE_COMPLETE_STATUS
   ,SMI_CMD_UPDATE_MSG_HEADER
   ,SMI_CMD_TOTAL
   ,SMI_CMD_NONE = SMI_CMD_TOTAL
}SMI_Update_Command_e;  //for the command in SMI_MsgSessionOperate_t

#define SMI_Update_Command_To_NotifyEvt_Shift  (SMI_EVT_AddMsgNotify)
#define SMI_UpdateCommandToNotifyEvt(cmd)   (u32)(cmd+SMI_Update_Command_To_NotifyEvt_Shift)
#define SMI_UpdateCommandToNotifyMask(cmd)  (u32)(1<<cmd)

#define SMI_AvailableID_BlockSize   32
#define SMI_AvailableID_To_BlockIdx(ID)         ((ID-MIN_MSG_ID)/SMI_AvailableID_BlockSize)
#define SMI_AvailableID_To_BlockMask(ID)        (1<<((ID-MIN_MSG_ID) & 0x1F))   //  0x1F =>SMI_AvailableID_BlockSize-1
#define SMI_AvailableID_Total_BlockNum          ( SMI_AvailableID_To_BlockIdx(MAX_PM_MSG_ID) +1 )
#define SMI_AvailableID_IsAvailableBlock(Block) ((Block)!=0)

#define SMI_AvailableID_PhoneSMS_BlockNum       ( SMI_AvailableID_To_BlockIdx(MAX_PHONE_SMS_ID) +1 )

#define SMI_AvailableID_MMS_FirstBlockIdx       ( SMI_AvailableID_To_BlockIdx(MIN_MMS_MSG_ID))
#define SMI_AvailableID_MMS_BlockNum            ( SMI_AvailableID_To_BlockIdx(MAX_MMS_MSG_ID) - (SMI_AvailableID_MMS_FirstBlockIdx) +1 )

#define SMI_AvailableID_CB_FirstBlockIdx        ( SMI_AvailableID_To_BlockIdx(MIN_CB_MSG_ID))
#define SMI_AvailableID_CB_BlockNum             ( SMI_AvailableID_To_BlockIdx(MAX_CB_MSG_ID) - (SMI_AvailableID_CB_FirstBlockIdx) +1 )

#define SMI_AvailableID_PM_FirstBlockIdx        ( SMI_AvailableID_To_BlockIdx(MIN_PM_MSG_ID))
#define SMI_AvailableID_PM_BlockNum             ( SMI_AvailableID_To_BlockIdx(MAX_PM_MSG_ID) - (SMI_AvailableID_PM_FirstBlockIdx) +1 )


#define SMI_AvailableID_SIM1_To_BlockIdx(ID)    ((ID-MIN_MASTER_SIM_MSG_ID)/SMI_AvailableID_BlockSize)
#define SMI_AvailableID_SIM1_To_BlockMask(ID)   (1<<((ID-MIN_MASTER_SIM_MSG_ID) & 0x1F))
#define SMI_AvailableID_SIM1_BlockNum           ( SMI_AvailableID_SIM1_To_BlockIdx(MAX_MASTER_SIM_MSG_ID)+1)

#define SMI_AvailableID_SIM2_To_BlockIdx(ID)    ((ID-MIN_SLAVE_SIM_MSG_ID)/SMI_AvailableID_BlockSize)
#define SMI_AvailableID_SIM2_To_BlockMask(ID)   (1<<((ID-MIN_SLAVE_SIM_MSG_ID) & 0x1F))
#define SMI_AvailableID_SIM2_BlockNum           ( SMI_AvailableID_SIM1_To_BlockIdx(MAX_SLAVE_SIM_MSG_ID)+1)






typedef struct
{
    u32 WaitingIdx; //The pUpdateVector index of the operation which wait for the TXI confirm notify event
    SMI_MsgID_t WaitingMsgID; //The msg ID of the message which wait for the TXI confirm notify event
    //u8  WaitingPackage; //The package index of the message which wait for the TXI confirm
}SMI_WaitCnfInfo_t;

#define WAIT_FOR_NONE_CONFIRM 0xFFFFFFFF    //for WaitingIdx in SMI_WaitTXIInfo_t: means not waiting for any TXI confirm

typedef enum
{
    SMI_UPDATE_NONE
   ,SMI_UPDATE_FAIL
   ,SMI_UPDATE_PARTIAL_FAIL
   ,SMI_UPDATE_SUCCESS
   ,SMI_UPDATE_CANCEL    //The operation has already been canceled, but the last operation might be still waiting for the TXI confirm
}SMI_Update_Status_e;   //for the Status in SMI_MsgSessionOperate_t

typedef struct SMI_MSG_SESSION_OPERATE_TAG
{
    SMI_LIST_PARAM BoxParam;   //The Cached Master file BoxParam set in ISMI_UtilBeginUpdateHeader
    SMI_MasterLocation_e MasterLocation; //The Cached Master Location according to the BoxParam
    SMI_Update_Command_e command;    //The Cached operation command type: SMI_Update_Command_e
    SMI_Update_Status_e Status;     //The Cache operation current status: SMI_Update_Status_e
    SMI_WaitCnfInfo_t WaitConfirmInfo;   //Saved the current operate command information, if the current operation is waiting for the TXI confirm
    u32 NextOperateIdx; //The pUpdateVector index of the Next Operation
    IArrayModel *pUpdateList;    //The Cached operation, each pointer in the Array model is (SMI_NotifyInfo_t *), the SMI_NotifyInfo_t define in mmi_smi.h
    SMI_MsgHdrLst_t *pCacheMaster;//The Cached master file
    SMI_Available_MsgId_t *pCacheAvailableID;   //The Cached Available ID
    void *pReqInstance;    //The operation request instance set in ISMI_UtilBeginUpdateHeader
}SMI_MsgSessionOperate_t;

typedef enum
{
    SMI_OPERATE_RESULT_WAITING = 0x00
   ,SMI_OPERATE_RESULT_DONE
   ,SMI_OPERATE_RESULT_BAD_PARAM
   ,SMI_OPERATE_RESULT_OUT_OF_MEMORY
   ,SMI_OPERATE_RESULT_FAIL
}SMI_Operate_Result_e;  //for the mmi_SMI_UtilTXIRelatedOperate return value


typedef struct SMI_MSG_OPERATE_TAG
{
    boolean bBusy;
    u32 CnfEventID ;        //post event,
    void *pReqInst;    //The operation request instance set in ISMI_UtilBeginUpdateHeader
    SMI_MsgLocation_e msgLocation; // the original location
    SMI_MsgHdr_t *pMsgHdr;         // the update message header
}SMI_MsgOperate_t;

typedef struct SMI_POST_CNF_DATA_TAG
{
    void *pDesInst;
    MAE_EventId ConfEvt;
    u32 Param1;
    u32 Param2;
}SMI_PostEvent_Data_t;

typedef struct SMI_DO_NOTIFY_DATA_TAG
{
    u32 NotifyMask;
    MAE_EventId NotifyEvent;
    SMI_LIST_PARAM OperateBoxParam;         //param1 with the Notify Event
    IArrayModel *pUpdateList;               //The update Array model, param2 with the Notify Event
    PfnEventCleanup pCleanFnc;            //The clean function for update vector model
}SMI_DoNotify_Data_t;

enum
{
    SMI_e_NotReset = 0x00
   ,SMI_e_ResetSIM = 0x01
   ,SMI_e_SIMUpdating = 0x02
   ,SMI_e_RetrievedSIM = 0x03
   ,SMI_e_Status_Mask = 0x03
   ,SMI_e_SIM1_Delete_Mask = 0x04
   ,SMI_e_SIM1_Retrieve_Mask = 0x08
   ,SMI_e_SIM1_Abort_Retrieve = 0x10
   ,SMI_e_SIM2_Delete_Mask = 0x20
   ,SMI_e_SIM2_Retrieve_Mask = 0x40
   ,SMI_e_SIM2_Abort_Retrieve = 0x80
   ,SMI_e_SIMChanging_Delay_Mask = 0xFC,
};
typedef u8 SMI_Status_e;

typedef struct SMI_READ_SIM_TAG
{
    u8 PackNum; //Total Package
    u8 ReadIdx; //The idx (0~PackNum-1) of the Read SIM package, wait for the read confirm
    u8 *pSIMIdx;    //The package array
    SMI_MsgLocation_e MsgLoc; //The new message location
    SMI_MsgID_t MsgID;        //The new message ID
    u8 *pReadData;
    u32 nReadByteLen;
}SMI_ReadSIM_t;

typedef struct SMI_DELETE_SIM_MSG_TAG
{
    SMI_MsgID_t MsgId;
    SMI_MsgLocation_e MailBoxLoc;
} SMI_DeleteSIMMsg_t;

typedef struct SMI_SEND_SMS_REQ_TAG{
    SMI_MsgID_t *pMsgId;
    IBase *pRequester;
} SMI_SendSMSReq_t;

/**
 * Application structure
 */
typedef struct MMI_SMI_TAG
{
    DECLARE_FUNCTBL(ISMI);    // function table pointer
    u32 refCnt;     // reference count
    /* Add custom fields below */
    MAE_Notifier_t *pNotifier;
    ITXI *pTXI;
    IMMSTRANSSRV *pIMMSTRANSSRV;
    IEVTCENTERSRV *pEvtCenterSrv;
    ISMS *pISMS;
    IACCESSORYSRV *pIAccessory;

    SMI_MsgSessionOperate_t CacheOperation;     // mark mode operation
    SMI_MsgOperate_t WaitCnfOperation;          // update msg and has to wait for TXI/MMS Cnf

    boolean bTerminate;
    boolean bRAIFull;
    u8 bRetrvCdMms;

    SMI_Available_MsgId_t AvaliableIDBlock[SMI_AvailableID_Total_BlockNum];
    SMI_Available_MsgId_t AvaliableIDBlock_SIM1[SMI_AvailableID_SIM1_BlockNum];
    SMI_Available_MsgId_t AvaliableIDBlock_SIM2[SMI_AvailableID_SIM2_BlockNum];
    SMI_Status_e SMIStatus;
    IBase *pSIMReloadRequester;    //Should be SMS instance.
    SMI_MsgHdrLst_t *pMsgHdrList[SMI_DUAL_SIM];
    SMI_SimMsgHdrLst_t *pSimMsgInfoList[SMI_DUAL_SIM];
    u16 SIMCapacity[SMI_DUAL_SIM];
    u16 SIMUsed[SMI_DUAL_SIM];
    SMI_ReadSIM_t *pReadSimMsg;     //record SIM Msg Info and wait read cnf for SIM Msg data retrieving
    IVectorModel *pWaitForDelete;
   	IArrayModel  *pWaitForSend;
} MMI_SMI;

/*=============================================================*/
// type, enum, and define
/*=============================================================*/

typedef enum
{
    //    SMI_MASTER_REQ_START = 0x00,
    SMI_MASTER_REQ_SIZE = 0x00
,     //Only request the list size (size, read number, sending number)
    SMI_MASTER_REQ_HDRLIST
,         //Request the whole list, SMI_MsgHdrLst_t structure
    SMI_MASTER_REQ_VECTOR_WITH_PARAM
,   //Request the items which follow the param, and then Add these items into VectorModel
    SMI_MASTER_REQ_ARRAY_WITH_PARAM
,   //Request the items which follow the param, and then Add these items into ArrayModel
    SMI_MASTER_REQ_TOTAL,
}SMI_MasterReq_Type_e;  //for the ReqType of the SMI_MasterReq_t

typedef struct SMI_MASTER_REQ_TAG
{
    u8 ReqType;     //The Request Type: SMI_MasterReq_Type_e
    SMI_MsgHdrLst_t *pMsgHdrList;   //if the ReqType is SMI_MASTER_REQ_HDRLIST => mmi_SMI_ListMasterMessage will malloc the whole Hdr List, and the user should release it
    IModel *pModel;           //the vector/array model for the list, if ReqType== SMI_MASTER_REQ_VECTOR_WITH_PARAM / SMI_MASTER_REQ_ARRAY_WITH_PARAM
    SMI_MSGHEADER_TRANSFER_FUNC_PTR pTransFunc; //The vector model transfer function
    void *pUserData;                           //The transfer function User Data
    SMI_LIST_PARAM VectorParam;                 //the param if ReqType==SMI_MASTER_REQ_VECTOR_WITH_PARAM
}SMI_MasterReq_t;   //The param for mmi_SMI_ListMasterMessage


/**
 * @par mmi_SMI_ResetCondition:
 * <PRE>
 *       Check if master file and available IDs need to be reset
 * </PRE>
 *
 * @param[in] pThis  Pointer to the MMI_SMI main struct.
 *
 * @retval NONE
 */
static boolean mmi_SMI_ResetCondition(MMI_SMI *pThis);

#ifdef SMI_TEST_FILE
/**
 * @par mmi_SMI_WriteTestingMasterFile:
 * <PRE>
 *       This function write the master file, and phone message file only for simulator testing use.
 * </PRE>
 *
 * @param[in] pThis  Pointer to the MMI_SMI main struct.
 *
 * @retval NONE
 */
static void mmi_SMI_WriteTestingMasterFile(MMI_SMI *pThis);
#endif //SMI_TEST_FILE

/**
 * @par mmi_SMI_GetMsgHdrList:
 * <PRE>
 *       (1) This function get the message header list from the master file according to the specific message location (please refer to mmi_common_sms_master.h)
 *       (2) The master file which include the specific location will be retrieved,
 *           since one master file might contain more then one location, the header list might include not only the message in the specific location
 *           Ex: master file MFINBOX contained the messages in MlSim1InBox, MlSim2InBox, MlInbox, MlPvInbox
 *               If user call:
 *                  nErr=mmi_SMI_GetMsgHdrList(pThis, MlSim1InBox, &pMsgHdrList)
 *               The pMsgHdrList is the whole message header list, retrieved from MFINBOX, so it contained not only the message in the MlSim1InBox,
 *               but also the messages in MlSim2InBox, MlInbox, MlPvInbox, and MLCblInbox
 *       (3) This function will malloc the header list for the API user, user should free it
 *           =>EX:
 *                  SMI_MsgHdrLst_t *pMsgHdrList = NULL;
 *                  MAE_Ret nErr=MAE_RET_SUCCESS;
 *                  nErr = mmi_SMI_GetMsgHdrList(pThis, MlDraft, &pMsgHdrList);
 *                  if(nErr==MAE_SUCCESS && pMsgHdrList)
 *                  {
 *                      .....
 *                  }
 *
 *                  //Free the header list get from the mmi_SMI_GetMsgHdrList
 *                  FREEIF(pMsgHdrList->pList);
 *                  FREEIF(pMsgHdrList);
 * </PRE>
 *
 * @param[in] pThis         Pointer to the MMI_SMI main struct.
 * @param[in] msgLocation   The specific message location coressponding to the master file that user want to retrieved
 * @param[out] ppMsgHdrList The message header list of the specific master file related to the msgLocation.
 *                          This API will malloc the memory for *ppMsgHdrList, and API user need to free it
 *
 * @retval MAE_RET_SUCCESS   - The message header list successfully retrieved.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_OUT_OF_MEMORY
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_GetMsgHdrList(MMI_SMI *pThis, SMI_MsgLocation_e msgLocation, SMI_MsgHdrLst_t **ppMsgHdrList);


/**
 * @par mmi_SMI_ListMasterMessage:
 * <PRE>
 *       (1) This function get the message lists or number of message from the specific master location specified by
 *           the param MasterLocation (refer to the enum SMI_MasterLocation_e) according to the request in
 *           param pMasterReq. The pMasterReq identiy what kind of information user want to retrieved,
 *           so if pMasterReq is NULL, this API will return MAE_RET_BAD_PARAM
 *       (2) There are three kinds of request type: (please refer to the enum SMI_MasterReq_Type_e)
 *           a. SMI_MASTER_REQ_SIZE: means user only want to get the message number information, but not the message list
 *              This API will malloc the memory for the pMasterReq->pMsgHdrList, and save the size information
 *              in pMasterReq->pMsgHdrList->ListHdr (please refer to SMI_MsgHdrLstHdr_t in mmi_common_sms_master.h)
 *              user should FREE the pMasterReq->pMsgHdrList memory
 *              =>Ex:
 *                  SMI_MasterReq_t MasterReq={0};
 *                  MAE_Ret nErr = MAE_RET_SUCCESS;
 *                  MasterReq.ReqType=SMI_MASTER_REQ_SIZE;
 *                  nErr=mmi_SMI_ListMasterMessage(pThis, SMI_MASTER_INBOX, &MasterReq);
 *                  if(nErr=MAE_RET_SUCCESS)
 *                  {
 *                      //The total number of message
 *                      u32 nMsg=0;
 *                      if(MasterReq.pMsgHdrList)
 *                          nMsg=MasterReq.pMsgHdrList->ListHdr.size
 *                       .....
 *                  }
 *                  //Free the message header list memory malloc by mmi_SMI_ListMasterMessage
 *                  FREEIF(MasterReq.pMsgHdrList);
 *           b. SMI_MASTER_REQ_HDRLIST: user want to get the whole message header list from the master file
 *              This API will malloc the memory for the pMasterReq->pMsgHdrList, and if there is any message belong to this master file
 *              This API will malloc the memory for the pMasterReq->pMsgHdrList->pList.It will save the size information
 *              in pMasterReq->pMsgHdrList->ListHdr (please refer to SMI_MsgHdrLstHdr_t in mmi_common_sms_master.h)
 *              and save the message header in pMasterReq->pMsgHdrList->pList, user should FREE these memory
 *              =>Ex:
 *                  SMI_MasterReq_t MasterReq={0};
 *                  MAE_Ret nErr = MAE_RET_SUCCESS;
 *                  MasterReq.ReqType=SMI_MASTER_REQ_SIZE;
 *                  nErr=mmi_SMI_ListMasterMessage(pThis, SMI_MASTER_INBOX, &MasterReq);
 *                  if(nErr=MAE_RET_SUCCESS && MasterReq.pMsgHdrList && MasterReq.pMsgHdrList->pList)
 *                  {
 *                      u32 idx;
 *                      for(idx=0;idx<MasterReq.pMsgHdrList->ListHdr.size;idx++)
 *                      {
 *                          //Operation for each message header
 *                          u32 MsgID=MasterReq.pMsgHdrList->pList[idx].u32MsgId;
 *                          ....
 *                      }
 *                  }
 *                  //Free the message header list memory malloc by mmi_SMI_ListMasterMessage
 *                  if(MasterReq.pMsgHdrList)
 *                  {
 *                      FREEIF(MasterReq.pMsgHdrList->pList);
 *                  }
 *                  FREEIF(MasterReq.pMsgHdrList);
 *           c. SMI_MASTER_REQ_VECTOR_WITH_PARAM: user want to get the items which fits the requirement set
 *              in MasterReq.VectorParam (please refer to SMI_LIST_PARM in mmi_common_sms_master.h)
 *              These items will transfer to the structure point by the transfer function set in MasterReq.pTransFunc
 *              and then insert to the top of the Vector Model MasterReq.pVectorModel,
 *              so if MasterReq.pTransFunc is NULL or MasterReq.pVectorModel is NULL, this API will return MAE_RET_BAD_PARAM
 *              The Vector Model should set the free function according to the transfer function MasterReq.pTransFunc
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] MasterLocation    The specific master location (please refer to SMI_MasterLocation_e)
 * @param[in,out] ppMsgHdrList  The pointer of List information Request
 *
 * @retval MAE_RET_SUCCESS   - The message list information successfully retrieved.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_OUT_OF_MEMORY
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_ListMasterMessage(MMI_SMI *pThis, u8 MasterLocation, SMI_MasterReq_t *pMasterReq, SMI_SmsSimMsgBox_e SmsSimMsgBox);

/**
* mmi_SMI_SearchMsgInMasterFile
* @brief    To get the master request "SMI_MasterReq_t" and location index in the master file for the specific message id
*
* @param[in]    pThis                       The pointer of ISMI object.
* @param[in]    MsgId                       The id of the message.
* @param[out]   pMasterReq                  The pointer of the master request.
* @param[out]   locIdx                      The index of the message list.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_SearchMsgInMasterFile(MMI_SMI *pThis, SMI_MsgID_t MsgId, SMI_MasterReq_t *pMasterReq, s32 *locIdx);

/**
* mmi_SMI_GetMsgType
* @brief    To get the message type for the specific message id and location
*
* @param[in]    pThis                       The pointer of ISMI object.
* @param[in]    MsgId                       The id of the message.
* @param[in]    msgLocation                 The location folder of the message.
* @param[out]   pMsgType                    The pointer of the message type.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_GetMsgType(MMI_SMI *pThis, SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MsgType_e *pMsgType);

/**
 * @par mmi_SMI_GetAvailableID:
 * <PRE>
 *       This function will get one Available ID or Current Available IDs from MSGIDFILE file,
 *       The Current Available IDs means the pointer of SMI_Available_MsgId_t (please refer to mmi_common_sms_master.h)
 *       (1) if pAvailableID is not NULL => get one Available ID from the MSGIDFILE file, and save to *pAvailableID
 *       (2) if ppCacheID is not NULL, this API will malloc the memory for the *ppCacheID and then save the Current Available IDs in it.
 *           if pAvailableID is not NULL either, then the Current Available IDs, ppCacheID, won't include the ID saved in pAvailableID
 *       (3)The ppCache ID don't need to Free it
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] MsgType           The Message type.
 * @param[out] pAvailableID     The pointer to get one available ID
 * @param[out] ppCacheID        The pointer to cached whole Current Available IDs excluding the *pAvailableID, user need to free (*ppCacheID)->pRecycleIDList, and *ppCacheID
 *
 * @retval MAE_RET_SUCCESS   - The Available ID / Current Available IDs successfully retrieved.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_OUT_OF_MEMORY
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_GetAvailableID(MMI_SMI *pThis, SMI_MsgID_Type_e MsgType, SMI_MsgID_t *pAvailableID, SMI_Available_MsgId_t **ppCacheID);

/**
 * @par mmi_SMI_DelAvailableIDFromCache:
 * <PRE>
 *       This function delete the available ID from the Cached Available IDs,
 *       This ID needs to be deleted should be the next Available ID in the Cached Available IDs,
 *       Otherwise, this API will return MAE_RET_NOT_FOUND.
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] AvailableID       The ID needs to be deleted from the Cached Available ID
 * @param[in,out] pCacheID      The Cached Available ID needs to be updated
 *
 * @retval MAE_RET_SUCCESS   - The Available ID has been deleted from the specific Cached Available IDs successfully.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_NOT_FOUND
 */
static MAE_Ret mmi_SMI_DelAvailableIDFromCache(MMI_SMI *pThis, SMI_MsgID_t AvailableID, SMI_Available_MsgId_t *pCacheID);

/**
 * @par mmi_SMI_AvailableIDRecycle:
 * <PRE>
 *       This function recycle the available ID to the file or Cached Available IDs.
 *       If the pCacheID is not NULL means recycle the available ID to the Cached Available IDs pCacheID,
 *       otherwise recycle the available ID to the MSGIDFILE file
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] AvailableID       The ID could be recycle as Available ID
 * @param[in,out] pCacheID     The Cached Available ID needs to be updated. If it is NULL meas update the Available IDs file MSGIDFILE
 *
 * @retval MAE_RET_SUCCESS   - The Available ID recycle successfully.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_OUT_OF_MEMORY
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_AvailableIDRecycle(MMI_SMI *pThis, SMI_MsgID_t AvailableID, SMI_Available_MsgId_t *pCacheID);

/**
 * @par mmi_SMI_ResetAvailableID:
 * <PRE>
 *       This function will reset the Available IDs according to master file
 * </PRE>
 *
 * @param[in] pThis         Pointer to the MMI_SMI main struct.
 *
 * @retval NONE
 */
static void mmi_SMI_ResetAvailableID(MMI_SMI *pThis);

/**
 * @fn      mmi_SMI_AddMsgInHdrList:
 * @brief   Add the message header to the specific message header list, and update the
 *        Message Header List size information(total number, private number, read number, sending number...)
 *
 * @param[in] pMsgHdr         Pointer to the message header
 * @param[in,out] pMsgHdrList     Pointer to the message header list
 * @param[in] bNeedReAllocate   if this API need to reallocate the message List in pMsgHdrList
 *
 * @retval MAE_RET_SUCCESS          Success
 * @retval MAE_RET_BAD_PARAM            Invalid paramter
 * @retval MAE_RET_OUT_OF_MEMORY    No memory
 * @retval MAE_RET_FAILED           Error
 */
static MAE_Ret mmi_SMI_AddMsgInHdrList(SMI_MsgHdr_t *pMsgHdr, SMI_MsgHdrLst_t *pMsgHdrList, boolean bNeedReAllocate);

/**
 * @par     mmi_SMI_InsertMsgInHdrListByTime:
 *
 * <PRE>
 *       (1) Insert the message header to the specific message header list according to the time stamp in the message header
 *       (2) Update the Message Header List size information(total number, private number, read number, sending number...)
 *       (3) Update the inserted msg index information into pIndexInfo if pIndexInfo is not NULL pointer
 *
 * @param[in] pMsgHdr           Pointer to the message header
 * @param[in,out] pMsgHdrList   Pointer to the message header list
 * @param[in] bNeedReAllocate   if this API need to reallocate the message List in pMsgHdrList
 * @param[out] pIndexInfo       Pointer to the new message index info structure
 *
 * @retval MAE_RET_SUCCESS          Success
 * @retval MAE_RET_BAD_PARAM            Invalid paramter
 * @retval MAE_RET_OUT_OF_MEMORY    No memory
 * @retval MAE_RET_FAILED           Error
 */
static MAE_Ret mmi_SMI_InsertMsgInHdrListByTime(SMI_MsgHdr_t *pMsgHdr, SMI_MsgHdrLst_t *pMsgHdrList, boolean bNeedReAllocate, SMI_MsgBoxIndexInfo_t *pIndexInfo);

/**
 * @par     mmi_SMI_AddMessageInMasterFile
 *
 * <PRE> Implement the ISMI_AddMessageParamsAsync (ISMI_AddMessageParamsAsync for not support FILE_READ_WRITE_PLUS filemgr version)
 *       (1) Add new message into the master file according to the message location identify in the msg header
 *       (2) Rename the temp file as the msg file name according to the new msg ID
 *       (3) Update the Message Header List size information(total number, private number, read number, sending number...) in the master file
 *       (4) if bSortByTime is TRUE, insert the msg into the master file according to the timestamp. otherwise, treat the new msg as the newest msg
 *       (5) Update the master file and available IDs file
 *       (6) Update the Cached master buffer, and cached available IDs buffer
 *       (7) Do Notify SMI_EVT_AddMsgNotify or SMI_EVT_AddMsgSortByTimeNotify
 *
 * @param[in] pISMI             Pointer to the ISMI instance
 * @param[in] pMsgHdr           Pointer to the message header
 * @param[in] bSortByTime       Add the msg as the newest msg, or insert it into the master file according to the time stamp
 *
 * @retval MAE_RET_SUCCESS          Success
 * @retval MAE_RET_BAD_PARAM            Invalid paramter
 * @retval MAE_RET_OUT_OF_MEMORY    No memory
 * @retval MAE_RET_FAILED           Error
 */
static MAE_Ret mmi_SMI_AddMessageInMasterFile(ISMI *pISMI, SMI_MsgHdr_t *pMsgHdr, boolean bSortByTime);
/**
 * @fn      mmi_SMI_DelMsgInHrdList:
 * @brief   Delete the message header from the message header list for the specific message id,
 *        and update the Message Header List size information(total number, private number, read number, sending number...)
 *
 * @param[in] MsgId               Message ID
 * @param[in] SMI_MsgLocation_e   message location
 * @param[in,out] pMsgHdrList     Pointer to the message header list
 * @param[in] bNeedReAllocate   if this API need to reallocate the message List in pMsgHdrList
 *
 * @retval MAE_RET_SUCCESS      Success
 * @retval MAE_RET_BAD_PARAM        Invalid paramter
 * @retval MAE_RET_NOT_FOUND    can't find the message with the specific message ID in the message header list
 * @retval MAE_RET_FAILED       Error
 */
static MAE_Ret mmi_SMI_DelMsgInHrdList(SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MsgHdrLst_t *pMsgHdrLst, boolean bNeedReAllocate);

/**
 * @fn      mmi_SMI_GetMsgInfo:
 * @brief   Get the message header index in the message header list for the specific message id
 *        If the message with the specific ID was found, it will return the message index (0-base) in the message header list.
 *        Otherwise, the return value will be idxNULL (-1)
 *
 * @param[in] MsgId        Message ID
 * @param[in] pMsgHdrList     Pointer to the message header list
 *
 * @retval idxNULL: define as -1, not found the message with the specific ID
 * @retval index  : the 0-base index of the message header list
 */
static s32 mmi_SMI_GetMsgInfo(SMI_MsgID_t MsgId, SMI_MsgHdrLst_t *pMsgHdrLst);

/**
 * @fn      mmi_SMI_UpdateMsgInHdrList:
 * @brief   Update the message header information of the message header list for the specific message id
 *
 * @param[in] pMsgHdr         Pointer to the message header
 * @param[in,out] pMsgHdrList     Pointer to the message header list
 *
 * @retval MAE_RET_SUCCESS    Success
 * @retval MAE_RET_BAD_PARAM      Invalid paramter
 * @retval MAE_RET_OUT_OF_MEMORY   No memory
 * @retval MAE_RET_FAILED     Error
 */
static MAE_Ret mmi_SMI_UpdateMsgInHdrList(SMI_MsgHdr_t *pMsgHdr, SMI_MsgHdrLst_t *pMsgHdrList);

/**
 * @par mmi_SMI_WriteMsgHdrList:
 * <PRE>
 *       This function write the Message Header list as the specific master file according to the
 *       master location (please refer to the enum SMI_MasterLocation_e).
 *       If the bTemp is TRUE, the message header list will be write as a temp Master file
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] MasterLocation    The specific master location to identify the master file (please refer to SMI_MasterLocation_e)
 * @param[in] pMsgHdrList       The pointer of Message Header List that need to be write as the master file or temp master file
 * @param[in] bTemp             Write to the temp master file or the real master file
 *
 * @retval MAE_RET_SUCCESS   - The message header list has been write as the master or temp master file successfully.
 * @retval MAE_RET_BAD_PARAM
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_WriteMsgHdrList(MMI_SMI *pThis, u8 MasterLocation, SMI_MsgHdrLst_t *pMsgHdrList, boolean bTemp);

/**
 * @par mmi_SMI_HandleTempMasterFile:
 * <PRE>
 *       This function repleace or delete all temp master file and temp MSGIDFILE(Available IDs) file
 *       If the bReplaceReal is TRUE, all these temp master and temp MSGIDFILE files will be rename as the real file, but not the temp file.
 *       Otherwise, all these temp files will be deleted
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] bReplaceReal      Repleace the temp files as the real files or Delete the temp files
 *
 * @retval MAE_RET_SUCCESS
 * @retval MAE_RET_FAILED
 */
#ifdef SMI_SUPPORT_TEMP_FILE
static MAE_Ret mmi_SMI_HandleTempMasterFile(MMI_SMI *pThis, boolean bReplaceReal);
#endif

/**
 * @par mmi_SMI_WriteFile:
 * <PRE>
 *       This function write the buffer into the specific file to support the IFILEMGR_OpenFile without "r+" mode
 *       (1) if *ppFileStream is NOT NULL, this function will release the original *ppFileStream
 *       (2) This function will open the specific file with the pFilePath, and write the pWriteBuf with specific size into the file Offset bytes
 *       (3) The file should in the MFMSGPATH folder (please refer to the mmi_common_sms_master.h)
 *       (4) The length of the filepath (including the file name) should smaller then the (MAX_FILE_FULL_PATH_LEN - the length of TEMP_FILE_POSTFIX)   (please refer to the mmi_common_sms_master.h)
 *       (5) If the file was write successfully, the *ppFileStream will be the new file stream with the correct seek bytes(Offset+size) from the begin of the file
 *       (6) User of the API need to release the *ppFileStream
 *           Ex:
 *              IFStream *pFileStream=NULL;
 *              MAE_WChar pTempFilePath=L"fs:/NAND/SMS/test_temp";
 *              MAE_Ret nErr=MAE_RET_SUCCESS;
 *              nErr=mmi_SMI_WriteFile(pThis, &pIFStream, pTempFilePath, 0, pMsgHdrList, sizeof(SMI_MsgHdrLstHdr_t)); //write the pMsgHdrList buffer with sizeof(SMI_MsgHdrLstHdr_t) size into "fs:/NAND/SMS/test_temp" file
 *              if(nErr==MAE_FS_ERROR)
 *              {
 *                  nErr=MAE_RET_FAILED;
 *              }
 *              else
 *              {
 *                  nErr=MAE_RET_SUCCESS;
 *                  .......
 *              }
 *              //release the file stream
 *              RELEASEIF(pIFStream, (IBase *)pThis);
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct, and the owner of the new *ppFileStream
 * @param[in,out] ppFileStream  [in]: Point to the pointer of the original file stream, this function will release the original one
 * @param[in,out] ppFileStream  [out]:Point to the pointer of the new file stream with the correct seek bytes (Offset+size) from the begin of the file
 * @param[in] pFilePath         The pointer of the file path (with NULL terminator), the file should in the MFMSGPATH folder, and the length of the pFilePath should < (MAX_FILE_FULL_PATH_LEN - the length of TEMP_FILE_POSTFIX)
 * @param[in] Offset            The number of bytes Offset from the begin of file to write the buffer
 * @param[in] pWriteBuf         Pointer to buffer that need to write to the specific file on the specific Offset
 * @param[in] size              Ther buffer size of the pWriteBuf
 *
 * @retval MAE_FS_ERROR         Error to write the file.
 * @retval Others               Number of bytes of the pWriteBuf has been written
 */
//static u32 mmi_SMI_WriteFile(MMI_SMI *pThis, IFStream **ppFileStream, MAE_WChar *pFilePath, u32 Offset, void *pWriteBuf, u32 size);


/**
 * @par mmi_SMI_GetMasterLocationByMsgLocation:
 * <PRE>
 *       This function transfer the message Location into the corresponding master location (pleace refer to the enum SMI_MasterLocation_e)
 * </PRE>
 *
 * @param[in] msgLocation       The specific message location (please refer to mmi_common_sms_master.h)
 *
 * @retval SMI_MASTER_UNKNOWN   can't find the corresponding master location
 * @retval Others               The corresponding master location (pleaser refer to the enum SMI_MasterLocation_e)
 */
static SMI_MasterLocation_e mmi_SMI_GetMasterLocationByMsgLocation(SMI_MsgLocation_e msgLocation);

/**
 * @par mmi_SMI_GetBoxParamByMsgLocation:
 * <PRE>
 *       This function transfer the message Location into the SMI_LIST_PARAM mask condition,
 *       (1) Using this function, message locations belong to the same Msg Box (please refer to the mmi_common_sms_master.h)
 *           will get the same SMI_LIST_PARAM
 *       (2) This function only consider the Msg Box and storage mask of the SMI_LIST_PARAM, but no other mask
 * </PRE>
 *
 * @param[in] msgLocation       The specific message location (please refer to mmi_common_sms_master.h)
 * @retval SMI_LIST_PARAM       The SMI_LIST_PARAM with the Msg Box corresponding to the msgLocation
 */
static SMI_LIST_PARAM mmi_SMI_GetBoxParamByMsgLocation(SMI_MsgLocation_e msgLocation);

/**
 * @par mmi_SMI_NotifyEventCleanup:
 * <PRE>
 *       This function is the Clean function fnClean for NOTIFIER_NotifyEx.
 *       It is use to clean the Update Vector model which transfer with the SMI notify event
 * </PRE>
 *
 * @param[in] lParam       The param1 of the NOTIFIER_NotifyEx
 * @param[in] dParam       The param2 of the NOTIFIER_NotifyEx=>the pointer of Update Vector model transfer with the SMI_notify event
 * @param[in] pOwner       Pointer to the owner of the dParam
 *
 * @retval NONE
 */
static void mmi_SMI_NotifyEventCleanup(IBase *pOwner, u32 lParam, u32 dParam);

/**
 * @par mmi_SMI_NewUpdateVector:
 * <PRE>
 *       This function will create a new Update Vector Model in pThis->CacheOperation.pUpdateVector for mmi_SMI_UtilBeginUpdateHeader.
 *       And set the free function to this vector model
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 *
 * @retval MAE_RET_SUCCESS              - The new Update Vector Model is create successfully.
 * @retval MAE_RET_ILLEGAL_OPERATION    - If there CacheOperation is not empty, should create a new vector model for the Cache operation
 * @retval MAE_RET_FAILED
 */
static MAE_Ret mmi_SMI_NewUpdateList(MMI_SMI *pThis);

/**
 * @par mmi_SMI_UpdateVectorFreeItem:
 * <PRE>
 *       This function is free function for the Update Vector Model
 * </PRE>
 *
 * @param[in] pData             Pointer to the data that saved in the Update Vector Model
 * @param[in] pOwner            Pointer to the Owner of the pData
 *
 * @retval NONE
 */
static void mmi_SMI_UpdateListFreeItem(void *pData, IBase *pOwner);
/**
 * @par mmi_SMI_UtilCommit:
 * <PRE>
 *       This function will operate the rest operations in the pThis->CacheOperation.pUpdateVector
 *       If all operation is done
 *          => (1)It will clean the pThis->CacheOperation
 *             (2)Save all Cached data into master and Available IDs file MSGIDFILE
 *             (3)Notify all Register instance the operation notify event
 *             (4)If the Operation status is not cancel, it will Post the Operation status to the instance who call
 *                the ISMI_UtilBeginUpdateHeader to begin the operation
 *       Otherwise, record the waiting confirm operation information in the pThis->CacheOperation
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] bCurrentContext   If the pThis is current context
 * @param[in] bNotifyNotBusy    If need to notify not busy
 *
 * @retval MAE_RET_SUCCESS      - The operation is operate successfully.
 * @retval Others               - The operation is failed.
 */
static MAE_Ret mmi_SMI_UtilCommit(MMI_SMI *pThis, boolean bCurrentContext, boolean bNotifyNotBusy);

/**
 * @par mmi_SMI_UtilCommitOperate:
 * <PRE>
 *       (1)This function operate the specific operation in pNotifyInfo, and update the Cached Message header list (cached master file)
 *          and the Cached Available IDs
 *       (2)The operation command is set in pThis->CacheOperation.command
 *       (3)The operation message ID and src, des location and some operateion details and result will record in pNotifyInfo
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in,out] pNotifyInfo   The Pointer of the details of the specific operation
 * @param[in] srcMasterFile     The source master location (pleaser refer to the enum SMI_MasterLocation_e), it identify which Cahced master message header list is the source master
 * @param[in] MsgInfoIdx        The message header index of the source master (the cached message header list identify by the srcMasterFile)
 * @param[in] bTXIRelated       Identify if the current operation is TXI related (need to operate through ril TXI and ril interface)
 *
 * @retval MAE_RET_SUCCESS      - The operation is operate successfully.
 * @retval Others               - The operation is failed.
 */
static MAE_Ret mmi_SMI_UtilCommitOperate(MMI_SMI *pThis, SMI_NotifyInfo_t *pNotifyInfo, SMI_MasterLocation_e srcMasterFile, s32 MsgInfoIdx, boolean bTXIRelated);

void mmi_SMI_UpdateCacheStatus(SMI_Update_Status_e *pCacheStatus, const SMI_Operate_Status_e NewOperateStatus);

/**
 * @par mmi_SMI_UtilTXIRelatedOperate:
 * <PRE>
 *       (1)This function operate the message operation related to the SIM message by calling the TXI interface
 *       (2)If the message operation is related to the TXI, then it will call the TXI interface.
 *          Since TXI operation interface are async API, mmi_SMI_UtilTXIRelatedOperate will return SMI_TXI_WAITING
 *       (3)If the message operation is no need to call the TXI API, then mmi_SMI_UtilTXIRelatedOperate will return SMI_TXI_OPERATE_DONE
 * </PRE>
 *
 * @param[in] pThis             Pointer to the MMI_SMI main struct.
 * @param[in] pNotifyInfo       The Pointer of the details of the specific operation
 * @param[in] srcMasterFile     The source master location (pleaser refer to the enum SMI_MasterLocation_e), it identify which Cahced master message header list is the source master
 * @param[in] MsgInfoIdx        The message header index of the source master (the cached message header list identify by the srcMasterFile)
 *
 * @retval SMI_OPERATE_WAITING      - The operation is TXI related operation, and now is waiting for the TXI confirm
 * @retval SMI_OPERATE_FAIL - The operation is TXI related operation, but the TXI return operation failed, and we don't need to wait the TXI confirm
 * @retval SMI_OPERATE_DONE - The operation is not TXI related operation
 * @retval SMI_OPERATE_BAD_PARAM
 * @retval SMI_OPERATE_OUT_OF_MEMORY
 */
static SMI_Operate_Result_e mmi_SMI_UtilTXIRelatedOperate(MMI_SMI *pThis, SMI_NotifyInfo_t *pNotifyInfo, SMI_MasterLocation_e srcMasterFile, s32 MsgInfoIdx);
boolean SMI_CheckConfirmForCacheOperation(MMI_SMI *pThis, MAE_EventId eventID, u32 param1, u32 param2);
//boolean SMI_MmsConfirmForCacheOperation(MMI_SMI *pThis, MAE_EventId eventID, u32 param1, u32 param2);

/**
* mmi_SMI_GetPrvInfoByMsgLocation
* @brief    Check if the message location folder is private
*
* @param[in]    msgLoc                  The location of the message.
* @param[out]   bPrv                    The pointer of the private flag.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_GetPrvInfoByMsgLocation(SMI_MsgLocation_e msgLoc, boolean *bPrv);

/**
* mmi_SMI_UtilOperation
* @brief    Use to operate command "SMI_Update_Command_e"
*
* @param[in]    pISMI               Pointer to the MMI_SMI main struct.
* @param[in]    MsgId               The message id.
* @param[in]    cmd                 The update command.
* @param[in]    value               The modified value.
* @param[in]    msgLoc              The message location.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_UtilOperation(ISMI *pISMI, SMI_MsgID_t MsgId, SMI_Update_Command_e cmd, u8 value, SMI_MsgLocation_e msgLoc);

/**
* mmi_SMI_DeleteSIMMsgFromMasterFile
* @brief    To delete SIM message information in master files
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    DelSIM              The id of the SIM module.
* @param[in]    bPowerOnReset       If power on reset, set the flag "TRUE";vice versa.
* @param[in]    pRequester          The pointer of the request instance.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_DeleteSIMMsgFromMasterFile(MMI_SMI *pThis, u8 DelSIM, boolean bPowerOnReset, IBase *pRequester);

/**
* mmi_SMI_DeleteMsgBody
* @brief    To delete the data file for the message id.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    MsgId               The message id.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_DeleteMsgBody(MMI_SMI *pThis, SMI_MsgID_t MsgId);

/**
* mmi_SMI_DeletePhoneMsg
* @brief    To delete the message data in the phone storage.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    MsgId               The message id.
* @param[in]    MmiSmsRslt          The command result input.
* @param[in]    msgLocation         The message location.
* @param[in]    pinst               The pointer of the request instance.
* @param[in]    bCurrentContext     If it is the current context, set the flag as "TRUE";vice versa.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_DeletePhoneMsg(MMI_SMI *pThis, SMI_MsgID_t MsgId, MMI_SMS_Rslt_e MmiSmsRslt, SMI_MsgLocation_e msgLocation, void *pinst, boolean bCurrentContext);

/**
* mmi_SMI_DeleteMsg
* @brief    To delete the message data for the message id.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    MsgId               The message id.
* @param[in]    msgLocation         The message location.
* @param[in]    pinst               The pointer of the request instance.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_DeleteMsg(MMI_SMI *pThis, SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, void *pinst);

/**
* mmi_SMI_ModifyMsg
* @brief    To modify the message data for the message id.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    MsgId               The message id.
* @param[in]    MmiSmsRslt          The command result input.
* @param[in]    msgLocation         The message location.
* @param[in]    pMsgHdr             Pointer to the modified message header information.
* @param[in]    pinst               The pointer of the request instance.
* @param[in]    bCurrentContext     If it is the current context, set the flag as "TRUE";vice versa.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_ModifyMsg(MMI_SMI *pThis, SMI_MsgID_t MsgId, MMI_SMS_Rslt_e MmiSmsRslt, SMI_MsgLocation_e msgLocation, SMI_MsgHdr_t *pMsgHdr, void *pinst, boolean bCurrentContext);

/**
* mmi_SMI_SetWaitCnfOperation
* @brief    To set the operation information of the wait confirm.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    msgLocation         The message location.
* @param[in]    CnfEventID          The event id of the confirm.
* @param[in]    pReqInst            The pointer of the request instance.
* @param[in]    pMsgHdr             Pointer to the modified message header information.
*
*/
static void mmi_SMI_SetWaitCnfOperation(MMI_SMI *pThis, SMI_MsgLocation_e msgLocation, u32 CnfEventID, void *pReqInst, SMI_MsgHdr_t *pMsgHdr);

/**
* mmi_SMI_ClearWaitCnfOperation
* @brief    To clear the operation information of the wait confirm.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
*
*/
static void mmi_SMI_ClearWaitCnfOperation(MMI_SMI *pThis);

/**
* mmi_SMI_AddSMSByReadCnf
* @brief    To add the message info to RAI for the TXI read message confirm.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    pReadCnf            Pointer to TXI read confirm "MMI_SMS_ReadCnf_t".
* @param[in]    simIdx              The index of the SIM PDU.
* @param[in]    bSIMMsg             If it's the SIM message, set as "TRUE";vice versa.
* @param[in]    bAppend             If the PDU need to been appended, set as "TRUE";vice versa.
* @param[out]   pMsgLoc             Pointer to message location.
* @param[out]   pMsgID              Pointer to message id.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
MAE_Ret mmi_SMI_AddSMSByReadCnf(MMI_SMI *pThis, MMI_SMS_ReadCnf_t *pReadCnf, s16 simIdx, boolean bSIMMsg, boolean bAppend, SMI_MsgLocation_e *pMsgLoc, SMI_MsgID_t *pMsgID);
static MAE_Ret mmi_SMI_AddNotify(IArrayModel *pArrModel, SMI_Operate_Status_e OperateStatus, SMI_MsgID_t MsgId, SMI_MsgLocation_e srcLoc, SMI_MsgLocation_e desLoc, u8 newStatus);
void mmi_SMI_DoNotifyResumeCB(IBase *pObj, u32 Param);
void mmi_SMI_PostConfirmResumeCB(IBase *pObj, u32 Param);
static MAE_Ret mmi_SMI_ContextSwitchDoNotify(MMI_SMI *pThis, u32 NotifyMask, MAE_EventId NotifyEvent, u32 OperateBoxParam, IArrayModel *pUpdateList, PfnEventCleanup pCleanFnc);
static MAE_Ret mmi_SMI_ContextSwitchPostEvent(MMI_SMI *pThis, void *pDesInst, MAE_EventId ConfEvent, u32 Param1, u32 Param2);

/**
* mmi_SMI_DelSimMsgInLstBuf
* @brief    To delete the SIM message info in the SIM message list.
*
* @param[in]    MsgId                   The message id.
* @param[in]    pSimMsgInfoList         Pointer to SIM message list information.
* @param[out]   pNumSimPDU              Pointer to PDU number of the SIM message.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_DelSimMsgInLstBuf(SMI_MsgID_t MsgId, SMI_SimMsgHdrLst_t *pSimMsgInfoList, u8 *pNumSimPDU);

/**
* mmi_SMI_QuerySIMCapacity
* @brief    To query the capacity of the SIM storage. Need to wait the confirm result in handle event.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    SIMID               The id of the SIM module.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_QuerySIMCapacity(MMI_SMI *pThis, u8 SIMID);

/**
* mmi_SMI_QuerySIMCapacity
* @brief    To query the capacity of the SIM storage. Need to wait the confirm result in handle event.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    SIMID               The id of the SIM module.
* @param[in]    nTotal              The total SIM PDU space number.
* @param[in]    nUsed               The used SIM PDU space number.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_ReadAllSMSInSIM(MMI_SMI *pThis, u8 SIMID, u16 nTotal, u16 nUsed);

/**
* mmi_SMI_FreeSIMCacheBuffer
* @brief    To free cached buffer of the SIM related information.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    SIMID               The id of the SIM module.
*
*/
static void mmi_SMI_FreeSIMCacheBuffer(MMI_SMI *pThis, u8 SIMID);

/**
* mmi_SMI_CancelCurrentOperation
* @brief    To cancel the current cached operation.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    SIMID               The id of the SIM module.
* @param[out]   pbNeedDelay         Pointer to check if the cancel operation need to been waited.
*
*/
static void mmi_SMI_CancelCurrentOperation(MMI_SMI *pThis, u8 SIMID, boolean *pbNeedDelay);

/**
* mmi_SMI_CheckDelaySIMInit
* @brief    To check if SIM busy.
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[out]   pbBusy              Pointer to check if SIM retrieving.
*
* @retval       TRUE                SIM info updating
* @retval       FALSE               No SIM info updating
*/
static boolean mmi_SMI_CheckDelaySIMInit(MMI_SMI *pThis, boolean *pbBusy);

/**
* mmi_SMI_SaveReadSIMData
* @brief    To save read SIM data to the SIM message read buffer
*
* @param[in]    pThis               Pointer to the MMI_SMI main struct.
* @param[in]    pReadCnf            Pointer to SIM message PDU read confirm data.
*
* @retval       MAE_RET_SUCCESS             Accepts the request
* @retval       others                      Exception
*/
static MAE_Ret mmi_SMI_SaveReadSIMData(MMI_SMI *pThis, MMI_SMS_ReadCnf_t *pReadCnf);

/**
* mmi_SMI_ReadCnfFree
* @brief    To free the SIM message data buffer
*
* @param[in]    pThis               Pointer to the caller.
* @param[in]    lParam              First parameter.
* @param[in]    dParam              Second parameter.
*
*/
static void mmi_SMI_ReadCnfFree(IBase *pIssuer, u32 lParam, u32 dParam);

//static void mmi_SMI_RetrvSimMsgDataCnf(MMI_SMS_ReadCnf_t *pReadCnf);

#ifndef BREAKIF_NOTSUCCESS
#define BREAKIF_NOTSUCCESS(r) if(MAE_RET_SUCCESS != r) { break; }
#endif /* IF BREAKIF_NOTSUCCESS */

#ifndef RETURNIF_NOTSUCCESS
#define RETURNIF_NOTSUCCESS(r) if(MAE_RET_SUCCESS != r) { return r; }
#endif /* IF RETURNIF_NOTSUCCESS */

#endif /* __MMI_MESSAGEMANAGERSRV_PRIV_H__ */
