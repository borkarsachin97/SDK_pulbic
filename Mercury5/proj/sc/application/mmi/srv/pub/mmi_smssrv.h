/**
* @file mmi_sms.h
*
* State Machine Service - SMS
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_SMS
*
*
* @version $Id: mmi_sms.h 33461 2009-06-16 08:06:40Z mark.yang $
*/
#ifndef __MMI_SMS_H__
#define __MMI_SMS_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"
#include "mmi_messagemanagersrv.h"
#include "mmi_mae_vectormodel.h"
#include "mmi_mae_notifier.h"
#include "mmi_message_cfg.h"
#include "mmi_common_sim.h"
#include "mmi_common_sms_master.h"
#ifdef __AUTO_TEST_SCRIPT__
#include "mmi_common_util.h"
#endif

#define Max_Sending_Queue                  20
#define BusyHandle                              /* do not limit user's sending*/

enum
{
    SMS_Notify_Mask_Ready = 0x0001
   ,/*for service ready notify*/
    SMS_Notify_Mask_Sending_Start = 0x0002
   ,SMS_Notify_Mask_Sending_Finish = 0x0004
   ,SMS_Notify_Mask_ScaSetting = 0x0008
   ,SMS_Notify_Mask_SIMChange = 0x0010
   ,SMS_Notify_Mask_SEND_CNF = 0x0020             //  for ISMS_Send_Message_byData()
   ,SMS_Notify_Mask_BUFF_MESSAGE_IND = 0x0040
};
typedef u8 SMS_Notify_Mask_e;

typedef enum
{
    ScaSetting_Success = 0
   ,ScaSetting_Fail = 1,
} SMS_ScaSetting_Conf_e;

typedef enum
{
    READY_WITH_SIM = 0
   ,READY_NO_SIM = 1,
} SMS_READY_STATUS_e;
typedef enum
{
    SENDING_READY = 0
 ,  // ready to send
    SENDING_FAIL       // already fail while saving at outbox, it is case of sending fail.
} SMS_SENDING_STATUS_e;
typedef struct SMS_MSG_ITEMDATA_TAG
{
    u8 simModule;
    SMI_MsgID_t u16MsgId;
    SMS_SENDING_STATUS_e eFailItem;          //  it fails while saved to outbox. but this case is treated as sending fail for user.
}SMS_Msg_ItemData_t;

typedef struct SMS_MSG_ITEM_DATA_EX_TAG
{
    SMS_Msg_ItemData_t          Base;
    SMI_MsgFlag                 Flag;
    SMS_MsgRecipLst             RecipList;
    SMI_SmEncoding_t            Encoding;
    mmiGsmLockShiftTable_e      LockTable;
    mmiGsmSingleShiftTable_e    SingleTable;
    MAE_WChar                   *pMsgCnt;
    u16                         MsgCntStrlen;
    u16                         Port;
    boolean                     IsPrivateMsg;
#ifdef __SMART_MESSAGING_MMI_SUPPORT__
    boolean                     IsWapVCardMsg;
#endif /* __SMART_MESSAGING_MMI_SUPPORT__ */
} SMS_Msg_ItemDataEx_t;

// for ISMS_Send_Message_byData()
typedef struct SMS_MSG_SENTDATA_TAG
{
    u8 simModule;
    u16 telNoLen;
    u16 dataLen;
    u16 *ptTelNo;
    u16 *ptData;
    boolean bRetry;
    SMI_SmEncoding_t tEncoding;
}SMS_MSG_SentData_t;

// for SMS_EVT_Message_Send_ByData_CNF
enum
{
    SMS_SEND_SUCCESS = 0
   ,SMS_SEND_FAIL
   ,SMS_SEND_NETWORK_FAIL
   ,SMS_SAVETOOUTBOX_FAIL
};
typedef u8 SMS_SEND_CNF_STATUS;

enum
{
    SMS_RECEIVE_TYPE_CB = 0
   ,SMS_RECEIVE_TYPE_SMS
};
typedef u8 SMS_RECEIVE_TYPE_e; // for JAVA
typedef struct SMS_SEND_RESULT_TAG
{
    SMS_SEND_CNF_STATUS eResult;
    u8 page;
    SMI_MsgID_t MsgID;
} SMS_Send_Result_t;

typedef struct
{
    u8 simModule;
    u8 telNoLen;
    u16 dataLen;
    u16 *ptTelNo;
    u16 *ptData;
    SMI_SmEncoding_t encoding;
    u16 nPort;
}SMS_3rd_ReceiveData_t;
typedef void (*pfn_sms_receive_CB)(SMI_MsgID_t nMsgID, u32 nPort, u8 nSIMModule, u32 nDatasize, u32 nTelLen, u32 userData, u32 CallerID);
typedef void (*pfn_sms_send_CB)(IBase *pObj, u32 userData, SMS_Send_Result_t *pResult);

/**
 * External Events
 */
#define SMS_EVT_Send_Message                (CLSID_SMS << 16 | 1)
#define SMS_EVT_SmsSrv_Ready                (CLSID_SMS << 16 | 2)
#define SMS_EVT_Message_Sending_Start               (CLSID_SMS << 16 | 3)
#define SMS_EVT_Message_Sending_Finish              (CLSID_SMS << 16 | 4)
#define SMS_EVT_SMS_SetScaCnf               (CLSID_SMS << 16 | 5)
#define SMS_EVT_SIMChange_Start             (CLSID_SMS << 16 | 6)
#define SMS_EVT_SIMChange_Ready             (CLSID_SMS << 16 | 7)
#define SMS_EVT_Handle_SIM_Operation                (CLSID_SMS << 16 | 8)
#define SMS_EVT_SIM_RetrieveMsg_OK              (CLSID_SMS << 16 | 9)
#define SMS_EVT_SIM_Deactive_OK             (CLSID_SMS << 16 | 10)
#define SMS_EVT_Message_Send_ByData_CNF             (CLSID_SMS << 16 | 11)
#define SMS_EVT_BuffMessageAddedInd             (CLSID_SMS << 16 | 12)
#define SMS_EVT_BuffMessageDeletedInd             (CLSID_SMS << 16 | 13)
#define SMS_EVT_BuffMessageMsgFlagUpdatedInd             (CLSID_SMS << 16 | 14)

/**
 * ISMS Interfaces
 */
#define INHERIT_ISMS(IName) \
    INHERIT_IHandler(IName); \
    MAE_Ret     (*Send_Message)     ( IName * , SMS_Msg_ItemData_t *pSentItem);  \
    MAE_Ret     (*service_isReady)      ( IName * , boolean *bReady, COMMON_SIM_CARD_STATUS_e *eSimCardStatus);  \
    MAE_Ret     (*Register_Notification)        ( IName * , void *instance, SMS_Notify_Mask_e mask);  \
    MAE_Ret     (*Deregister_Notification)      ( IName * , void *instance, SMS_Notify_Mask_e mask);  \
    MAE_Ret     (*Query_MessagesAtSendingQueue)     ( IName * , u32 *uUnSent, u32 *uSending);  \
    MAE_Ret     (*Query_MessageServiceCenter)       ( IName * , Msg_SMS_Service_Center_t *pSCA, u8 SimModule);  \
    MAE_Ret     (*Set_MessgageServiceCenter)        ( IName * , Msg_SMS_Service_Center_t *pSCA, u8 SimModule);  \
    MAE_Ret     (*SIMSrv_Retrieve_IND)      ( IName * , u8 u8SimCardStatus, u8 u8SimModule, boolean bSTKRefresh);  \
    MAE_Ret     (*SIMSrv_Deactive_IND)      ( IName * , u8 u8SimModule);  \
    MAE_Ret     (*SIMSrv_Retrieve_Abort)        ( IName * , u8 u8SimModule);  \
	MAE_Ret		(*Send_Message_byData)		( IName * , SMS_MSG_SentData_t *pSendData, pfn_sms_send_CB fnSendCB, IBase* pObj, u32 userData, SMI_MsgID_t *pSavedID);  \
	void		(*SMS_CancelCallBack)		( IName * , pfn_sms_send_CB fnSendCB, u32 userData);  \
    MAE_Ret     (*SMS_SendSMS_Without_Notify)       ( IName * , SMS_MSG_SentData_t*  pSendData, pfn_sms_send_CB  fnSendCB, IBase* pObj, u32 userData);  \
    MAE_Ret     (*SMS_RegisterPort)     ( IName * , u32 nPort, u8 nSIMModule, pfn_sms_receive_CB pReceiveCB, u32 userData, u32 CallerID);  \
    MAE_Ret     (*SMS_DeRegisterPort)       ( IName * , u32 nPort, u8 nSIMModule, u32 CallerID);  \
    MAE_Ret     (*SMS_DeRegisterAllPort)        ( IName * , u32 CallerID);  \
    MAE_Ret     (*SMS_SendPushMessage)      ( IName * , SMS_MSG_SentData_t * pSendData, u32 nPort, pfn_sms_send_CB fnSendCB, IBase* pObj, u32 userData);  \
    MAE_Ret     (*SMS_SendPushMessageWithSender)  ( IName * , SMS_MSG_SentData_t * pSendData, u32 nDesPort, u32 nSenderPort, pfn_sms_send_CB fnSendCB, IBase* pObj, u32 userData);  \
    MAE_Ret     (*SMS_GetData_byMsgID)      ( IName * , SMI_MsgID_t  MsgID, SMS_3rd_ReceiveData_t * pData);  \
    MAE_Ret     (*SMS_GetDataSize_ByMsgID)      ( IName * , SMI_MsgID_t  MsgID, u32 * pDataSize, u32 * pTelSize);  \
    MAE_Ret     (*SMS_RegisterTelNo)        ( IName * , u16* pTelNo, u8 nTelNoLen, u8 nSIMModule, pfn_sms_receive_CB pReceiveCB, u32 nUserData, u32 nCallerID);  \
    MAE_Ret     (*SMS_DeRegisterTelNo)      ( IName * , u16* pTelNo, u8 nTelNoLen, u8 nSIMModule, u32 nCallerID);  \
    MAE_Ret     (*SMS_DeRegisterAllTelNo)       ( IName * , u32 nCallerID);  \
    boolean     (*SMS_IsTelNoMessage)       ( IName * , u16* pTelNo, u8 nTelNoLen, u8 nSIMModule);  \
    MAE_Ret     (*SMS_KeepTelNoMsgByID)     ( IName * , u16 nMsgId, boolean bKeepMsg, u32 nCallerID); \
	MAE_Ret		(*SMS_SendSMS_AntiSteal)		( IName * , SMS_MSG_SentData_t* pSendData, pfn_sms_send_CB fnSendCB, IBase* pObj, u32 userData); \
    boolean     (*SMS_IsMTMessageAllowed)       ( IName * );  \
    void        (*SMS_SetMTMessageAllowed)      ( IName * , boolean nAllowed);  \
    MAE_Ret     (*CancelBuffMessage)            ( IName * , SMI_MsgID_t nMsgId);  \
    MAE_Ret     (*GetAllBuffMessageMsgIds)      ( IName * , SMI_MsgID_t **ppMsgIds, u8 *pMsgNum);  \
    MAE_Ret     (*GetBuffMessageBriefInfo)      ( IName * , SMI_MsgID_t nMsgId, SMS_MsgRecipAddr *pRecipAddr, boolean *pIsMultiRecip, MAE_WChar **ppMemo, boolean *pIsMoreMemo);  \
    MAE_Ret     (*GetBuffMessageHeader)         ( IName * , SMI_MsgID_t nMsgId, SMI_MsgHdr_t *pMsgHdr);  \
    u8          (*GetBuffMessageNum)            ( IName * , boolean bSIMSelect, u8 nSIMModule);  \
    MAE_Ret     (*GetBuffMessageRecipAddr)      ( IName * , SMI_MsgID_t nMsgId, SMS_MsgRecipLst *pMsgRecipLst);  \
    MAE_Ret     (*ResendBuffMessage)            ( IName * , SMI_MsgID_t nMsgId);  \
    MAE_Ret     (*SendMessageFromBuffer)        ( IName * , SMS_Msg_ItemDataEx_t *pSentItemEx)

DEFINE_INTERFACE(ISMS);


#define ISMS_QueryInterface(pICntlr, id, pp, po)            GET_FUNCTBL((pICntlr), ISMS)->QueryInterface(pICntlr, id, pp, po)
#define ISMS_HandleEvent(pICntlr, e, p1, p2)                GET_FUNCTBL((pICntlr), ISMS)->HandleEvent(pICntlr, e, p1, p2)
/**
  * sms_send_message
 *  @ brief send messaeg by msgID
 *  @ param pSentItem, pointer of msg info, MsgID/SIMModule/status


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_Send_Message(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMS)->Send_Message( pICntlr, p1)
/**
  * sms_service_isReady
 *  @ brief get the sms service status,
                 if not ready, register SMS_Notify_Mask_Ready[SMS_EVT_SmsSrv_Ready]
 *  @ param bReady, return sms service ready status, bReady =1, it means sms service ready
 *  @ param eSimCardStatus, return current SIM  status.

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_service_isReady(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMS)->service_isReady( pICntlr, p1, p2)
/**
  * sms_register_notification
 *  @ brief register notification
 *  @ param instance, register instance
 *  @ param mask notitication mask

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_Register_Notification(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMS)->Register_Notification( pICntlr, p1, p2)
/**
  * sms_deregister_notification
 *  @ brief Deregister notification
 *  @ param instance, deregister instance
 *  @ param mask, notitication mask

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_Deregister_Notification(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMS)->Deregister_Notification( pICntlr, p1, p2)
/**
  * sms_Query_MessagesAtSendingQueue
 *  @ brief check current sms sending status
 *  @ param uUnsent, return unsent message number
 *  @ param uSending, return sending message number

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_Query_MessagesAtSendingQueue(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMS)->Query_MessagesAtSendingQueue( pICntlr, p1, p2)
/**
  * sms_Query_MessageServiceCenter
 *  @ brief get service center address
 *  @ param pSCA, return service center related info
 *  @ param SimModule, query for which sim, DUAL_MASTER/DUAL_SLAVE

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 */
#define ISMS_Query_MessageServiceCenter(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), ISMS)->Query_MessageServiceCenter( pICntlr, p1, p2)
/**
  * sms_Set_MessgageServiceCenter
 *  @ brief set service center address for certain SIM
 *  @ param pSCA, pointer of service center related info
 *  @ param SimModule,set for which sim, DUAL_MASTER/DUAL_SLAVE

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, no memory to set new one
 */
#define ISMS_Set_MessgageServiceCenter(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMS)->Set_MessgageServiceCenter( pICntlr, p1, p2)
/**
  * sms_SIMSrv_Retrieve_IND
 *  @ brief Simsrv notify SMS to retrieve SIM message for sim change / power on/stkrefresh
 *  @ param u8SimCardStatus, current sim status
 *  @ param u8SimModule, retrieve which sim, DUAL_MASTER/DUAL_SLAVE
 *  @ param bSTKRefresh, bSTKRefresh = 1, it means strkrefresh.

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, no memory
 */
#define ISMS_SIMSrv_Retrieve_IND(pICntlr, p1, p2, p3)   GET_FUNCTBL((pICntlr), ISMS)->SIMSrv_Retrieve_IND( pICntlr, p1, p2, p3)
/**
  * sms_SIMSrv_Deactive_IND
 * @ brief SIM srv notify sms to deactive certain SIM
 *  @ param u8SimModule, retrieve which sim, DUAL_MASTER/DUAL_SLAVE

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, no memory
 */
#define ISMS_SIMSrv_Deactive_IND(pICntlr, p1)   GET_FUNCTBL((pICntlr), ISMS)->SIMSrv_Deactive_IND( pICntlr, p1)
/**
  * sms_SIMSrv_Retrieve_Abort
 *  @ brief Simsrv notify SMS to stop retrieving
 *  @ param u8SimModule, indicate stop which sim, DUAL_MASTER/DUAL_SLAVE

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_ILLEGAL_OPERATION Fail, SMI is busy
 */
#define ISMS_SIMSrv_Retrieve_Abort(pICntlr, p1) GET_FUNCTBL((pICntlr), ISMS)->SIMSrv_Retrieve_Abort( pICntlr, p1)
/**
  * sms_Send_Message_byData
 *  @ brief send sms by data, sms will save and send this sms and result sent by callback function.

 *  @ param pSendData, pointer of SMS data including content /recipient/simmodule
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function
                                        fnSendCB = NULL, do not pass sending result. If caller close and sms waits for sending, caller has to cancel callback
 *  @ param pObj, pointer of requester instance
 *  @ param userData, the caller data will pass by callback "fnSendCB"


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 */
#define ISMS_Send_Message_byData(pICntlr, p1, p2, p3, p4, p5)	GET_FUNCTBL((pICntlr), ISMS)->Send_Message_byData( pICntlr, p1, p2, p3, p4, p5)
/**
  * sms_SMS_CancelCallBack
 *  @ brief cancel the sending result callback if caller close or do not need to care sending result.
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function

 */
#define ISMS_SMS_CancelCallBack(pICntlr, p1, p2)	GET_FUNCTBL((pICntlr), ISMS)->SMS_CancelCallBack( pICntlr, p1, p2)
/**
  * sms_Send_Message_byData
 *  @ brief send sms by data, 1.background sending without status report
                                                2.the sending result does not display on Idle but pass by fnSendCB
                                                3.no sms stored at sentbox(draft)
 *  @ param pSendData, pointer of SMS data including content /recipient/simmodule
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function
                                        fnSendCB = NULL, do not pass sending result. If caller close and sms waits for sending, caller has to cancel callback
 *  @ param pObj, pointer of requester instance
 *  @ param userData, the caller data will pass by callback "fnSendCB"


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail

 */
#define ISMS_SMS_SendSMS_Without_Notify(pICntlr, p1, p2, p3, p4)    GET_FUNCTBL((pICntlr), ISMS)->SMS_SendSMS_Without_Notify( pICntlr, p1, p2, p3, p4)
/**
  * sms_SMS_RegisterPort
 *  @ brief register certain port to receive this port SMS by receive callback

 *  @ param nPort, port range 1 byte or 2 byte
 *  @ param nSIMModule, indicate receive which SIM port SMS
 *  @ param pReceiveCB, receive callback funtion to receive port SMS
 *  @ param userData, the caller data will pass by callback "pReceiveCB", it would be NULL.
 *  @ param CallerID, indicate whilch caler and caller will pass by callback "pReceiveCB", it would be instance address



 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 *  @retval MAE_RET_FAILED Fail

 */
#define ISMS_SMS_RegisterPort(pICntlr, p1, p2, p3, p4, p5)  GET_FUNCTBL((pICntlr), ISMS)->SMS_RegisterPort( pICntlr, p1, p2, p3, p4, p5)
/**
  * sms_SMS_DeRegisterPort
 *  @ brief deregister certain port not to receive this port SMS

 *  @ param nPort, the registered one
 *  @ param nSIMModule, indicate deregister which SIM port SMS
 *  @ param CallerID, indicate whilch caler

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_FAILED Fail, do not find the registered one
 */
#define ISMS_SMS_DeRegisterPort(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMS)->SMS_DeRegisterPort( pICntlr, p1, p2, p3)
/**
  * sms_DeRegisterAllPort
 *  @ brief deregister all port registered by certain caller
 *  @ param CallerID, indicate whilch caller

 *  @retval MAE_RET_SUCCESS Success
 */
#define ISMS_SMS_DeRegisterAllPort(pICntlr, p1) GET_FUNCTBL((pICntlr), ISMS)->SMS_DeRegisterAllPort( pICntlr, p1)
/**
  * sms_SendPushMessage
 *  @ brief send sms by data with certain port,
                1.sms send this sms and result sent by callback function.
                2. this sms donot display at message box


 *  @ param pSendData, pointer of SMS data including content /recipient/simmodule
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function
                                        fnSendCB = NULL, do not pass sending result. If caller close and sms waits for sending, caller has to cancel callback
 *  @ param pObj, pointer of requester instance
 *  @ param userData, the caller data will pass by callback "fnSendCB"


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 */
#define ISMS_SMS_SendPushMessage(pICntlr, p1, p2, p3, p4, p5)   GET_FUNCTBL((pICntlr), ISMS)->SMS_SendPushMessage( pICntlr, p1, p2, p3, p4, p5)
/**
  * sms_SendPushMessageWithSender
 *  @ brief send sms by data with certain port,
                1.sms send this sms and result sent by callback function.
                2. this sms donot display at message box


 *  @ param pSendData, pointer of SMS data including content /recipient/simmodule
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function
                                        fnSendCB = NULL, do not pass sending result. If caller close and sms waits for sending, caller has to cancel callback
 *  @ param pObj, pointer of requester instance
 *  @ param userData, the caller data will pass by callback "fnSendCB"


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 */

#define ISMS_SMS_SendPushMessageWithSender(pICntlr, p1, p2, p3, p4, p5, p6)   GET_FUNCTBL((pICntlr), ISMS)->SMS_SendPushMessageWithSender( pICntlr, p1, p2, p3, p4, p5, p6)

/**
  * sms_SendPushMessage
 *  @ brief get message content and recipients[sender] by message ID

 *  @ param  MsgID, message Id
 *  @ param pData, return SMS data [content,recipient,encoding, simModule], this pData alloc by caller

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Fail
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 */
#define ISMS_SMS_GetData_byMsgID(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMS)->SMS_GetData_byMsgID( pICntlr, p1, p2)
/**
  * sms_GetDataSize_ByMsgID
 *  @ brief get message content / recipient word count

 *  @ param  MsgID, message Id
 *  @ param pDataSize, return  word count of SMS content
 *  @ param pTelSize, return word count of SMS recipient/sender telphone number

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail, no memory
 *  @retval MAE_RET_BAD_PARAM Fail, error msgID
 *  @retval MAE_RET_FAILED Fail, over 9 page
 *  @retval MAE_RET_NOT_SUPPORTED Fail, pud len exceed limitation

 */
#define ISMS_SMS_GetDataSize_ByMsgID(pICntlr, p1, p2, p3)   GET_FUNCTBL((pICntlr), ISMS)->SMS_GetDataSize_ByMsgID( pICntlr, p1, p2, p3)
/**
  * sms_SMS_RegisterTelNo
 *  @ brief register certain telphone number  to receive specific SMS by receive callback

 *  @ param pTelNo, u16 string pointer of telphone number
 *  @ paramnTelNoLen, the word count of telphone number
 *  @ param nSIMModule, indicate receive which sim card
 *  @ param pReceiveCB, receive callback function. If there is one MT sms and from the registered tel, notify through this function
 *  @ param nUserData, It will pass by callback "pReceiveCB", apply caller to differentiate
 *  @ param CallerID, indicate whilch caller . It could be instance address and caller will pass by callback "pReceiveCB"

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail
 *  @retval MAE_RET_FAILED Fail, there is existed one.
 */
#define ISMS_SMS_RegisterTelNo(pICntlr, p1, p2, p3, p4, p5, p6) GET_FUNCTBL((pICntlr), ISMS)->SMS_RegisterTelNo( pICntlr, p1, p2, p3, p4, p5, p6)
/**
  * sms_SMS_DeRegisterTelNo
 *  @ brief deregister certain telphone number  not to receive specific SMS by receive callback

 *  @ param pTelNo, u16 string pointer of telphone number
 *  @ paramnTelNoLen, the word count of telphone number
 *  @ param nSIMModule, indicate receive which sim card
 *  @ param CallerID, indicate whilch caller.

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_FAILED Fail, there is no existed one.
 */
#define ISMS_SMS_DeRegisterTelNo(pICntlr, p1, p2, p3, p4)   GET_FUNCTBL((pICntlr), ISMS)->SMS_DeRegisterTelNo( pICntlr, p1, p2, p3, p4)
/**
 * sms_DeRegisterAllTelNo
 *  @ brief deregister all telno. certain caller do not receive any sms.
 *  @ param CallerID, indicate whilch caller

 *  @retval MAE_RET_SUCCESS Success
 */
#define ISMS_SMS_DeRegisterAllTelNo(pICntlr, p1)    GET_FUNCTBL((pICntlr), ISMS)->SMS_DeRegisterAllTelNo( pICntlr, p1)
/**
 * sms_IsTelNoMessage
 *  @ brief check if sender of the MT SMS is the registered one.
 *  @ param pTelNo,pointer of telphone number by u16 string
 *  @ param nTelNoLen,word count of telphone number
 *  @ param nSIMModule, indicate from which SIM card

 *  @retval TRUE , It is one SMS from  registed telNo
                   FALSE, not registed telNo SMS
 */
#define ISMS_SMS_IsTelNoMessage(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMS)->SMS_IsTelNoMessage( pICntlr, p1, p2, p3)
/**
 * sms_KeepTelNoMsgByID
 *  @ brief delete certain Msg or move certain msg to inbox

 *  @ param nMsgId, MsgID
 *  @ param bKeepMsg, FALSE: delete this Msg, TRUE:move this msg to Inbox
 *  @ param nCallerID, the register caller

 *  @retval MAE_RET_SUCCESS , success
                  MAE_RET_FAILED, Fail, no such Msg.
 */
#define ISMS_SMS_KeepTelNoMsgByID(pICntlr, p1, p2, p3)  GET_FUNCTBL((pICntlr), ISMS)->SMS_KeepTelNoMsgByID( pICntlr, p1, p2, p3)
/**
 * sms_SendSMS_AntiSteal
 *  @ brief send anti steal sms by data, 1.background sending without status report
                                                2.the sending result does not display on Idle but pass by fnSendCB 
                                                3.no sms stored at sentbox(draft)												
 *  @ param pSendData, pointer of SMS data including content /recipient/simmodule
 *  @ param fnSendCB, pointer of sending result callback, caller will know sending result though this callback function 
                                        fnSendCB = NULL, do not pass sending result. If caller close and sms waits for sending, caller has to cancel callback
 *  @ param pObj, pointer of requester instance
 *  @ param userData, the caller data will pass by callback "fnSendCB"


 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_OUT_OF_MEMORY Fail

 */
#define ISMS_SMS_SendSMS_AntiSteal(pICntlr, p1, p2, p3, p4)	GET_FUNCTBL((pICntlr), ISMS)->SMS_SendSMS_AntiSteal( pICntlr, p1, p2, p3, p4)

#define ISMS_SMS_IsMTMessageAllowed(pICntlr)	GET_FUNCTBL((pICntlr), ISMS)->SMS_IsMTMessageAllowed( pICntlr)

#define ISMS_SMS_SetMTMessageAllowed(pICntlr, p1)	GET_FUNCTBL((pICntlr), ISMS)->SMS_SetMTMessageAllowed( pICntlr, p1)

/**
 * sms_CancelBuffMessage
 *  @ brief cancel a waiting message
 *  @ param nMsgID, message Id

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_NOT_FOUND Failed, not found
 *  @retval MAE_RET_REJECT Failed , this message is sending now
 */
#define ISMS_CancelBuffMessage(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMS)->CancelBuffMessage( pICntlr, p1)

/**
 * sms_GetAllBuffMessageMsgIds
 *  @ brief get all the MsgIds of buff-messages
 *  @ param ppMsgIds, return a list of buff-message MsgIds
 *  @ param pMsgNum, return num of buff-messages 

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, out of memory
 */
#define ISMS_GetAllBuffMessageMsgIds(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMS)->GetAllBuffMessageMsgIds( pICntlr, p1, p2)

/**
 * sms_GetBuffMessageBriefInfo
 *  @ brief get the brief info of the buff-message
 *  @ param nMsgID, message Id
 *  @ param pRecipAddr, the address of the first recipient of the buff-message
 *  @ param pIsMultiRecip, FALSE: single recipient, TRUE: multi recipients 
 *  @ param ppMemo, the front part of the buff-message content. Text truncated to SMI_MEMO_BYTE_LEN chars
 *  @ param pIsMoreMemo, FALSE: no more than SMI_MEMO_BYTE_LEN chars, TRUE: more than SMI_MEMO_BYTE_LEN chars 

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_NOT_FOUND Failed, not found
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, out of memory
 */
#define ISMS_GetBuffMessageBriefInfo(pICntlr, p1, p2, p3, p4, p5)  GET_FUNCTBL((pICntlr), ISMS)->GetBuffMessageBriefInfo( pICntlr, p1, p2, p3, p4, p5)

/**
 * sms_GetBuffMessageHeader
 *  @ brief get the MsgHdr info of the specified buff-message by MsgId
 *  @ param nMsgID, message Id
 *  @ param pMsgHdr, pointer to a SMI_MsgHdr_t structure

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_NOT_FOUND Failed, not found
 */
#define ISMS_GetBuffMessageHeader(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMS)->GetBuffMessageHeader( pICntlr, p1, p2)

/**
 * sms_GetBuffMessageNum
 *  @ brief get number of buff-messages
 *  @ param bSIMSelect, need to select by SIM module
 *  @ param nSIMModule, SIM module Id

 *  @retval 0 ~ MAX_BUFF_MSG_NUM
 */
#define ISMS_GetBuffMessageNum(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMS)->GetBuffMessageNum( pICntlr, p1, p2)

/**
 * sms_GetBuffMessageRecipAddr
 *  @ brief get the RecipAddr info of the specified buff-message by MsgId
 *  @ param nMsgID, message Id
 *  @ param pSentItemEx, pointer to a SMS_MsgRecipLst structure

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_NOT_FOUND Failed, not found
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, out of memory 
 */
#define ISMS_GetBuffMessageRecipAddr(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMS)->GetBuffMessageRecipAddr( pICntlr, p1, p2)

/**
 * sms_ResendBuffMessage
 *  @ brief resend a sent-fail or sent-retry message
 *  @ param nMsgID, message Id

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_NOT_FOUND Failed, not found
 */
#define ISMS_ResendBuffMessage(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMS)->ResendBuffMessage( pICntlr, p1)

/**
 * sms_SendMessageFromBuffer
 *  @ brief send messaeg without saving
 *  @ param pSentItemEx, pointer of msg info

 *  @retval MAE_RET_SUCCESS Success
 *  @retval MAE_RET_BAD_PARAM Failed, bad parameter
 *  @retval MAE_RET_NOT_READY Failed, queue full
 *  @retval MAE_RET_OUT_OF_MEMORY Failed, out of memory
 */
#define ISMS_SendMessageFromBuffer(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMS)->SendMessageFromBuffer( pICntlr, p1)

/**
 * Functions
 */

void SMS_Init(void);

__SLDPM_FREE__ MAE_Ret SMS_New(MAE_ClsId id, void **ppObj);

#endif /* __MMI_SMS_H__ */
