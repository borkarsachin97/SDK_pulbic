/**
* @file mmi_vcalstoresrv.h
*
* Service without using State Machine - VCALSTORESRV
* Generated by XFSM v1.0, CodeVer=v0.24 
*
* Class Id: CLSID_VCALSTORESRV
* Interface Id: IID_VCALSTORESRV
*
* @version $Id: mmi_vcalstoresrv.h 33461 2009-06-16 08:06:40Z mark.yang $
*/
#ifndef __MMI_VCALSTORESRV_H__
#define __MMI_VCALSTORESRV_H__

/*=============================================================*/
// Include files
/*=============================================================*/

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"
#include "mmi_mae_eventdb_types.h"
#include "mmi_mae_eventdb_forward.h"
#include "mmi_vcalparsersrv_properties.h"
#include "mmi_base_util.h"
/*=============================================================*/
// Macro definition
/*=============================================================*/

/**
* Constant value definition
*/

/* Second count for upper and lower limit for normal date range. */
/* Lower limit 1970/1/1 00:00:01 */
#define CAL_DATETIME_LOWERLIMIT (1U)
/* Upper limit 2039/12/31 23:59:59 */
#define CAL_DATETIME_UPPERLIMIT (2208988799U)

#define CALENDAR_RESET_WATCH_DOG_COUNT   (3)    // reset watch dog for every CALENDAR_RESET_WATCH_DOG_COUNT.

/*=============================================================*/
// Data type definition
/*=============================================================*/

/**
 * Enum value definition
 */

typedef enum
{
    CAL_EVENT_CREATE_FAILED
   ,CAL_EVENT_CREATE_FAILED_REACH_ALARM_LIMIT
   ,CAL_EVENT_CREATE_WITH_ALARM
   ,CAL_EVENT_CREATE_WITHOUT_ALARM
   ,CAL_EVENT_UPDATE_FAILED
   ,CAL_EVENT_UPDATE_FAILED_REACH_ALARM_LIMIT
   ,CAL_EVENT_UPDATE_WITH_ALARM
   ,CAL_EVENT_UPDATE_WITHOUT_ALARM
} EventExecOutput_e;

/*
 * Object structure definition
 */

typedef struct
{
    EventExecOutput_e eAlarmInfo;
	u8 nEventNum;
	u8 nToDoNum; // __APP_MMI_TODOLIST_VTODO__
} EventExecResult_t;

/*
 * Object structure definition
 */

typedef struct
{
    MAE_DateTime_t stStartDate; /* For start date of the events. */
    MAE_DateTime_t stEndDate; /* For end date of the events. */
} DateRange_t; 

typedef struct
{
    u32 nUID;
    u32 nDTSTART;
    u32 nDTEND;
    VCALRRule_t *pRRULE;
} CalenEventInfo_t;

typedef struct
{
    CalenEventInfo_t stCalenEventInfo; /* Pointer to a CalenEventInfo_t object. */
    VCALDateRange_t stDateRange; /* Recurrence StartDateTime/EndDateTime. */
} VCALEnumEvent_t;

typedef struct
{
    boolean bForceCreateEvent;
    EventExecOutput_e eOutput;
} EventCreateParam_t;

typedef struct
{
    boolean bIsResetAlarm;
    EventExecOutput_e eOutput;
} EventUpdateParam_t;

/* User Code End */
/*-------------------------------------------------------------------------*/

/**
 * External Events
 */


/**
 * IVCALSTORESRV Interfaces
 */
#define INHERIT_IVCALSTORESRV(IName) \
    INHERIT_IHandler(IName); \
    MAE_Ret     (*CreateEvent)               (IName * , CalendarEvent_t* pCalendarEvent);  \
    MAE_Ret     (*UpdateEvent)               (IName * , CalendarEvent_t* pCalendarEvent, boolean bIsResetAlarm);  \
    MAE_Ret     (*CreateEventEx)             (IName * , CalendarEvent_t* pCalendarEvent, EventCreateParam_t *pCreateParam);  \
    MAE_Ret     (*UpdateEventEx)             (IName * , CalendarEvent_t* pCalendarEvent, EventUpdateParam_t *pUpdateParam);  \
    MAE_Ret     (*DeleteEvent)               (IName * , u32 nUID);  \
    MAE_Ret     (*DeleteAllEvent)            (IName * );  \
    MAE_Ret     (*GetEvent)                  (IName * , u32 nUID, CalendarEvent_t** ppCalendarEvent);  \
    u32         (*GetEnumEventCount)         (IName * );  \
    MAE_Ret     (*EnumInitEvent)             (IName * , DateRange_t* pDateRange, boolean bIsListAllOccurrence);  \
    MAE_Ret     (*EnumNextEvent)             (IName * , DateRange_t* pDateRange, CalenEventInfo_t** ppCalenEventInfo);  \
    MAE_Ret     (*AddRepeatException)        (IName * , CalendarEvent_t* pCalendarEvent, u32 nStartDateTime, u32 nEndDateTime);  \
    MAE_Ret     (*SetNewAlarmTime)           (IName * , CalendarEvent_t* pCalendarEvent);  \
    MAE_Ret     (*ListEvent)                 (IName * , DateRange_t* pDateRange, ArrayClass_t** ppArray, boolean bIsListAllDayEvent, IBase* pOwner);  \
    MAE_Ret     (*ListEventWithLimitNum)     (IName * , DateRange_t* pDateRange, ArrayClass_t** ppArray, boolean bIsListAllDayEvent, u8 nLimitNum, IBase* pOwner);  \
    void        (*ClearEnumEvent)            (IName * );  \
    u32         (*GetTotalEventCount)        (IName * );  \
    MAE_Ret     (*GetEventIDList)            (IName * , ArrayClass_t** ppArray, IBase* pOwner);  \
    boolean     (*IsSetNextAlarm)            (IName * , CalendarEvent_t* pCalendarEvent);  \
    MAE_Ret     (*EnumInitEventIndicator)    (IName * , DateRange_t* pDateRange, boolean bIsListAllOccurrence)

DEFINE_INTERFACE(IVCALSTORESRV);


#define IVCALSTORESRV_QueryInterface(pICntlr, id, pp, po)           GET_FUNCTBL((pICntlr), IVCALSTORESRV)->QueryInterface(pICntlr, id, pp, po)
#define IVCALSTORESRV_HandleEvent(pICntlr, e, p1, p2)               GET_FUNCTBL((pICntlr), IVCALSTORESRV)->HandleEvent(pICntlr, e, p1, p2)
/**
 Create a new event in the event database.
 */
#define IVCALSTORESRV_CreateEvent(pICntlr, p1)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->CreateEvent( pICntlr, p1)
/** IVCALSTORESRV_UpdateEventEx
@brief  Create a new event in the event database with an I/O param.

@param[in] p1      pCalendarEvent  Pointer to calendar event
@param[in] p2      eCreateMethod.bForceCreateEvent  create event even exceeds the limit of alarm at the same time.
                   eCreateMethod.eOutput  The sub-result of creating an event.
 
@retval  MAE_RET_SUCCESS        If successful.
@retval  MAE_RET_BAD_PARAM      If input parameter error. 
@retval  MAE_RET_OUT_OF_MEMORY  Memory is not enough to complete the operation.
@retval  MAE_RET_FAILED         If an error occurs.
*/
#define IVCALSTORESRV_CreateEventEx(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->CreateEventEx( pICntlr, p1, p2)
/**
 Update an existing event in the event database.
 */
#define IVCALSTORESRV_UpdateEvent(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->UpdateEvent( pICntlr, p1, p2)

/** IVCALSTORESRV_UpdateEventEx
@brief  Update an existing event in the event database with an I/O param.
 
@param[in] p1      pCalendarEvent  Pointer to calendar event
@param[in] p2      pUpdateParam.bIsResetAlarm  If reset alarm
                   eUpdateMethod.eOutput  The sub-result of updating an event.

@retval  MAE_RET_SUCCESS        If successful.
@retval  MAE_RET_BAD_PARAM      If input parameter error. 
@retval  MAE_RET_OUT_OF_MEMORY  Memory is not enough to complete the operation.
@retval  MAE_RET_FAILED         If an error occurs.
*/
#define IVCALSTORESRV_UpdateEventEx(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->UpdateEventEx( pICntlr, p1, p2)
/**
 Delete an event from the event database with the given event uid.
 */
#define IVCALSTORESRV_DeleteEvent(pICntlr, p1)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->DeleteEvent( pICntlr, p1)
/**
 Delete all events from the event database.
 */
#define IVCALSTORESRV_DeleteAllEvent(pICntlr)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->DeleteAllEvent( pICntlr)
/**
 Get an event from the event database with the given event uid.
 */
#define IVCALSTORESRV_GetEvent(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), IVCALSTORESRV)->GetEvent( pICntlr, p1, p2)
/**
 Return the number of enumerated events.
 */
#define IVCALSTORESRV_GetEnumEventCount(pICntlr)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->GetEnumEventCount( pICntlr)
/**
 Initialize the enumeration of the events within a given date range.
 */
#define IVCALSTORESRV_EnumInitEvent(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->EnumInitEvent( pICntlr, p1, p2)
/**
 Retrieve the next event in the enumeration. IVCALSTORESRV_EnumInitEvent() function must be called before this function call.
 */
#define IVCALSTORESRV_EnumNextEvent(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->EnumNextEvent( pICntlr, p1, p2)
/**
 Add an exception date range for a repeat event.
 */
#define IVCALSTORESRV_AddRepeatException(pICntlr, p1, p2, p3)   GET_FUNCTBL((pICntlr), IVCALSTORESRV)->AddRepeatException( pICntlr, p1, p2, p3)
/**
 Set the next alarm time of an event.
 */
#define IVCALSTORESRV_SetNewAlarmTime(pICntlr, p1)  GET_FUNCTBL((pICntlr), IVCALSTORESRV)->SetNewAlarmTime( pICntlr, p1)
/**
 Query events within a specified date range.
 */
#define IVCALSTORESRV_ListEvent(pICntlr, p1, p2, p3, p4)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->ListEvent( pICntlr, p1, p2, p3, p4)
/**
 Query events within a specified date range & limit size.
 */
#define IVCALSTORESRV_ListEventWithLimitNum(pICntlr, p1, p2, p3, p4, p5)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->ListEventWithLimitNum( pICntlr, p1, p2, p3, p4, p5)
/**
 Clear the enumeration of the events.
 */
#define IVCALSTORESRV_ClearEnumEvent(pICntlr)   GET_FUNCTBL((pICntlr), IVCALSTORESRV)->ClearEnumEvent( pICntlr)
/**
 Return the total event number in DB.                                   
 */
#define IVCALSTORESRV_GetTotalEventCount(pICntlr)   GET_FUNCTBL((pICntlr), IVCALSTORESRV)->GetTotalEventCount( pICntlr)
/**
 Get list of event id from DB.                          
 */
#define IVCALSTORESRV_GetEventIDList(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), IVCALSTORESRV)->GetEventIDList( pICntlr, p1, p2)
/**
 Check if need to set the next alarm time of a repeat calendar event.
 */
#define IVCALSTORESRV_IsSetNextAlarm(pICntlr, p1)   GET_FUNCTBL((pICntlr), IVCALSTORESRV)->IsSetNextAlarm( pICntlr, p1)
/**
 Initialize the enumeration of the event indicators within a given date range.
 */
#define IVCALSTORESRV_EnumInitEventIndicator(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), IVCALSTORESRV)->EnumInitEventIndicator( pICntlr, p1, p2)


/*=============================================================*/
// Local function prototype declaration and definition
/*=============================================================*/

/**
 * Functions
 */

void VCALSTORESRV_Init(void);

MAE_Ret VCALSTORESRV_New(MAE_ClsId id, void **ppObj);
/*
#ifndef FREEIF_RRULE
#define FREEIF_RRULE(pRRule) { \
    if (NULL != (pRRule)) \
{ \
    if((pRRule)->pDayInYear) FREE((pRRule)->pDayInYear); \
    FREE((pRRule)); \
    (pRRule) = NULL; \
} \
}
#endif

#ifndef FREEIF_ALARM
#define FREEIF_ALARM(pAlarm) { \
    if (NULL != (pAlarm)) \
{ \
    if((pAlarm)->pStr1) FREE((pAlarm)->pStr1); \
    if((pAlarm)->pStr2) FREE((pAlarm)->pStr2); \
    FREE((pAlarm)); \
    (pAlarm) = NULL; \
} \
}
#endif
*/
/* Free the memory occupied by the variables of CalendarEvent_t data structure.
#ifndef FREEIF_CALENDAREVENT
#define FREEIF_CALENDAREVENT(p){ \
    if (NULL != (p)){ \
    FREEIF_RRULE((p)->pRRULE); \
    FREEIF_ALARM((p)->pDALARM); \
    if((p)->pSUMMARY) FREE((p)->pSUMMARY); \
    if((p)->pDESCRIPTION) FREE((p)->pDESCRIPTION); \
    if((p)->pLOCATION) FREE((p)->pLOCATION); \
    FREE((p)); \
    (p) = NULL; \
    } \
}
#endif
*/
/*
 * Replace FREEIF_CALENDAREVENT macro by function call for reducing code size
*/
void freeif_rrule(VCALRRule_t **);
void freeif_alarm(VCALAlarm_t **);
void freeif_calendarevent(CalendarEvent_t **);

#ifndef FREEIF_RRULE
    #define FREEIF_RRULE(ptr) freeif_rrule(&(ptr))
#endif
#ifndef FREEIF_ALARM
    #define FREEIF_ALARM(ptr) freeif_alarm(&(ptr))
#endif
#ifndef FREEIF_CALENDAREVENT
    #define FREEIF_CALENDAREVENT(ptr) freeif_calendarevent(&(ptr))
#endif
/* User Code End */
/*-------------------------------------------------------------------------*/
#endif /* __MMI_VCALSTORESRV_H__ */
