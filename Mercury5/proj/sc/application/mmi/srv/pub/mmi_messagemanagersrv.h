/**
* @file mmi_smi.h
*
* Service without using State Machine - SMI
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_SMI
* Interface Id: IID_SMI
*
* @version $Id: mmi_smi.h 41408 2009-09-25 06:11:18Z joe.hsu $
*/
#ifndef __MMI_MESSAGEMANAGERSRV_H__
#define __MMI_MESSAGEMANAGERSRV_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"

//#define TEST_SIM_SENT_BOX
#define SMI_DEBUG
#include "mmi_common_sms_master.h"
#include "mmi_common_sms.h"
#include "mmi_mae_vectormodel.h"
#include "mmi_mae_arraymodel.h"
#include "mmi_mae_notifier.h"

#define SMI_TEST_FILE

typedef void (*SMI_MSGHEADER_TRANSFER_FUNC_PTR) (SMI_MsgHdr_t MsgData, void **ppOutData, void *pUserData);  //for ISMI_ListMessageByParam

enum
{
    SMI_NOTIFY_MASK_ADD = 0x00000001
   ,SMI_NOTIFY_MASK_DEL = 0x00000002
   ,SMI_NOTIFY_MASK_DEL_LOCATION = 0x00000004
   ,SMI_NOTIFY_MASK_MOVE = 0x00000008
   ,SMI_NOTIFY_COMMAND_MASK = 0x0000000F
   ,SMI_NOTIFY_MASK_READ_STATUS = 0x00000010
   ,SMI_NOTIFY_MASK_SENT_STATUS = 0x00000020
   ,SMI_NOTIFY_MASK_COMPLETE_STATUS = 0x00000040
   ,SMI_NOTIFY_MASK_UPDATE_HEADER = 0x00000080
   ,SMI_NOTIFY_STATUS_MASK = 0x000000F0
   ,SMI_NOTIFY_MASK_READY = 0x00000100
   ,SMI_NOTIFY_MASK_NOBUSY = 0x00000200
   ,SMI_NOTIFY_MASK_PHONE_FULL = 0x00000400,
};
typedef u32 SMI_Notify_Mask_e;

enum
{
    SMI_OPERATE_NONE
   ,SMI_OPERATE_SUCCESS
   ,SMI_OPERATE_NOTIFIED
   ,SMI_OPERATE_FAIL
   ,SMI_OPERATE_BAD_PARAM,
};
typedef u8 SMI_Operate_Status_e;  //for the OperateStatus in SMI_NotifyInfo_t

typedef struct SMI_NOTIFY_INFO_TAG
{
    //u16 Command;      //User should use the same command in one operation (command begin ~ command commit)
    SMI_Operate_Status_e OperateStatus;
    SMI_MsgLocation_e srcLoaction;
    SMI_MsgLocation_e desLoaction;
    u8 newStatus;
    SMI_MsgID_t MsgId;
}SMI_NotifyInfo_t;  //for the param2 (IArrayModel *) of the following notify event
//AddMsg, DelMsg, MoveMsg, SetMsgReadStatus, SetMsgSentStatus, UpdateMsgHeaderNotify

typedef struct SMI_MSGBOX_INDEXINFO_TAG
{
    boolean bPrivateMsgLocation;
    u32 BoxIndex;       //the index(timestamp ascending order) of the new msg in Private or Non-Private Box
    u32 nPreSending;    //number of previous msg (the time stamp is smaller(elder) then the new msg)) which is sending msg
    u32 nPreRead;       //number of previous msg (the time stamp is smaller(elder) then the new msg)) which is read msg
}SMI_MsgBoxIndexInfo_t;

typedef struct SMI_INSERT_MSG_NOTIFY_INFO_TAG
{
    SMI_NotifyInfo_t NotifyBase;
    SMI_MsgBoxIndexInfo_t IndexInfo;
}SMI_InsertMsgNotifyInfo_t;  //for the param2 (IVectorModel *) of the following notify event
//SMI_EVT_AddMsgSortByTimeNotify

typedef struct SMI_SIM_DATA_TAG
{
    u32 nByteLen;
    u8 *pData;
}SMI_SIMData_t; //for SMI_EVT_RetrvMsgDataFromSimCnf Param2

enum
{
    SMI_FULL_NONE = 0x00
   ,SMI_FULL_Phone = 0x01
   ,SMI_FULL_MMS = 0x02
   ,SMI_FULL_SMS_MASTER = 0x04
   ,SMI_FULL_SMS_SLAVE = 0x08
   ,SMI_FULL_ALL = 0x0F,
};

typedef u8 SMI_FULL_STATUS_e;

/**
 * External Events
 */
#define SMI_EVT_ModifyMsgParamCnf               (CLSID_SMI << 16 | 1)
#define SMI_EVT_DelMsgByIdCnf               (CLSID_SMI << 16 | 2)
#define SMI_EVT_DelMsgByLocCnf              (CLSID_SMI << 16 | 3)
#define SMI_EVT_CmtUptMsgHdrCnf             (CLSID_SMI << 16 | 4)
#define SMI_EVT_AddMsgParamCnf              (CLSID_SMI << 16 | 5)
#define SMI_EVT_AddMsgNotify                (CLSID_SMI << 16 | 6)
#define SMI_EVT_DelMsgNotify                (CLSID_SMI << 16 | 7)
#define SMI_EVT_DelLocationNotify               (CLSID_SMI << 16 | 8)
#define SMI_EVT_MoveMsgNotify               (CLSID_SMI << 16 | 9)
#define SMI_EVT_SetMsgReadStatusNotify              (CLSID_SMI << 16 | 10)
#define SMI_EVT_SetMsgSentStatusNotify              (CLSID_SMI << 16 | 11)
#define SMI_EVT_SetMsgCompleteStatusNotify              (CLSID_SMI << 16 | 12)
#define SMI_EVT_UpdateMsgHeaderNotify               (CLSID_SMI << 16 | 13)
#define SMI_EVT_AddMsgSortByTimeNotify              (CLSID_SMI << 16 | 14)
#define SMI_EVT_OperationNotBusyNotify              (CLSID_SMI << 16 | 15)
#define SMI_EVT_InitReady               (CLSID_SMI << 16 | 16)
#define SMI_EVT_PhoneFullNotify             (CLSID_SMI << 16 | 17)
#define SMI_EVT_PhoneNotFullNotify              (CLSID_SMI << 16 | 18)
#define SMI_EVT_CopySimMsgToPhoneCnf                (CLSID_SMI << 16 | 19)
#define SMI_EVT_CopyPhoneMsgToSimCnf                (CLSID_SMI << 16 | 20)
#define SMI_EVT_StoreMsgCfn             (CLSID_SMI << 16 | 21)
#define SMI_EVT_RetrvMsgDataFromSimCnf              (CLSID_SMI << 16 | 22)
#define SMI_EVT_DeleteInactiveSIMCnf                (CLSID_SMI << 16 | 23)
#define SMI_EVT_RetrieveSIMCnf              (CLSID_SMI << 16 | 24)
#define SMI_EVT_AbortRetrieveSIMCnf             (CLSID_SMI << 16 | 25)
#define SMI_EVT_SendSMSCnf				(CLSID_SMI << 16 | 26)
#define SMI_EVT_SearchRefresh			(CLSID_SMI << 16 | 27)


/**
 * ISMI Interfaces
 */
#define INHERIT_ISMI(IName) \
    INHERIT_IHandler(IName); \
    MAE_Ret     (*ModifyMessageParamsAsync)     ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MsgHdr_t *pMsgHdr, void *pinst);  \
    MAE_Ret     (*DeleteMessageByIdAsync)       ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, void *pinst);  \
    MAE_Ret     (*DeleteMessageByLocAsync)      ( IName * , SMI_MsgLocation_e msgLocation, void *pinst);  \
    MAE_Ret     (*RetrieveMessageHeader)        ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MsgHdr_t **pMsgHder);  \
    MAE_Ret     (*ListMessageByParam)       ( IName * , IModel *pMsgHdrLstModel, boolean bVectorModel, SMI_LIST_PARAM params, SMI_MSGHEADER_TRANSFER_FUNC_PTR pTransFunc, void *pUserData);  \
    MAE_Ret     (*ListMessageByParamInMCA)       ( IName * , IModel *pMsgHdrLstModel, boolean bVectorModel, SMI_LIST_PARAM params, SMI_MSGHEADER_TRANSFER_FUNC_PTR pTransFunc, void *pUserData, SMI_SmsSimMsgBox_e SmsSimMsgBox);  \
    void        (*CloseListMessage)     ( IName * , SMI_MsgHdrLst_t *pMsgHdrLst);  \
    MAE_Ret     (*UtilBeginUpdateHeader)        ( IName * , SMI_LIST_PARAM BoxParam, void *pinst);  \
    MAE_Ret     (*UtilCommitUpdateHeaderAsync)      ( IName * , void *pinst);  \
    MAE_Ret     (*UtilCancelCommitUpdateHeader)     ( IName * , void *pinst);  \
    boolean     (*IsOperationBusy)      ( IName * );  \
    MAE_Ret     (*UtilSetRead)      ( IName * , SMI_MsgID_t MsgId, boolean bRead);  \
    MAE_Ret     (*UtilSetSent)      ( IName * , SMI_MsgID_t MsgId, SMI_SentStatus_e eSent);  \
    MAE_Ret     (*UtilSetFolder)        ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLoc);  \
    MAE_Ret     (*UtilDeleteMessageById)        ( IName * , SMI_MsgID_t MsgId);  \
    MAE_Ret     (*UtilGetRead)      ( IName * , SMI_MsgID_t MsgId, boolean *bRead);  \
    MAE_Ret     (*UtilGetSent)      ( IName * , SMI_MsgID_t MsgId, SMI_SentStatus_e *eSent);  \
    MAE_Ret     (*UtilGetFolder)        ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e *msgLoc);  \
    MAE_Ret     (*CloseRetrieveMessageHeader)       ( IName * , SMI_MsgHdr_t *pMsgHdr);  \
    MAE_Ret     (*AddMessageParamsAsync)        ( IName * , SMI_MsgHdr_t *pMsgHdr, void *pinst, boolean bSortByTime);  \
    MAE_Ret     (*Register_Notification)        ( IName * , void *pinst, SMI_Notify_Mask_e mask);  \
    MAE_Ret     (*Deregister_Notification)      ( IName * , void *pinst, SMI_Notify_Mask_e mask);  \
    MAE_Ret     (*GetMsgNumByMsgBoxParam)       ( IName * , SMI_LIST_PARAM MsgBoxparam, u32 *pMsgTotalNum, u32 *pMsgReadNum, u32 *pMsgSendingNum);  \
    u32     (*CheckSeqConcateMsg)       ( IName * , SMI_MsgHdr_t *pMsgHdr, SMI_MsgLocation_e msgLocation, u8 *pRecipient, u8 maxPartNum, u8 PartNum);  \
    boolean     (*IsInitReady)      ( IName * );  \
    MAE_Ret         (*CancelCnf)        ( IName * , u32 eventID, void *pinst);  \
    boolean     (*IsPhoneFull)      ( IName * , SMI_MsgID_Type_e  MsgType);  \
    MAE_Ret     (*ResetMasterFile)      ( IName * , boolean bPowerOnReset);  \
    MAE_Ret     (*SearchInboxMsgIdByTime)       ( IName * , SMI_MsgID_t OldMsgID, SMI_TimeStamp_t Time, SMI_MsgID_t *pNewMsgID);  \
    MAE_Ret     (*UpdateMsgFlag)        ( IName * , SMI_MsgHdr_t *pMsgHdr, SMI_MsgLocation_e msgLocation);  \
    MAE_Ret     (*CopySimMsgToPhoneAsync)       ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, void *pinst);  \
    MAE_Ret     (*CopyPhoneMsgToSimAsync)       ( IName * , SMI_MsgID_t MsgID, SMI_MsgLocation_e OrgLoc, u8 SimModule, IBase *pRequester);  \
    MAE_Ret     (*AddSimMsg)        ( IName * , SMI_SimMsgHdr_t *pSimMsgInfo, SMI_MsgHdr_t *pMsgHdr, u8 SIMID, u8 nPartNum);  \
    MAE_Ret     (*UpdateSimMsgInfoInLstBuf)     ( IName * , SMI_SimMsgHdr_t *pSimMsgInfo, SMI_SimMsgHdrLst_t *pSimMsgInfoList, SMI_MsgHdr_t *pSmHdr, u8 partNum, u8 maxPartNum);  \
    MAE_Ret     (*GetSimMsgLstInfo)     ( IName * , u16 u16MsgId, u8 SIMID, SMS_MsgRecipAddr *pRecipAddr, MAE_WChar **ppMemo, boolean  *pbMoreMemo);  \
    MAE_Ret     (*RetrvSimMsgDataHdr)       ( IName * , u16 u16MsgId, u8 SIMID, SMS_MsgDataHdr *pMsgDataHdr);  \
    MAE_Ret     (*RetrvMsgDataFromSimAsync)     ( IName * , u16 u16MsgId, SMI_MsgLocation_e msgLocation, void *pinst);  \
    MAE_Ret     (*GetMmsHdrInfo)        ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MmsHdr_t** ppMMSHdr);  \
    MAE_Ret     (*UpdateMmsHdrInfo)     ( IName * , SMI_MsgID_t MsgId, SMI_MsgLocation_e msgLocation, SMI_MmsHdr_t* pMsgHdr);  \
    MAE_Ret     (*DeleteMmsHeaderInfo)      ( IName * );  \
    MAE_Ret     (*SetRetrvCdMmsFlag)        ( IName * , u8 bRetrvCdMms);  \
    MAE_Ret     (*RetrieveSIMMsg)       ( IName * , u8 SIMID, IBase * pRequester);  \
    MAE_Ret     (*AbortRetrievedSIMMsg)     ( IName * , u8 SIMID, IBase * pRequester);  \
    MAE_Ret     (*DeleteInactiveSIMMsg)     ( IName * , u8 SIMID, IBase *pRequester);  \
    MAE_Ret     (*GetSimPduCountInfo)       ( IName * , u8 SIMID, u16 *pTotal, u16 *pUsed);  \
    MAE_Ret     (*StoreMessageAsync)        ( IName * , SMS_StoreData_t *pStoredData, IBase *pRequester);  \
    MAE_Ret     (*IncSimPduUsedNumByOne)        ( IName * , u8 nSIMId);  \
    SMI_FULL_STATUS_e       (*QueryMessageFullStatus)       ( IName * );  \
    MAE_Ret     (*ResetSIMBuffer)       ( IName * , u8 SIMID, u16  nTotal, u16  nUsed);  \
    MAE_Ret     (*GetMsgNumberByType)       ( IName * , SMI_MsgID_Type_e eMsgType, u32 *pMsgNumber);  \
    MAE_Ret     (*DeletePhoneMsgInfo)       ( IName * , SMI_MsgID_t msgId, SMI_MsgLocation_e msgLocation, void* pinst);  \
    MAE_Ret	(*SendSMSAsync)		( IName * , u8 simModule, SMS_MsgRecipAddr *pRecipient, MAE_WChar *pData, u16 dataStrLen, SMI_SmEncoding_t encoding, IBase *pRequester);	\
    MAE_Ret	(*GetMsgNumBySimModule)		( IName * , u8 simModuleu, SMI_LIST_PARAM param, u32 *pMsgTotalNum, u32 *pMsgReadNum); \
    MAE_Ret     (*GetTrashMsgNumber)        ( IName * , SMI_MsgLocation_e msgLocation, u32 *pMsgNumber); \
	MAE_Ret     (*GetMsgNumberByStatus)        ( IName * , SMI_MsgLocation_e msgLocation, SMI_LIST_PARAM params, u32 *pMsgNumber)

DEFINE_INTERFACE(ISMI);


#define ISMI_QueryInterface(pICntlr, id, pp, po)            GET_FUNCTBL((pICntlr), ISMI)->QueryInterface(pICntlr, id, pp, po)
#define ISMI_HandleEvent(pICntlr, e, p1, p2)                GET_FUNCTBL((pICntlr), ISMI)->HandleEvent(pICntlr, e, p1, p2)
/**
  *modify the header information of the message header
 *post SMI_EVT_ModifyMsgParamCnf and cnf status
 */
#define ISMI_ModifyMessageParamsAsync(pICntlr, p1, p2, p3, p4)  GET_FUNCTBL((pICntlr), ISMI)->ModifyMessageParamsAsync( pICntlr, p1, p2, p3, p4)
/**
  *delete the message by message id
 *post SMI_EVT_DelMsgByIdCnf and cnf status
 */
#define ISMI_DeleteMessageByIdAsync(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->DeleteMessageByIdAsync( pICntlr, p1, p2, p3)
/**
  *delete messages by message location
 *post SMI_EVT_DelMsgByLocCnf and cnf status
 */
#define ISMI_DeleteMessageByLocAsync(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->DeleteMessageByLocAsync( pICntlr, p1, p2)
/**
  *retrieve the message's header information
 */
#define ISMI_RetrieveMessageHeader(pICntlr, p1, p2, p3) GET_FUNCTBL((pICntlr), ISMI)->RetrieveMessageHeader( pICntlr, p1, p2, p3)
/**
  * @par the implementation of ISMI_ListMessageByParam
 *
 *     (1)Get the message header according to the params filter
 *     (2)The message header will transfer to some kinds of struct pointer by the pTransFunc, and then Add into the pMsgHdrLstModel Vector/Array Model
 *     (3)Before calling the API, user should set the Vector/Array Model free function according to the pTransFunc
 *     (4)The pUserData is the pUserData param for the pTransFunc
 *
 */
#define ISMI_ListMessageByParam(pICntlr, p1, p2, p3, p4, p5)    GET_FUNCTBL((pICntlr), ISMI)->ListMessageByParam( pICntlr, p1, p2, p3, p4, p5)
/**
  * @par the implementation of ISMI_ListMessageByParamInMCA
 *
 *     (1)Get the message header according to the params filter
 *     (2)The message header will transfer to some kinds of struct pointer by the pTransFunc, and then Add into the pMsgHdrLstModel Vector/Array Model
 *     (3)Before calling the API, user should set the Vector/Array Model free function according to the pTransFunc
 *     (4)The pUserData is the pUserData param for the pTransFunc
 *
 */
#define ISMI_ListMessageByParamInMCA(pICntlr, p1, p2, p3, p4, p5, p6)    GET_FUNCTBL((pICntlr), ISMI)->ListMessageByParamInMCA( pICntlr, p1, p2, p3, p4, p5, p6)
/**
  *free the messages header list
 */
#define ISMI_CloseListMessage(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMI)->CloseListMessage( pICntlr, p1)
/**
  * begin the messages list session by box param
 * This API only accept the same kind of box param
 * Ex: (1) only inbox : SMI_LIST_INBOX
 *     (2) only private inbox : SMI_LIST_PRVINBOX
 *     (3) all the inbox type : SMI_LIST_INBOX| SMI_LIST_PRVINBOX
 * If the box param include different type of box type, this API will return MAE_RET_BAD_PARAM
 *      Ex: SMI_LIST_DRAFT| SMI_LIST_SENTBOX  =>return MAE_RET_BAD_PARAM
 */
#define ISMI_UtilBeginUpdateHeader(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->UtilBeginUpdateHeader( pICntlr, p1, p2)
/**
  *commit the session which modifies header's specific information for the message
 *post SMI_EVT_CmtUptMsgHdrCnf and cnf status
 */
#define ISMI_UtilCommitUpdateHeaderAsync(pICntlr, p1)   GET_FUNCTBL((pICntlr), ISMI)->UtilCommitUpdateHeaderAsync( pICntlr, p1)
/**
  *cancel the begin update header, or cancel the commit update header async
 */
#define ISMI_UtilCancelCommitUpdateHeader(pICntlr, p1)  GET_FUNCTBL((pICntlr), ISMI)->UtilCancelCommitUpdateHeader( pICntlr, p1)
/**
  *Check if the SMI is busy for the begin - commit operation session
 */
#define ISMI_IsOperationBusy(pICntlr)   GET_FUNCTBL((pICntlr), ISMI)->IsOperationBusy( pICntlr)
/**
  *After begin the update session, set the read information of the message
 */
#define ISMI_UtilSetRead(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->UtilSetRead( pICntlr, p1, p2)
/**
  *After begin the update session, set the sent information of the message
 */
#define ISMI_UtilSetSent(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->UtilSetSent( pICntlr, p1, p2)
/**
  *After begin the update session, set the folder information of the message
 */
#define ISMI_UtilSetFolder(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->UtilSetFolder( pICntlr, p1, p2)
/**
  *After begin the update session, delete the specific message with unique message ID
 */
#define ISMI_UtilDeleteMessageById(pICntlr, p1) GET_FUNCTBL((pICntlr), ISMI)->UtilDeleteMessageById( pICntlr, p1)
/**
  *get the read information of the message
 */
#define ISMI_UtilGetRead(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->UtilGetRead( pICntlr, p1, p2)
/**
  *get the sent information of the message
 */
#define ISMI_UtilGetSent(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->UtilGetSent( pICntlr, p1, p2)
/**
  *get the folder information of the message
 */
#define ISMI_UtilGetFolder(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->UtilGetFolder( pICntlr, p1, p2)
/**
  *close the session for retrieving the message's header information
 */
#define ISMI_CloseRetrieveMessageHeader(pICntlr, p1)    GET_FUNCTBL((pICntlr), ISMI)->CloseRetrieveMessageHeader( pICntlr, p1)
/**
  *add the header information of the message header, if successful,  post SMI_EVT_AddMsgParamCnf and cnf and msg id
 */
#define ISMI_AddMessageParamsAsync(pICntlr, p1, p2, p3) GET_FUNCTBL((pICntlr), ISMI)->AddMessageParamsAsync( pICntlr, p1, p2, p3)

/**

 */
#define ISMI_Register_Notification(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->Register_Notification( pICntlr, p1, p2)
/**

 */
#define ISMI_Deregister_Notification(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), ISMI)->Deregister_Notification( pICntlr, p1, p2)
/**
  *Get msg total, read, and sending number by valid msg box param
 */
#define ISMI_GetMsgNumByMsgBoxParam(pICntlr, p1, p2, p3, p4)    GET_FUNCTBL((pICntlr), ISMI)->GetMsgNumByMsgBoxParam( pICntlr, p1, p2, p3, p4)
/**
 param[in] pMsgHdr: The message header info
param[in] msgLocation: The phone message original location
param[in] *pRecipient: The recipient of message
param[in] maxPartNum: The total page number of whole message

if pRecipient == NULL or maxPartNum =0, do not check this field for concatnated message
 */
#define ISMI_CheckSeqConcateMsg(pICntlr, p1, p2, p3, p4, p5)    GET_FUNCTBL((pICntlr), ISMI)->CheckSeqConcateMsg( pICntlr, p1, p2, p3, p4, p5)
/**
  *Check if the SMI is busy for the begin - commit operation session
 */
#define ISMI_IsInitReady(pICntlr)   GET_FUNCTBL((pICntlr), ISMI)->IsInitReady( pICntlr)
/**

 */
#define ISMI_CancelCnf(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->CancelCnf( pICntlr, p1, p2)
/**
  *Check if the phone message number is reached the max phone message num limitation according to message type [sms/mms/sim/push msg/CB....]
 */
#define ISMI_IsPhoneFull(pICntlr, p1)   GET_FUNCTBL((pICntlr), ISMI)->IsPhoneFull( pICntlr, p1)
/**
 * Message Kernel using API (Not publich API):
* for SMS Service to Reset the master file and Available IDs
 */
#define ISMI_ResetMasterFile(pICntlr, p1)   GET_FUNCTBL((pICntlr), ISMI)->ResetMasterFile( pICntlr, p1)
/**
 * Search the inbox msgId
 */
#define ISMI_SearchInboxMsgIdByTime(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->SearchInboxMsgIdByTime( pICntlr, p1, p2, p3)
/**
 * Update the message Flag in the master file but don't update the reading status to TXI
 */
#define ISMI_UpdateMsgFlag(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->UpdateMsgFlag( pICntlr, p1, p2)
/**

 */
#define ISMI_CopySimMsgToPhoneAsync(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->CopySimMsgToPhoneAsync( pICntlr, p1, p2, p3)
/**
 param[in] MsgID: The message ID of the phone msg
param[in] OrgLoc: The phone message original location
param[in] SimModule: The Sim module ID (DUAL_MASTER/DUAL_SLAVE)
param[in] pRequester: The pointer of the request instance
This function will post the SMI_EVT_CopyPhoneMsgToSimCnf  confirm event to the pRequester with the copy result and the SIM message ID.
If request instance don't want to get the confirm event, the pRequester could be NULL, or
request instance could cancel the confirm by calling the ISMI_CancelCnf API




 */
#define ISMI_CopyPhoneMsgToSimAsync(pICntlr, p1, p2, p3, p4)    GET_FUNCTBL((pICntlr), ISMI)->CopyPhoneMsgToSimAsync( pICntlr, p1, p2, p3, p4)
/**
  * @param[in] pSimMsgInfo The pointer of SIM Message information
 * @param[in] pMsgHdr The pointer of message information
 * @param[in] SIMID for dual SIM, DUAL_MASTER or DUAL_SLAVE

 */
#define ISMI_AddSimMsg(pICntlr, p1, p2, p3, p4) GET_FUNCTBL((pICntlr), ISMI)->AddSimMsg( pICntlr, p1, p2, p3, p4)
/**

 */
#define ISMI_UpdateSimMsgInfoInLstBuf(pICntlr, p1, p2, p3, p4, p5)  GET_FUNCTBL((pICntlr), ISMI)->UpdateSimMsgInfoInLstBuf( pICntlr, p1, p2, p3, p4, p5)
/**
 * param[in] u16MsgId SIM message ID
* param[in] SIMID for dual SIM, DUAL_MASTER or DUAL_SLAVE
* param[out] pRecipAddr Sim message sender/recipient information
 */
#define ISMI_GetSimMsgLstInfo(pICntlr, p1, p2, p3, p4, p5)  GET_FUNCTBL((pICntlr), ISMI)->GetSimMsgLstInfo( pICntlr, p1, p2, p3, p4, p5)
/**
 * param[in] u16MsgId SIM message ID
* param[in] SIMID for dual SIM, DUAL_MASTER or DUAL_SLAVE
* param[out] pMsgLstInfo
 */
#define ISMI_RetrvSimMsgDataHdr(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->RetrvSimMsgDataHdr( pICntlr, p1, p2, p3)
/**

 */
#define ISMI_RetrvMsgDataFromSimAsync(pICntlr, p1, p2, p3)  GET_FUNCTBL((pICntlr), ISMI)->RetrvMsgDataFromSimAsync( pICntlr, p1, p2, p3)
/**
 SMI will allocate the MMS Hdr for user, and user have to free the MMS Hdr
 */
#define ISMI_GetMmsHdrInfo(pICntlr, p1, p2, p3) GET_FUNCTBL((pICntlr), ISMI)->GetMmsHdrInfo( pICntlr, p1, p2, p3)
/**
 Update Mms header
 */
#define ISMI_UpdateMmsHdrInfo(pICntlr, p1, p2, p3)  GET_FUNCTBL((pICntlr), ISMI)->UpdateMmsHdrInfo( pICntlr, p1, p2, p3)
/**
 delete Mms header info in message header list
 */
#define ISMI_DeleteMmsHeaderInfo(pICntlr)   GET_FUNCTBL((pICntlr), ISMI)->DeleteMmsHeaderInfo( pICntlr)
/**

 */
#define ISMI_SetRetrvCdMmsFlag(pICntlr, p1) GET_FUNCTBL((pICntlr), ISMI)->SetRetrvCdMmsFlag( pICntlr, p1)
/**
 * Message Kernel using API (Not publich API):
* for SMS Service to ask retrieved SIM message
 */
#define ISMI_RetrieveSIMMsg(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), ISMI)->RetrieveSIMMsg( pICntlr, p1, p2)
/**
 * Message Kernel using API (Not publich API):
* for SMS Service to abort retrieved SIM message
 */
#define ISMI_AbortRetrievedSIMMsg(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMI)->AbortRetrievedSIMMsg( pICntlr, p1, p2)
/**
 * Message Kernel using API (Not publich API):
* for SMS Service to Del the Msg in the inactive SIM
 */
#define ISMI_DeleteInactiveSIMMsg(pICntlr, p1, p2)  GET_FUNCTBL((pICntlr), ISMI)->DeleteInactiveSIMMsg( pICntlr, p1, p2)
/**
 * Get the SIM total and used number of PDU
 */
#define ISMI_GetSimPduCountInfo(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->GetSimPduCountInfo( pICntlr, p1, p2, p3)
/**

 */
#define ISMI_StoreMessageAsync(pICntlr, p1, p2)	GET_FUNCTBL((pICntlr), ISMI)->StoreMessageAsync( pICntlr, p1, p2)
/**

Inc the SIM used number of PDU by one

@param nSIMId
       The Sim id for this request.

@return
       Return the result of method call.

 */
#define ISMI_IncSimPduUsedNumByOne(pICntlr, p1) GET_FUNCTBL((pICntlr), ISMI)->IncSimPduUsedNumByOne( pICntlr, p1)
/**
 check sms/mms phone/sim full status
 */
#define ISMI_QueryMessageFullStatus(pICntlr)    GET_FUNCTBL((pICntlr), ISMI)->QueryMessageFullStatus( pICntlr)
/**
 realloc SIM message buffer
 */
#define ISMI_ResetSIMBuffer(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->ResetSIMBuffer( pICntlr, p1, p2, p3)
/**
 type[push message/phone SMS/CB], count by Available ID
 */
#define ISMI_GetMsgNumberByType(pICntlr, p1, p2)    GET_FUNCTBL((pICntlr), ISMI)->GetMsgNumberByType( pICntlr, p1, p2)
/**
 Delete phone messages'  info
 */
#define ISMI_DeletePhoneMsgInfo(pICntlr, p1, p2, p3)    GET_FUNCTBL((pICntlr), ISMI)->DeletePhoneMsgInfo( pICntlr, p1, p2, p3)

/**
 Sebd SMS request
param[in] simModule: send via Master or Slave SIM. DUAL_MASTER or DUAL_SLAVE
param[in] recipient: The recipient number address in ASCII
param[in] pData: The message content data in UCS2
param[in] dataStrLen:  string length of the pData
param[in] encoding: the SMS preferred encoding
param[in] pRequester: the send SMS request instance.

if the retval is MAE_RET_SUCCESS, 
SMI will post the SMI_EVT_SendSMSCnf confirm event to the pRequester for the send result if the pRequest isn't NULL.
 */
#define ISMI_SendSMSAsync(pICntlr, p1, p2, p3, p4, p5, p6)	GET_FUNCTBL((pICntlr), ISMI)->SendSMSAsync( pICntlr, p1, p2, p3, p4, p5, p6)

/**
 *Get msg total, read, and sending number by sim module
*/
#define ISMI_GetMsgNumBySimModule(pICntlr, p1, p2, p3, p4)	GET_FUNCTBL((pICntlr), ISMI)->GetMsgNumBySimModule( pICntlr, p1, p2, p3, p4)

/**
 * Get the Trash Message Number
 */
#define ISMI_GetTrashMsgNumber(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), ISMI)->GetTrashMsgNumber( pICntlr, p1, p2)

/**
 * Get the Message Number By Status
 * @brief  Get the message number for the specific message status.

 * @param[in]      msgLocation			The message location for the request.
										Only support : MlInbox, MlDraft, MlOutbox, MlSent, MlSim1InBox, MlSim2InBox, MlSim1Sent, MlSim2Sent now.
 * @param[in]      params				The message status for the request.
										Only support :  SMI_LIST_SENT, SMI_LIST_NOT_SENT, SMI_LIST_RESENT, SMI_LIST_SENT_FAIL, SMI_LIST_READ, SMI_LIST_UNREAD, 
														SMI_LIST_COMPLETE, SMI_LIST_INCOMPLETE, SMI_LIST_REMOTE_DELIVERED, SMI_LIST_REMOTE_NOT_DELIVERED,
														SMI_LIST_DELIVERED_READ, SMI_LIST_DELIVERED_NOT_READ, SMI_LIST_DELETING, SMI_LIST_NON_DELETING now.
 * @param[in]      pMsgNumber           Pointer to return the number of the message.
 */
#define ISMI_GetMsgNumberByStatus(pICntlr, p1, p2, p3) GET_FUNCTBL((pICntlr), ISMI)->GetMsgNumberByStatus( pICntlr, p1, p2, p3)

/**
 * Functions
 */

void SMI_Init(void);

__SLDPM_FREE__ MAE_Ret SMI_New(MAE_ClsId id, void **ppObj);

#endif /* __MMI_MESSAGEMANAGERSRV_H__ */
