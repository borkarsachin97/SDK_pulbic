/**
* @file mmi_usbsrv.h
*
* State Machine Service - USBSRV
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_USBSRV
*
*
* @version $Id: mmi_usbsrv.h 33461 2009-06-16 08:06:40Z mark.yang $
*/
#ifndef __MMI_USBSRV_H__
#define __MMI_USBSRV_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"
#include "mmi_mae_model.h"
#include "mmi_camerasrv_def.h"
#include "mmi_mediasrv_common.h"

/**
 *  @brief The enumeration defines the return code of the USB interface
 */
typedef enum MMI_USB_RESULT_E_
{
    MMI_USB_OK
   ,/**< Function complete successfully */
    MMI_USB_FAIL
   ,/**< Function common fail */
    MMI_USB_PARAM_ERROR
   ,/**< The input parameter is wrong */
    MMI_USB_MEM_ALLOC_ERROR
   ,/**< Can not allocate memory from OS */
    MMI_USB_REJECT
   ,/**< Request rejected because of other function's confliction */
    MMI_USB_ABORT
   ,/**< Request aborted because of incorrect sequence */
    MMI_USB_TIMEOUT             /**< Request no response timeout, this error is returned by call back function */
} MMI_USB_RESULT_E;
/**
 * @brief The enumeration defines the USB device type of the USB interface function.
 */
typedef enum MMI_USB_DEVICE_E_
{
    MMI_USB_NONE
   ,/**< No USB function */
    MMI_USB_CDC
   ,/**< Communication Device Class (Modem virtual COM port) */
    MMI_USB_MSC
   ,/**< Mass Storage Device Class */
    MMI_USB_MTP
   ,/**< Media Transfer Protocol */
    MMI_USB_PBD
   ,/**< Picture Bridge Device */
#ifndef __DUAL_CAMERA_MMI__
    MMI_USB_VDC
    ,/**< Video Class used for PC camera service */
#else
    MMI_USB_VDC_MAIN
    ,/**< Video Class used for PC camera service */
    MMI_USB_VDC_SUB
    ,/**< Video Class used for PC camera service */
#endif
    MMI_USB_OTG             /**< OTG Host */
#ifdef __3G_RIL_MMI__
   ,/**< For PC sync tool */
    MMI_USB_ATSYNC             
#endif //__3G_RIL_MMI__
#ifdef __V24_COMPOSITE_USB___
   ,/**< For composite trc&at tool */
    MMI_USB_COMPOSITE            
#endif //#ifdef __V24_COMPOSITE_USB___
} MMI_USB_DEVICE_E;

/* For USB cam device config value */
typedef struct UsbSrvWebCamFlickerConfig_t_
{
    CameraSrvAntiFlicker_e eCamAntiFlicker;
} UsbSrvWebCamFlickerConfig_t;

typedef enum MMI_USB_STATE_E_
{
    MMI_USB_STATE_UNSPECIFIED
   ,MMI_USB_STATE_OPEN_REQUEST
   ,MMI_USB_STATE_RESUME_FILEMGR
} MMI_USB_STATE_E;

typedef struct UsbSrvStartup_t_
{
    MMI_USB_STATE_E eUSBAPState;
    u32 nUSBFuncID;
} MMI_USB_STARTUP_T;

/* For Usb Listener, event code is USBSRV_EVT_USB_STATUS. */
typedef enum MMI_USB_STATUS_E_
{
    MMI_USB_STATUS_NONE
   ,/**< USB cable not connect. */
    MMI_USB_STATUS_UNKNOWN
   ,/**< USB cable not check yet (but connect). */
    MMI_USB_STATUS_PCHOST
   ,/**< USB cable attached for PC host */
    MMI_USB_STATUS_CHARGING
   ,/**< USB cable is for charging only */
    MMI_USB_STATUS_PCHOST_CDC_MODEM
   ,/**< USB cable is for Communication Modem Device */
    MMI_USB_STATUS_PCHOST_CDC_SYNCTOOL
   ,/**< USB cable is for Communication Sync tool Device */
    MMI_USB_STATUS_PCHOST_CDC_TRACE
   ,/**< USB cable is for Communication Trace Device */
    MMI_USB_STATUS_PCHOST_MSC
   ,/**< USB cable is for Mass Storage */
    MMI_USB_STATUS_PCHOST_VDC
   ,/**< USB cable is for Webcam */
    MMI_USB_STATUS_VBUS_USB_IN
   ,/* For dual charger, to notify USB IN */
    MMI_USB_STATUS_VBUS_USB_OUT
   ,/* For dual charger, to notify USB IN */
    MMI_USB_STATUS_RESUME_FILEMGR_DONE
    /* For file manager has been resumed, to notify USB app to close */
} MMI_USB_STATUS_E;

typedef enum MMI_USB_RSP_TYPE_E_
{
    MMI_USB_RSP_ATTACH
   ,MMI_USB_RSP_OPEN
   ,MMI_USB_RSP_CLOSE
   ,MMI_USB_RSP_REG_NOTIFICATION
   ,MMI_USB_RSP_MSC_STOP_IND
#ifdef __DUAL_CHARGER_MMI__

   ,MMI_USB_RSP_VBUS_CONNECT_IND
   ,MMI_USB_RSP_VBUS_REMOVE_IND
   ,MMI_USB_RSP_STOP_POLLING
#endif
} MMI_USB_RSP_TYPE_E;

typedef enum UsbSrvMode_e_
{
    USBSRV_MODE_IDLE = 0
   ,USBSRV_MODE_CHECKATTACH
   ,USBSRV_MODE_CONNECTDEV
} UsbSrvMode_e;

typedef enum UsbSrvSimPath_e_
{
    USBSRV_SIM_PATH_SIM1 = 0
   ,USBSRV_SIM_PATH_SIM2
} UsbSrvSimPath_e;

/**
 * External Events
 */
#define USBSRV_EVT_USB_IN               (CLSID_USBSRV << 16 | 1)
#define USBSRV_EVT_USB_OUT              (CLSID_USBSRV << 16 | 2)
#define USBSRV_EVT_RESULT_OK            (CLSID_USBSRV << 16 | 3)
#define USBSRV_EVT_RESULT_FAIL          (CLSID_USBSRV << 16 | 4)
#define USBSRV_EVT_USB_STATUS           (CLSID_USBSRV << 16 | 5)
#define USBSRV_EVT_SRV_BACK_TO_IDLE     (CLSID_USBSRV << 16 | 6)
#define USBSRV_EVT_SRV_STOP_IND         (CLSID_USBSRV << 16 | 7)

typedef void (*SrvUsbResultCB)(void *pThis, boolean bResult);  // True:ok, False:fail ,USBSRV_EVT_RESULT_OK,USBSRV_EVT_RESULT_FAIL
/**
 * IUSBSRV Interfaces
 */
#define INHERIT_IUSBSRV(IName) \
    INHERIT_IHandler(IName) \

DEFINE_INTERFACE(IUSBSRV);

#define IUSBSRV_QueryInterface(pICntlr, id, pp, po)         GET_FUNCTBL((pICntlr), IUSBSRV)->QueryInterface(pICntlr, id, pp, po)
#define IUSBSRV_HandleEvent(pICntlr, e, p1, p2)             GET_FUNCTBL((pICntlr), IUSBSRV)->HandleEvent(pICntlr, e, p1, p2)

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  USB Service interface
/////////////////////////////////////////////////////////////////////////////////////////////////////////
MAE_Ret UsbSrvOpenSession(IUSBSRV *pIUSBSRV, MMI_USB_DEVICE_E eUsbDev, SrvUsbResultCB pfnUsbSrvCb);
MAE_Ret UsbSrvCloseSession(IUSBSRV *pIUSBSRV, SrvUsbResultCB pfnUsbSrvCb);
void UsbSrvSetSimPathReq(IUSBSRV *pIUSBSRV, UsbSrvSimPath_e eSimPath, SrvUsbResultCB pfnUsbSrvCb);
MMI_USB_RESULT_E UsbSrvUsbOpenReq(IUSBSRV *pIUSBSRV, MMI_USB_DEVICE_E eUsbDev, SrvUsbResultCB pfnUsbSrvCb);
MMI_USB_RESULT_E UsbSrvUsbCloseReq(IUSBSRV *pIUSBSRV, SrvUsbResultCB pfnUsbSrvCb);
__SLDPM_FREE__ MMI_USB_STATUS_E UsbSrvUsbGetUsbStatus(IUSBSRV *pIUSBSRV);
__SLDPM_FREE__ MAE_Ret UsbSrvUsbAddUsbListener(IUSBSRV *pIUSBSRV, ModelListener_t *pModelListener);
MAE_Ret UsbSrvUsbCancelUsbListener(IUSBSRV *pIUSBSRV, ModelListener_t *pModelListener);
MAE_Ret UsbSrvUsbEnableReq(IUSBSRV *pIUSBSRV, boolean bIsEnabled);
MAE_Ret UsbSrvUsbEnableReqInCharging(IUSBSRV *pIUSBSRV, boolean bIsEnabledInCharging);
MMI_USB_RESULT_E UsbSrvUsbFlushAppletStack(IUSBSRV *pIUSBSRV, u32 nUSBFuncID);
/**
 * Functions
 */
void UsbSrvInit(void);
__SLDPM_FREE__ MAE_Ret UsbSrvNew(MAE_ClsId nId, void **ppObj);

#endif /* __MMI_USBSRV_H__ */
