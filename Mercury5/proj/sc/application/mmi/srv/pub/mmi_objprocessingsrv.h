/**
* @file mmi_objprocessingsrv.h
*
* State Machine Service - OBJPROCESSINGSRV
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_OBJPROCESSINGSRV
*
*
* @version $Id$
*/
#ifndef __MMI_OBJPROCESSINGSRV_H__
#define __MMI_OBJPROCESSINGSRV_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"
#include "mmi_mae_listmodel.h"
#include "mmi_common_content.h"
#include "mmi_mae_image.h"

// define the operation type that the OPSRV is launched for
enum _OPSrv_LaunchType
{
    OPSRV_OPERATION_NONE
   ,OPSRV_OPERATION_GETTHUMBNAIL
   ,OPSRV_OPERATION_DEL
   ,OPSRV_OPERATION_COPY
   ,OPSRV_OPERATION_MOVE
   ,OPSRV_OPERATION_SAVE
   ,OPSRV_OPERATION_MAX
};
typedef u8 OPSrv_LaunchFor_e;

enum _OPSrv_RetCode
{
    OPSRV_RET_SUCCESS
   ,OPSRV_RET_FAILED
   ,OPSRV_RET_CACHEFILE_FAILED
   ,OPSRV_RET_CACHEDB_FAILED
   ,OPSRV_RET_PARTIALFAILED
   ,OPSRV_RET_ITEMNOTEXIST
   ,OPSRV_RET_ITEMDUPLICATED
  , // for move, copy.
    OPSRV_RET_RESCONFLICT
,   // resource conflict
    OPSRV_RET_OPDENIED
,     // operation denied.
    OPSRV_RET_DBFULL
   ,OPSRV_RET_DBFAILED
   ,OPSRV_RET_FSFULL
   ,OPSRV_RET_FSFAILED
   ,OPSRV_RET_SRVBUSY
   ,OPSRV_RET_FILENAME_TOOLONG
   ,OPSRV_RET_FILENAME_COLLISION
  , // cannot find a suitable file name for moving/copying files
    OPSRV_RET_MAX
};
typedef u8 OPSrv_RetCode_e;

enum _OPSrv_StatusCode
{
    OPSRV_STATUS_NONE
   ,OPSRV_STATUS_BUSY
   ,OPSRV_STATUS_CANCELING
   ,OPSRV_STATUS_STOPPED
   ,OPSRV_STATUS_MAX
};
typedef u8 OPSrv_StatusCode_e;

enum _OPSrv_ThumbCacheType
{
    OPSRV_THUMBCACHE_NONE
   ,OPSRV_THUMBCACHE_FILE
   ,OPSRV_THUMBCACHE_DB     // including its file
};
typedef u8 OPSrv_ThumbCacheType_e;

enum _OPSrv_CacheNamingType
{
    //OPSRV_CACHENAMING_CNTID,    // url(fs:/card/thumb/) + cnt_id(7243) + ext_name(.thmb) ( --> fs:/card/thumb/7243.thmb)
    OPSRV_CACHENAMING_SUFFIX
,   // url(fs:/card/playlist/a.m3u) + ext_name(.thmb) ( --> fs:/card/playlist/a.m3u.thmb)
    OPSRV_CACHENAMING_APDEFINED   // it means AP defined, we don't need to change it
};
typedef u8 OPSrv_CacheNamingType_e;


enum _OPSrv_CacheDirCheckingType
{
    OPSRV_CACHEDIRCHECK_LIMIT
,    // cached file count is limited
    OPSRV_CACHEDIRCHECK_UNLIMIT   // unlimited cache (must cache the file!)
};
typedef u8 OPSrv_CacheDirCheckingType_e;

/*-------------- structure of the request data *--------------- */
typedef struct _OPSrvRectangle
{
    u32 width;
    u32 height;
}OPSrvRect_t;

typedef struct _OPSrvThumbCache
{
    MAE_WChar *pCacheURL;
    u16 nCacheLimit;    // if 0, set OPSRV_THUMB_CACHE_FILE_COUNT
    OPSrv_CacheDirCheckingType_e nCacheDirType;  // if limited, the nCacheLimit is referenced; otherwise, nCacheLimit is useless
    OPSrv_ThumbCacheType_e nCacheType;
    OPSrv_CacheNamingType_e nNaming;
    RGBColor_t nBGColor; // For image maker to convert transparent color to a specified color.
}OPSrvThumbCache_t;

typedef struct _OPSrvThumbReq
{
    OPSrvRect_t tRect;
    OPSrvThumbCache_t tCache;
    MAE_WChar pFileURL[FILEMGR_MAX_FILEPATH_SIZE];
    u32 nIdx;
}OPSrvThumbReq_t;

typedef struct _OPSrvDelReq
{
    MAE_WChar pszCurrentFolder[FILEMGR_MAX_FILEPATH_SIZE];
    IListModel *pSelList;  // the data type in every element is MMI_Common_FMList_ItemElement_t
}OPSrvDelReq_t;

typedef struct _OPSrvCpMvReq
{
    MAE_WChar pszCurrentFolder[FILEMGR_MAX_FILEPATH_SIZE];
    MAE_WChar pszDestFolder[FILEMGR_MAX_FILEPATH_SIZE];
    IListModel *pSelList;  // the data type in every element is MMI_Common_FMList_ItemElement_t
}OPSrvCpMvReq_t;

typedef struct _OPSrvSaveReq /* Seems not be used. TBD */
{
    MAE_WChar *pFilepath;
    MAE_WChar *pCntName;
    char *pCntMIMEType;
}OPSrvSaveReq_t;

typedef union _OPSrvReqInfo
{
    OPSrvThumbReq_t tThumb;
    OPSrvDelReq_t tDel;     //To be removed
    OPSrvCpMvReq_t tCpMv;   //To be removed
    OPSrvSaveReq_t tSave;   //To be removed
}OPSrvReqInfo_u;

/*-------------- structure of the return result *--------------- */
typedef struct _OPSrvThumbRslt
{
    IImage *pThumbImg;
    MAE_WChar *pFilename;
    u32 nIdx;
    OPSrv_RetCode_e nRet;
}OPSrvThumbRslt_t;

typedef struct _OPSrvOPRslt // for object processing: deletion, copying and moving.
{
    OPSrv_RetCode_e nRet;
    u32 nItemCount;
    u32 nSuccessCount;    // counting begins from zero.
    u32 nMPlayerSrvUsedCount;  // // Which deleting file is in music player service background play.
}OPSrvOPRslt_t;

typedef struct _OPSrvRsltInfo
{
    OPSrvThumbRslt_t tThumb;
    OPSrvOPRslt_t tOP;
}OPSrvRsltInfo_t;

/*-------------- structure of the OPSrvStatus *--------------- */
typedef struct _OPSrvStatus
{
    OPSrv_LaunchFor_e nOPType;
    OPSrv_StatusCode_e nStatus;
}OPSrvStatus_t;

/**
 * External Events
 */
#define OBJPROCESSINGSRV_EVT_GETPREVIEWDATADONE             (CLSID_OBJPROCESSINGSRV << 16 | 1)
#define OBJPROCESSINGSRV_EVT_STARTGETTHUMBNAIL              (CLSID_OBJPROCESSINGSRV << 16 | 2)
#define OBJPROCESSINGSRV_EVT_FS_FAILED              (CLSID_OBJPROCESSINGSRV << 16 | 14)
#define OBJPROCESSINGSRV_EVT_DB_FAILED              (CLSID_OBJPROCESSINGSRV << 16 | 17)
#define OBJPROCESSINGSRV_EVT_STOPPROCESSING             (CLSID_OBJPROCESSINGSRV << 16 | 21)
#define OBJPROCESSINGSRV_EVT_GETOBJ_FAILED              (CLSID_OBJPROCESSINGSRV << 16 | 25)
#define OBJPROCESSINGSRV_EVT_GETOBJ_SUCCESS             (CLSID_OBJPROCESSINGSRV << 16 | 26)
#define OBJPROCESSINGSRV_EVT_OPDONE             (CLSID_OBJPROCESSINGSRV << 16 | 27)
#define OBJPROCESSINGSRV_EVT_SRVSTOPPED             (CLSID_OBJPROCESSINGSRV << 16 | 28)

/**
 * IOBJPROCESSINGSRV Interfaces
 */
#define INHERIT_IOBJPROCESSINGSRV(IName) \
    INHERIT_IHandler(IName); \
    MAE_Ret     (*StartProcessing)      ( IName * , OPSrv_LaunchFor_e nLaunchFor, IHandler *pClient, OPSrvReqInfo_u *pReqInfo);  \
    MAE_Ret     (*StopProcessing)       ( IName * , IHandler *pClient);  \
    MAE_Ret     (*GetStatus)        ( IName * , OPSrvStatus_t *pStatus)

DEFINE_INTERFACE(IOBJPROCESSINGSRV);


#define IOBJPROCESSINGSRV_QueryInterface(pICntlr, id, pp, po)           GET_FUNCTBL((pICntlr), IOBJPROCESSINGSRV)->QueryInterface(pICntlr, id, pp, po)
#define IOBJPROCESSINGSRV_HandleEvent(pICntlr, e, p1, p2)               GET_FUNCTBL((pICntlr), IOBJPROCESSINGSRV)->HandleEvent(pICntlr, e, p1, p2)
/**
 it is used for AP to start the obj processing. (MMI_OPSRV_RET_BUSY if the service is serving for other request, every item is defined as MMI_Common_FMList_ItemElement_t)
 */
#define IOBJPROCESSINGSRV_StartProcessing(pICntlr, p1, p2, p3)  GET_FUNCTBL((pICntlr), IOBJPROCESSINGSRV)->StartProcessing( pICntlr, p1, p2, p3)
/**

 */
#define IOBJPROCESSINGSRV_StopProcessing(pICntlr, p1)   GET_FUNCTBL((pICntlr), IOBJPROCESSINGSRV)->StopProcessing( pICntlr, p1)
/**

 */
#define IOBJPROCESSINGSRV_GetStatus(pICntlr, p1)    GET_FUNCTBL((pICntlr), IOBJPROCESSINGSRV)->GetStatus( pICntlr, p1)



/**
 * Functions
 */

void OBJPROCESSINGSRV_Init(void);

MAE_Ret OBJPROCESSINGSRV_New(MAE_ClsId id, void **ppObj);

#endif /* __MMI_OBJPROCESSINGSRV_H__ */
