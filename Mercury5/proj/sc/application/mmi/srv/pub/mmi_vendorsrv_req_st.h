/**
 * @file mmi_vendorsrv_req_st.h
 *
 * Service without using State Machine  - VENDORSRV
 * Generated by AP Designer v0.23, 2008-03-10 18:42
 *
 * @version $Id: mmi_vendorsrv_req_st.h 41649 2009-09-29 02:45:43Z christoph.kuo $
 */
#ifndef __MMI_VENDORSRV_REQ_ST_H__
#define __MMI_VENDORSRV_REQ_ST_H__

#include "mmi_audiosrv.h"
#include "mmi_videoplayersrv.h"
#include "mmi_smssrv.h"
#include "mmi_mae_softkey.h"
#include "Mmi_mae_softkeymodel.h"
#include "mmi_phbsrv_def.h"
#include "mmi_messagemanagersrv.h"
#include "mmi_download_def.h"
#include "mmi_ccsrv_def.h"

typedef struct
{
    void *pCBFunc;
    u32 UserData;
}mmi_ven_Callback_Info_t;

typedef struct
{
    u32 AP_ID;
    u8 bSync;
    union
    {
        mmi_ven_Callback_Info_t CbInfo;
        u32 SemID;
    }Resp;
}mmi_ven_req_base_t;

//file
enum
{
    FILE_BROWSER_TYPE_IMAGE = 0,
    FILE_BROWSER_TYPE_AUDIO = 1,
    FILE_BROWSER_TYPE_VIDEO = 2,
    FILE_BROWSER_TYPE_ALL,
};

typedef u8 file_browser_type_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTitle;
    u8 titleLen;
    file_browser_type_t type;
    u8 maxMarkSize;
    u16 **pptOutData;
    u16 *ptOutDataLen;
    u8 *ptOutMarkedSize;
}mmi_file_browse_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTitle;
    u8 titleLen;
    file_browser_type_t type;
    u8 maxMarkSize;
    u16 **pptOutData;
    u16 *ptOutDataLen;
    u8 *ptOutMarkedSize;
    VFS_ExtensionFilter_t tExtList;
    u16 *pwszBrowsingFolder;
    u16 nFolderStrLen;
}mmi_file_browse_ex_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTitle;
    u8 titleLen;
    u16 **pptOutData;
    u16 *ptOutDataLen;
}mmi_file_select_folder_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    boolean            bIsEnterPlaybackMode;
    boolean            bIsReturnFilePath;
    boolean            bIsMultiShotSupport;
}mmi_cam_launch_app_req_t;

//editor
enum
{
    EDITOR_TYPE_FORMAT = 0
  , ///< according to the format string
    EDITOR_TYPE_DIALING = 1
  , ///< for dialing number
    EDITOR_TYPE_RATE = 2
  , ///< for decimal input
    EDITOR_TYPE_DIGITAL = 3
  , ///< digital is allowed only
    EDITOR_TYPE_ALPHA = 4
  , ///< alpha is allowed only
    EDITOR_TYPE_NUMERIC = 5
  , ///< for negative sign and digits.
    EDITOR_TYPE_ALL = 6
  , ///< digital, alpha, Chinese are allowed
};
typedef u32 editor_type_t;
enum
{
    EDITOR_STYLE_TEXT = 0
   ,EDITOR_STYLE_PASSWORD
};
typedef u8 editor_style_t;

enum
{
    EDITOR_ENCODING_UCS2 = 0,
    EDITOR_ENCODING_UTF8,
    EDITOR_ENCODING_ASC_UCS2
};
typedef u8 editor_encoding_t;

enum
{

    EDITOR_RESULT_OK = 0,
    EDITOR_RESULT_CANCEL,
    EDITOR_RESULT_ERROR
};
typedef u8 editor_reult_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTitle;
    u8 titleLen;
    editor_type_t type;
    editor_style_t style;
    editor_encoding_t encoding;
    u16 maxContentLen;
    u16 *ptInitContent;
	u16 initContentLen;
    u16 *pFormatStr;
    u8 formatStrLen;
    editor_reult_t *ptOutResult;
    u16 **pptOutContent;
    u16 *ptOutContentLen;
}mmi_editor_edit_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u32 *pRetCode; //for sync
}mmi_editor_close_req_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
	editor_reult_t *ptOutResult;
	bool bDate;
	u16 nInitYear;
	u8 nInitMonth;
	u8 nInitDay;
	u8 nInitHour;
	u8 nInitMinute;
	u8 nInitSecond;
}mmi_editor_datetime_req_t;

//phonebook
enum
{
    PHB_BROWSER_TYPE_PHONENO                = 0,
    PHB_BROWSER_TYPE_EMAIL                  = 1,
};
typedef u8 phb_browser_type_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTitle;
    u8 titleLen;
    phb_browser_type_t type;
    u8 maxMarkSize;
    u16 **pptOutData;
    u16 *ptOutDataLen;
    u8 *ptOutMarkedSize;
}mmi_phb_browse_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u8 *pName;
    u8 *pNumber;
    u8 nNameLen;
    u8 nNumberLen;
    MmiPhbBookType_e ePhbBookType;
    void *pRet; //for sync
}mmi_phb_save_contact_req_t;


typedef struct
{
    mmi_ven_req_base_t venderData;
    MmiPhbContactContent_t pContent;
    MmiPhbBookType_e ePhbBookType;
    u16 *pu16PhbPhysicalIdx;
    bool bNeedReturnIndex;
    void *pRet; //for sync
}mmi_phb_write_contact_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 u16PhbPhysicalIdx;
    MmiPhbBookType_e ePhbBookType;
    void *pRet; //for sync
}mmi_phb_delete_contact_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    MmiPhbBookType_e s32PhbBookType;
    MmiPhbContactContent_t tPhbContactContent;
    u16 u16PhbPhysicalIdx;
    u16 *pu16PhbNewPhysicalIdx;
    bool bNeedReturnIndex;
    void *pRet; //for sync
}mmi_phb_save_contact_by_handle_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	void* pReadyIndFunc;
	u32 usrData;
    u32 *pRetCode; //for sync
} mmi_phb_register_ready_req_t;

//cc

enum
{
    DUAL_MASTER_SIM = 0
   ,DUAL_SLAVE_SIM,
};
typedef u8 common_sim_id_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTelNo;
    u8 telNoLen;
    common_sim_id_t simId;
}mmi_cc_make_call_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	s32 callID;
	u32 *pResult;
}mmi_cc_release_call_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    void *pCallFilter;
	void *pCallHandler;
	u32 usrData;
	u32 *pRetCode; //for sync
}mmi_cc_register_incoming_call_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	void *pCallLogListener;
	u32 usrData;
	u32 *pRetCode; //for sync
}mmi_cc_register_add_call_log_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u8 u8KeyCode;
    u8 u8Duration;
    MMI_CCSRV_DTMF_OP_e OperationMode;
}mmi_cc_send_DTMF_req_t;

//sms
enum
{
    MSG_SMS_TYPE_7BIT = 0,
    MSG_SMS_TYPE_8BIT = 1,
    MSG_SMS_TYPE_UCS2 = 2,
	MSG_SMS_TYPE_7BitASCII,		/*!< Comment */
	MSG_SMS_TYPE_GSM8Bit,		/*!< Comment */
	MSG_SMS_TYPE_IS91,			/*!< Comment */
	MSG_SMS_TYPE_UNICODE,		/*!< Comment */
	MSG_SMS_TYPE_IA5,			/* ITU-T T.50 */
	MSG_SMS_TYPE_Hebrew,		/* ISO 8859-8 */
	MSG_SMS_TYPE_Latin,			/* ISO 8859-1 */    
};
typedef u8 msg_sms_type_t;

enum
{
    MSG_SMS = 0,
    MSG_CBS = 1,
    MSG_MMS = 2,
};
typedef u8 msg_type_t;

enum
{
    MSG_DATA_BYTEDATA = 0
   ,MSG_DATA_TEXTDATA = 1,
};
typedef u8 msg_data_t;

enum
{
    MSG_ENCODING_GSM7BIT = 0,
    MSG_ENCODING_8BITASCII,
    MSG_ENCODING_UCS2,
    MSG_ENCODING_7BITASCII,
    MSG_ENCODING_GSM8BIT,
    MSG_ENCODING_IS91,
    MSG_ENCODING_UNICODE,
    MSG_ENCODING_A5,
    MSG_ENCODING_HEBREW,
    MSG_ENCODING_LATIN
};
typedef u8 msg_encoding_t;

enum
{
    MSG_MMS_OBJECT_NONE = 0,
    MSG_MMS_OBJECT_IMAGE,
    MSG_MMS_OBJECT_AUDIO,
    MSG_MMS_OBJECT_VIDEO,
    MSG_MMS_OBJECT_VCS,
    MSG_MMS_OBJECT_TEXT,
    MSG_MMS_OBJECT_ATTACHMENT,
    MSG_MMS_OBJECT_NUM,
};
typedef u8 msg_mms_object_t;

enum {
	//--- single box ---
	MSG_PH_Inbox = 0,		//phone public
	MSG_PH_Draft,					
	MSG_PH_Outbox,		
	MSG_PH_Sent,				
	MSG_PH_PvInbox,			//phone private
	MSG_PH_PvDraft,			
	MSG_PH_PvOutbox,		
	MSG_PH_PvSent,		
	MSG_SIM1_InBox,			//sim1
	MSG_SIM1_Draft, 
	MSG_SIM1_Sent, 
	MSG_SIM2_InBox,  		//sim2
	MSG_SIM2_Draft,
	MSG_SIM2_Sent,   
	
	//--- multiple boxes --- 
	MSG_PH_PUBLIC_ALL = 0x80, 
	MSG_PH_PRIVATE_ALL,				
	MSG_PH_ALL,								
	MSG_SIM1_ALL,
	MSG_SIM2_ALL,

	MSG_BOX_INVALID = 0xff,	//no meaning
};
typedef u8 mmi_msg_box_t; 

enum {
	MSG_READ = 0,	
	MSG_UNREAD,	

	MSG_READ_INVALID = 0xff,	//no meaning							
};
typedef u8 mmi_msg_readstatus_t; 

enum {
	MSG_TO_SEND = 0,	
	MSG_SENT_FAIL,
	MSG_SENT_SUCCESS,	//only in sentbox
	//--- internal status ---
	MSG_SENDING,							
	MSG_SENT_RETRY,
	
	MSG_SEND_INVALID = 0xff,	//no meaning
};
typedef u8 mmi_msg_sendstatus_t;

enum {
	MSG_MODIFY_READ = 0,	
	MSG_MODIFY_SEND,
	MSG_MODIFY_BOX,
	MSG_MODIFY_TIME,	//not support
	MSG_MODIFY_SENDER,	//not support
};
typedef u8 mmi_msg_modify_type_t;

typedef struct
{
    u8 *pPhoneNum;                  ///< Phone number
    u8 len;                         ///< Length in bytes, without null terminate
} msg_recipient_type_t;

//mirror of ven_msg.h's ven_msg_sms_struct_t
typedef struct
{
    u16 *ptTelNo;
    u8 telNoLen;
    u16 *pData;                            ///< do type casting if type= VEN_MSG_DATA_BYTEDATA
    u16 dataLen;                           ///< equal to bytelen if type= VEN_MSG_DATA_BYTEDATA
    u32 timeStamp;                         ///< only for receive SMS. Time in seconds since 1979/01/01
    common_sim_id_t simId;             ///< Sim ID
    msg_sms_type_t smsType;            ///< encoding type
    u8 saveSentMsg;   ///< if save sent message in sent box, if port property is enabled, this will be ignored.
    u8 msgPortProp;   ///< if message with port property
    u16 port;                              ///< for port message
    msg_data_t type;                   ///< for port message
} mmi_msg_sms_struct_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *ptTelNo;
    u8 telNoLen;
    u16 *ptData;
    u16 dataLen;
    msg_sms_type_t smsType;
    common_sim_id_t simId;
    u8 bSaveSentMsg;
    u8 bRetrySendMsg;

    u8 bExt;  //0 for default
    struct
    {
        u16 desport;
        u16 senderport;
        msg_data_t dataType;
    } ext;

}mmi_msg_send_sms_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 port;
    msg_type_t msgType;
    u32 *pRetCode; //for sync

    void *pCBFunc;  //for callback
    u32 UserData;
}mmi_msg_register_port_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 port;
    msg_type_t msgType;
    s32 *pRetCode; //for sync
}mmi_msg_deregister_port_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    void *pMsgFilterFunc;
    void *pCBFunc;  //for callback
    u32 UserData;
    s32 *pRetCode; //for sync
}mmi_msg_register_all_sms_msg_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    s32 *pRetCode; //for sync
}mmi_msg_deregister_all_port_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    u16 *ptTelNo;
    u8 telNoLen;
    u32 *pRetCode; //for sync

    void *pCBFunc;  //for callback
    u32 UserData;
}mmi_msg_register_telno_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    u16 *ptTelNo;
    u8 telNoLen;
    u32 *pRetCode; //for sync
}mmi_msg_deregister_telno_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    u32 *pRetCode; //for sync
}mmi_msg_deregister_all_telno_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    u16 msgId;
    u8 keepMsg;
    u32 *pRetCode; //for sync
}mmi_msg_keep_telno_msg_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 msgId;
    mmi_msg_sms_struct_t *pReceivedMsg;  //for sync
	u32 *pRetCode; //for sync
}mmi_msg_get_received_sms_req_t;

typedef struct
{
    msg_mms_object_t objType;
    u16 *pMMSText; // MMS text
    u16 *pFilePath;// MMS embedded file path
} mmi_msg_mms_object;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u8 numOfRecipients;
    msg_recipient_type_t *pRecipientsList;
    msg_type_t msgType;
    union
    {
        u16 *pSMSText; // SMS text
        mmi_msg_mms_object MMSObj; // MMS object
    } content;
    u32 *pRetCode; //for sync
} mmi_msg_open_editor_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    u32 *pRetCode; //for sync
    void* pCBFunc;  //for callback
    u32   UserData;
} mmi_msg_register_srv_ready_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    msg_type_t msgType;
    s32 *pRetCode; //for sync
} mmi_msg_deregister_srv_ready_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
	msg_type_t type;
    u32 *pRetCode; //output: only useful if the ReqBase.bSync is TRUE
    u8 *pReady;
}mmi_msg_get_srv_ready_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    common_sim_id_t simId;
    u8 *pAddr;
    u8 *pAddrLen;
    u32 *pRetCode; //for sync
} mmi_msg_query_sms_srv_center_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    common_sim_id_t simId;
    u8 smsSrvCenterAddr[MSG_SMS_SERVICE_CENTER_MAX_CHAR+1];
    u32 *pRetCode; //for sync
} mmi_msg_set_sms_srv_center_t;

typedef struct {
    SMI_TimeStamp_t timestamp; 
    SMI_MsgID_t msgId;  
    mmi_msg_box_t box; 
    mmi_msg_readstatus_t readStatus;
    mmi_msg_sendstatus_t sendStatus;
    u8 addr[20*2+1];	// Sender Address
} mmi_msg_header_t; 

#ifdef __SDK_API_01_SMS_MMS_CC__
typedef struct
{
    mmi_ven_req_base_t venderData;
	u32 msgParam;
	u32 *pHdrNum;
	mmi_msg_header_t **ppHdrList;
    u32 *pRetCode; //for sync
} mmi_msg_sms_get_header_list_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	SMI_MsgID_t msgId;
	mmi_msg_box_t srcBox;
	mmi_msg_modify_type_t modifyType;
	mmi_msg_header_t msgHdr;
    u32 *pRetCode; //for sync
} mmi_msg_sms_modify_header_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	SMI_MsgID_t msgId;
	mmi_msg_box_t srcBox;
    u32 *pRetCode; //for sync
} mmi_msg_delete_req_t;

typedef struct
{
    mmi_ven_req_base_t 		venderData;
	common_sim_id_t 		simId;
	u8						*pFrom;
	u8						*pTo;
	u8						*pCc;
	u8						*pBcc;
	u8						*pSubject;
	u8						messageClass;
	u32 					expiry;
	u32 					deliveryTime;
	u8						priority;
	bool					senderVisibility;
	bool					deliveryReport;
	bool					readReply;
	u32 					contentNum;
	mmi_msg_mms_object 		*pContentArray;
} mmi_msg_mms_send_req_t;
#endif //#ifdef __SDK_API_01_SMS_MMS_CC__

typedef struct
{
    u8 addr[20*2+1];	//SMI_MAX_ADDR_LEN*2+1
} mmi_msg_phone_addr_t;

typedef struct
{
	mmi_msg_header_t msgHdr;
	u16 *pMsgCnt;
	msg_sms_type_t encoding;
	u16 receiverNum;
	mmi_msg_phone_addr_t *pReceiverList;
	u32 CRCValue;
	u32 Size;
	u16 reference; 	// 16 bit reference to cross check with Message part
	u8 IMSI[10];	//MMI_MMS_FS_MAX_IMSI_LEN
	u8 type; 		// SMI_MsgType_e, Message type for this message
	u8 msgFlag;
	u8 SimModule; 	// record the sim card for sent
	u8 SmsSimMsgBox;
	u8 IsWapVCardMessage; //check if it is VCard message
}mmi_msg_sms_backup_info_t; //iVen_msg_sms_backup_info_t

typedef struct
{
    mmi_ven_req_base_t venderData;
	SMI_MsgID_t msgId;
	mmi_msg_box_t box;
	mmi_msg_sms_backup_info_t* pBackupInfo; ////output: only useful if the ReqBase.bSync is TRUE
    u32 *pRetCode; //for sync	
} mmi_msg_sms_backup_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	mmi_msg_sms_backup_info_t* pRestoreInfo; 
    u32 *pRetCode; //for sync	
} mmi_msg_sms_restore_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	SMI_TimeStamp_t timestamp; 
	mmi_msg_box_t box;
	mmi_msg_readstatus_t readStatus;
	mmi_msg_sendstatus_t sendStatus;
	u16 *pMsgContent;
	u8 *pPhoneNum;		// Sender or Receiver Address
	common_sim_id_t simId;
    u32 *pRetCode; //for sync
    SMI_MsgID_t *pMsgId; //for sync
} mmi_msg_sms_add_req_t;

enum
{
    MSG_SMS_SEND_RESULT_SUCCESS  = 0,
    MSG_SMS_SEND_RESULT_FAIL = 1,
    MSG_SMS_SEND_RESULT_SAVETOOUTBOX_FAIL = 2,
};
typedef u8 msg_sms_send_result_t;

//Get Select SIM
enum
{
    MMI_VENDOR_SETTING_GET_MAKE_CALL_SIM = 0,
    MMI_VENDOR_SETTING_GET_SEND_SMS_SIM,
    MMI_VENDOR_SETTING_GET_CONNECT_WAP_SIM,
    MMI_VENDOR_SETTING_GET_CONNECT_MMS_SIM,
    MMI_VENDOR_SETTING_GET_CONNECT_JAVA_SIM,
    MMI_VENDOR_SETTING_GET_CONNECT_EMAIL_SIM,
#ifdef __NCCQQ_MMI__
    MMI_VENDOR_SETTING_GET_CONNECT_QQ_SIM,
#endif // __NCCQQ_MMI__
    MMI_VENDOR_SETTING_GET_CONNECT_VDO_STREAMING_SIM,
    MMI_VENDOR_SETTING_GET_SELECT_SIM,
    MMI_VENDOR_SETTING_GET_SIM_FUNCTION_SIZE,
};

typedef enum
{
    MMI_VENDOR_SEEK_MODE__OFF,             /// Disable seek
    MMI_VENDOR_SEEK_MODE__DOWNLOADED_ONLY, /// Support for seeking downloaded data
    MMI_VENDOR_SEEK_MODE__ALL,             /// Support for seeking all data
} mmi_ven_codec_SeekMode_e;

typedef enum
{
    MMI_VENDOR_MEDIA_STREAM_PROG__NOT_STARTED = 0,
    MMI_VENDOR_MEDIA_STREAM_PROG__PARTIAL,
    MMI_VENDOR_MEDIA_STREAM_PROG__COMPLETE,
}mmi_ven_codec_VideoStreamingProgress_e;

typedef enum
{
    MMI_VENDOR_VDOSTREAM_FILECHANGE_MOVE = 0,
    MMI_VENDOR_VDOSTREAM_FILECHANGE_COPY,
}mmi_ven_codec_VideoStreamingFileChangeMode_e;

typedef struct
{
    u16 *pURL;
    u16 nUrlLen;
    mmi_ven_codec_VideoStreamingProgress_e eVideoStreamingInfo;
}mmi_VideoStreamingInfo_t;    

typedef struct
{
    u16 *pSrcURL;
    u16 nSrcUrlLen;
    u16 *pDestURL;
    u16 nDestUrlLen;
    mmi_ven_codec_VideoStreamingFileChangeMode_e eOpMode;
}mmi_VideoStreamingFileChange_t;    

typedef struct
{
    s32 AvpMsg;
    u32 nDataSize;
    void *pData;    
}mmi_VideoStreamingAvpDLItf_t;
typedef u8 mmi_ven_select_sim_function_t;

enum
{
    MMI_VENDOR_SETTING_SELECT_MASTER_SIM = 0,
    MMI_VENDOR_SETTING_SELECT_SLAVE_SIM,
    MMI_VENDOR_SETTING_NO_SIM_ACTIVE,
    MMI_VENDOR_SETTING_SELECT_NONE,
};
typedef u8 mmi_ven_select_sim_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_select_sim_function_t type;
    void *pRetCode;  //only useful if the venderData.bSync is TRUE
    void *pSimID;    //only useful if the venderData.bSync is TRUE
}mmi_ven_select_sim_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	common_sim_id_t SimID;
    void *pRetCode;  //only useful if the venderData.bSync is TRUE
    void *pIccID;    //only useful if the venderData.bSync is TRUE
}mmi_ven_get_sim_iccid_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    void *pRetCode;  //only useful if the venderData.bSync is TRUE
    void *eStatus;    //only useful if the venderData.bSync is TRUE
}mmi_ven_getSIMStatus_req_t;


//////////////////////////////////////////////////////////////////////
//media
typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 *pMediaHandle;  //for sync
    u32 *pRetCode;      //for sync
} mmi_codec_open_media_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 mediaHandle;
    u32 *pRetCode; //for sync
} mmi_codec_close_media_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u16 *pURL;
    u16 urlLen;
    u32 *pRetCode;   //for sync
    void *pFileInfo; //for sync

} mmi_codec_get_file_info_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u32 *pPlayingTime;  //for sync
    u32 *pRetCode;  //for sync
} mmi_codec_get_playing_time_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    //MAEMediaPlayMode_e playMode;  //reference media.h's
    AudioSrvPlayMode_e playMode;
    u16 *pURL;  //null-terminated
    u32 position;
    u8 volume;      //0~8
    void *pCBFunc;  //for sync "play end"
    u32 UserData;   //for sync "play end"
    u32 *pRetCode; //for sync
} mmi_codec_play_audio_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    MediaSrvMimeType_e mediaFormat;
    AudioSrvPlayMode_e playMode;
    u8 *pData;
    u32 dataLen;
    u8 volume;      //0~8
    void *pCBFunc;  //for sync "play end"
    u32 UserData;   //for sync "play end"
    u32 *pRetCode; //for sync
} mmi_codec_play_audio_raw_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u32 *pRetCode; //for sync
} mmi_codec_pause_audio_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u32 *pRetCode; //for sync
} mmi_codec_resume_audio_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u32 *pRetCode; //for sync
} mmi_codec_stop_audio_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u32 position;
    u32 *pRetCode; //for sync
} mmi_codec_setpos_audio_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u8 volume;
    u32 *pRetCode;   //for sync
} mmi_codec_set_audio_volume_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    u8 *pVolume;     //for sync
    u32 *pRetCode;   //for sync
} mmi_codec_get_audio_volume_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    //MAEAudidoFormat_e mediaFormat;    //reference media.h's
    MediaSrvFileFormat_e mediaFormat;    //reference media.h's
    u16 *pURL;  //null-terminated
} mmi_codec_play_video_req_t;

typedef enum
{
    mmi_VIDEOPLAYERLAUNCHER_STREAMING_FILE_MODE,
    mmi_VIDEOPLAYERLAUNCHER_STREAMING_MEMORY_MODE
} mmi_VideoPlayerLauncherStreamingMode_e;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    MediaSrvMimeType_e eMimeType;    //reference media.h's
    u16 *pURL;  //null-terminated
    mmi_VideoPlayerLauncherStreamingMode_e estreamingMode;
    boolean bUseCusDownloadItf;
    void *pVendorDownloadItf;
    u32 nInitData;
} mmi_codec_play_videostreaming_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
} mmi_codec_stop_video_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 mediaHandle;
    mmi_VideoStreamingInfo_t VideoStreamingInfo;    
} mmi_codec_get_videostreaminginfo_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 mediaHandle;
    mmi_VideoStreamingFileChange_t VideoStreamingFileChange;    
    u32 * pRetCode;
} mmi_codec_videostreaming_filechange_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_codec_SeekMode_e eSeekMode;
} mmi_codec_set_video_seek_req_t;

typedef enum
{
    MMI_VEN_VIDEO_STATUS__PLAY_RESULT,
    MMI_VEN_VIDEO_STATUS__PLAYTICK,
    MMI_VEN_VIDEO_STATUS__TERMINATED,
} mmi_ven_video_status_e;

typedef enum
{    
    VENDORSRV_DOWNLOAD_EVENT_UNINIT = 0,               /// Init & Set parameters is delayed to start download stage
    VENDORSRV_DOWNLOAD_EVENT_START_DOWNLOAD,
    VENDORSRV_DOWNLOAD_EVENT_STOP_DOWNLOAD,
    VENDORSRV_DOWNLOAD_EVENT_NUM
} mmi_codec_videostreaming_download_event_e;

typedef struct
{
    mmi_codec_videostreaming_download_event_e eDownloadEventId;
    s32 mediaHandle;
    struct
    {		
        u16* pUrl;
        u32 nBufferSize;
        u32 nThreshold;
        u32 nPosition;
        bool bSetBufferSize:1;
        bool bSetThreshold:1;
        bool bSetPosition:1;
        bool bSetInitialize:1;
        bool bDoInitialize:1;
    }sParam;
} mmi_codec_videostreaming_download_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_DownloadStatusInfo_t status;
} mmi_codec_videostreaming_download_status_notify_req_t;

/////////////////////////////////////////////////////////////////////
//play midi structs
enum
{
    CODEC_MIDI_TYPE_TONE,
    CODEC_MIDI_TYPE_CH_VOLUME,
    CODEC_MIDI_TYPE_PROGRAM,
    CODEC_MIDI_TYPE_SHORT_EVENT,
    CODEC_MIDI_TYPE_LONG_EVENT
};

typedef u8 Codec_Midi_Type_t;

typedef struct
{

    u32 note;     //0~256
    u32 duration;
    u32 volume;   //0~100

} mmi_codec_midi_tone_t;

typedef struct
{
    u32 channel;
    u32 volume;

} mmi_codec_midi_chVolume_t;

typedef struct
{
    u32 channel;
    u32 bank;
    u32 program;

} mmi_codec_midi_program_t;

typedef struct
{
    u32 type;
    u32 param1;
    u32 param2;

} mmi_codec_midi_shortEvent_t;

typedef struct
{
    u8 *pLongEvent;
    u32 length;

} mmi_codec_midi_longEvent_t;

typedef struct
{
    mmi_ven_req_base_t venderData;

    s32 mediaHandle;
    Codec_Midi_Type_t midiType;
    union
    {
        mmi_codec_midi_tone_t midiTone;
        mmi_codec_midi_chVolume_t midiChVolume;
        mmi_codec_midi_program_t midiProgram;
        mmi_codec_midi_shortEvent_t midiShortEvent;
        mmi_codec_midi_longEvent_t midiLongEvent;
    } param;

    void *pCBFunc;  //for sync "play end"
    u32 UserData;   //for sync "play end"

    u32 *pRetCode; //for sync
} mmi_codec_play_midi_req_t;

/////////////////////////////////////////////////////////////////////

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 *pHandle;
    u32 *pRetCode; //for Sync
} mmi_codec_open_image_handle_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 imgCodecHandle;
    u32 *pRetCode; //for Sync
}mmi_codec_close_image_handle_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 imgCodecHandle;
    s32 frame;
    u32 angle;
    BitmapBase_t *pBitmapBase;    ///< Bitmap to store decodec data
    const u8 *pSrcBuf;        ///< Source buffer to decode
    u32 bufSize;         ///< Size of source buffer
    u16 *pSrcFileURL;    ///< URL of source file
    u32 *pRetCode;       ///< for Sync
    void *pDecodeStatus;  ///< for Sync
}mmi_codec_decode_image_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    s32 imgCodecHandle;
    u32 *pRetCode;       ///< for Sync
    void *pDecodeStatus;  ///< for Sync
}mmi_codec_decode_next_frame_req_t;

enum
{
    VISITEM_STATUS_BAR,
    VISITEM_SOFTKEY
};
typedef u8 mmi_ven_vis_item_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_vis_item_t ItemId;
    u32 *pRetCode;
    u8 bVis;
}mmi_ven_gra_set_vis_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_vis_item_t ItemId;
    u32 *pRetCode;
    u8 *pbVis;
}mmi_ven_gra_get_vis_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	u8 nDispMode;
    u32 *pRetCode; //for sync
}mmi_ven_gra_set_display_mode_req_t;

enum
{
    STC_BACKGROUND,
    STC_FOREGROUND,
};
typedef u8 mmi_ven_stc_t;

enum
{
    STC_RET_SUCCESS,
    STC_RET_FAILED,
    STC_RET_SUSPENDED,

    SCT_RET_SUM
};
typedef u8 mmi_ven_stc_ret_t;

typedef struct
{
    u32 AP_ID;
    MAE_Ret retCode;
}mmi_ven_stc_rsp_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u32 AP_ID;
    u32 *pRetCode; // For sync
}mmi_ven_stc_ind_t;

enum
{
    UI_MENU_TYPE_TEXT,
    UI_MENU_TYPE_NUMERIC_TEXT,

    MENU_STYLE_SUM
};

typedef u8 mmi_ven_menu_type_t;

enum
{
	UI_CONTNT_MENU,
	UI_CONTNT_DIALOG,
	UI_CONTNT_TEXTVIEWER,
    UI_CONTNT_SOFTKEY,

	UI_CONTNT_SUM
};
typedef u8 mmi_ven_ui_type_t;

enum
{
	UI_DIALOG_TYPE_INFORMATION,
	UI_DIALOG_TYPE_CONFIRMATION,
	UI_DIALOG_TYPE_WARNING,

	UI_DIALOG_TYPE_SUM
};
typedef u8 mmi_ven_dlg_type_t;

enum
{
	UI_USR_RSP_OK,
	UI_USR_RSP_CANCEL,

	UI_USR_RSP_SUM
};
typedef u8 mmi_ven_ui_usr_rsp_t;

enum
{
	UI_RET_SUCCESS,
	UI_RET_BUSY,
	UI_RET_TIMEOUT,
	UI_RET_FAILED,

	UI_RET_SUM
};
typedef u8 mmi_ven_ui_ret_t;

enum
{
	UI_INT_NORMAL           = 0x00,     ///< Allow all interruptions
	UI_INT_DENY_DIALOG      = 0x01,     ///< Refuse dialog interruptions ex.SMS/MMS dialog
	UI_INT_DENY_USB         = 0x02,     ///< Refuse USB screen when data cable is interted
    UI_INT_DENY_BT_OBEX     = 0x04,     ///< Refuse Bluetooth OBEX, no Bluetooth file transfer is allowed
    UI_INT_DENY_MT          = 0x08,     ///< Refuse mt call
    UI_INT_DENY_ALL         = 0x10,     ///< Refuse all interruptions

    UI_INT_SUM
};
typedef u8 mmi_ui_interrupt_level_t;

enum
{
    UI_NO_SK_PRESSED = 0,
    UI_LSK_PRESSED,
    UI_CSK_PRESSED,
    UI_RSK_PRESSED,
};
typedef u8 mmi_ui_softkey_status_t;

enum
{
    UI_SK_PREDEFINED_IMG = 0
,   ///< Predefined image from resource
    UI_SK_CUS_TEXT
,             ///< Customized text from vendor
    UI_SK_CUS_IMG
,              ///< Customized image from vendor
};
typedef u8 mmi_ui_softkey_attribute_t;

enum
{
    MMI_UI_BACKLIGHT_ON         = 0,    ///< LCD backlight is always on
    MMI_UI_BACKLIGHT_AUTO,              ///< LCD backlight will load the last setting, if the last setting is forever ON, then it will be set to forever ON.
    MMI_UI_BACKLIGHT_OFF,               ///< LCD backlight is always off
    MMI_UI_BACKLIGHT_FORCE_AUTO,	///< LCD backlight is automaitc on/off by the default timer
    MMI_UI_BACKLIGHT_SET,			///< LCD backlight is set by level and duration
    MMI_UI_BACKLIGHT_SUM,
};
typedef u8 mmi_ui_backlight_behavior_t;

enum
{
	MMI_UI_BACKLIGHT_LEVEL_0 = 0,
	MMI_UI_BACKLIGHT_LEVEL_1,
	MMI_UI_BACKLIGHT_LEVEL_2,
	MMI_UI_BACKLIGHT_LEVEL_3,
	MMI_UI_BACKLIGHT_LEVEL_4,
	MMI_UI_BACKLIGHT_LEVEL_5,
	MMI_UI_BACKLIGHT_LEVEL_6,
	MMI_UI_BACKLIGHT_LEVEL_MAX = MMI_UI_BACKLIGHT_LEVEL_6,
	MMI_UI_BACKLIGHT_LEVEL_DEFAULT,
};
typedef u16 mmi_ui_backlight_level_t;

enum
{
    MMI_UI_BACKLIGHT_DURATION_DEFAULT = 0xEEEE,
   	MMI_UI_BACKLIGHT_DURATION_FOREVER = 0xFFFF   //match with BKL_DURATION_ALWAYS_ON
};
typedef u16 mmi_ui_backlight_duration_t;


enum
{
    MMI_WAP_BROWSER_OPEN         = 0,
	MMI_WAP_BROWSER_DOWNLOAD,
    MMI_WAP_BROWSER_STORAGE_DOWNLOAD,
};
typedef u8 mmi_wap_browser_mode_t;
enum
{
    MMI_WAP_DL_STORAGE_CARD=0,
    MMI_WAP_DL_STORAGE_CARD2,
    MMI_WAP_DL_STORAGE_PHONE,
    MMI_WAP_DL_STORAGE_SYS_DEFAULT = 0xFF    
};
typedef u8 mmi_wap_browser_download_storage_t;


enum
{
    MMI_WAP_RSP_RET_SUCCESS = 0,
    MMI_WAP_RSP_RET_NETWORK_ERR,
    MMI_WAP_RSP_RET_DL_FAILED,
    MMI_WAP_RSP_RET_INIT_FAILED,
    MMI_WAP_RSP_RET_UNKNOWN_ERR,
};
typedef u32 mmi_wap_rsp_ret_t;

typedef struct
{
    u16 *pText;
    u32 nTextLen;
}mmi_ven_ui_menu_item_t;

typedef struct
{
    u16 *pText;
    u32 nTextLen;
}mmi_ven_ui_title_t;

typedef struct
{
    mmi_ven_ui_title_t tTitle;
    mmi_ven_menu_type_t nMenuType;
    mmi_ven_ui_menu_item_t *pItems;
    u32 nSize;
    u32 nHLIndex;
    void *pExtData;
    SoftkeyID_e aSoftkey[NUM_SK];
}mmi_ven_ui_menu_t;

typedef struct
{
    mmi_ven_ui_title_t tTitle;
    mmi_ven_dlg_type_t nDialogType;
    u16 *pText;          ///< UCS2 string pointer
    u32 nTextLen;      ///< character length of pText, not including end of string
    u32 nDuration;     ///< Dialog duration, in seconds
    SoftkeyID_e aSoftkey[NUM_SK];
    bool bShowOverEmbededAp;//Show on top of an enbeded app (Set this para to be TRUE only when you want to show dialog after you have launched a app.)
}mmi_ven_ui_dialog_t;

typedef struct
{
    mmi_ven_ui_title_t tTitle;
    u16 *pText;          ///< UCS2 string pointer
    u32 nTextLen;      ///< character length of pText, not including end of string
    SoftkeyID_e aSoftkey[NUM_SK];
}mmi_ven_ui_textviewer_t;

typedef struct
{
    mmi_ui_softkey_attribute_t lskAttr;
    union
    {
        u16 *pText;
        u8 *pImg;
        SoftkeyID_e eSoftkeyID;
    } lskData;
    mmi_ui_softkey_attribute_t cskAttr;
    union
    {
        u16 *pText;
        u8 *pImg;
        SoftkeyID_e eSoftkeyID;
    } cskData;
    mmi_ui_softkey_attribute_t rskAttr;
    union
    {
        u16 *pText;
        u8 *pImg;
        SoftkeyID_e eSoftkeyID;
    } rskData;
    mmi_ui_softkey_status_t softkeyStatus;
}mmi_ven_ui_softkey_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_ui_type_t contentType;
    void *pData;      ///< mmi_ven_ui_xxxx_t
    void *ptSyncRet;     ///< Sync only, store user rsp data
    u32 *pRetCode;     ///< Sync only, store command return code
    void *pContent;       ///< Pointer to content of menu/dialog/textviewer
    u32 transID;
}mmi_ven_ui_show_comp_req_t;

typedef mmi_ven_ui_show_comp_req_t mmi_ven_ui_update_comp_req_t;

typedef struct
{
    mmi_ven_ui_type_t contentType;
    void *pContent;       ///< Pointer to content of menu/dialog/textviewer
    u32 transID;
    u32 index;
    mmi_ven_ui_ret_t retCode;    ///< operation return code
    mmi_ven_ui_usr_rsp_t usrRsp;
}mmi_ven_ui_show_comp_rsp_t;

typedef struct
{
    mmi_ven_ui_type_t contentType;
    u32 index;
    mmi_ven_ui_ret_t retCode;    ///< operation return code
    mmi_ven_ui_usr_rsp_t usrRsp;
}mmi_ven_ui_show_comp_sync_rsp_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_ui_type_t contentType;
    u32 transID;
    u32 *pRetCode;
}mmi_ven_ui_close_comp_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ui_interrupt_level_t intLevel;
    void *ptSyncRet;     ///< Sync only, store user rsp data
    u32 *pRetCode;     ///< Sync only, store command return code
}mmi_ven_ui_set_interrupt_level_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u32 nIconIndex;
    u32 nDataSize;
    u8* pRawData;
    u8 nStatusbarImage;
} mmi_ven_ui_statusbar_draw_icon_req_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
	mmi_ui_backlight_behavior_t blkBehavior;
	u32 *pRetCode;
	mmi_ui_backlight_level_t blkLevel;
	mmi_ui_backlight_duration_t blkDuration;
}mmi_ven_ui_set_backlight_behavior_req_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
	mmi_ven_ui_ret_t retCode;   ///< operation return code
}mmi_ven_ui_set_backlight_behavior_rsp_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
    boolean bEnableLaunch;
	u32 *pRetCode;
}mmi_ven_ui_enable_launch_keyguard_req_t;

typedef struct
{
	mmi_ven_req_base_t venderData;
	mmi_ven_ui_ret_t retCode;   ///< operation return code
}mmi_ven_ui_enable_launch_keyguard_rsp_t;

typedef struct{
	mmi_ven_req_base_t venderData;
	boolean bAccess_SD;	//File Access on SD Card
}mmi_ven_file_file_access_ind_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u16 *pURL;  //null-terminated
    u16 nURLLen;
    u32 *pRetCode; //for sync
    mmi_wap_browser_download_storage_t storage;
    mmi_wap_browser_mode_t mode;
    u8 SimID;         //the SIM ID used to create datalink in browser (possible values are SIM_ONE, SIM_TWO, NO_SIM_SELECT)
    void *pfnCb;        //for calling back while calling wap dowloading or browser status
} mmi_wap_open_browser_req_t;

typedef struct
{
    u32 apID;
} mmi_ven_kpd_reset_backlight_req_t;



typedef struct
{
    common_sim_id_t nSimID;
} mmi_ven_util_get_cell_info_t;
typedef struct
{
    u8    Mcc[2];              ///< Main Cell Mcc 
    u8    Mnc;                 ///< Main Cell Mnc 
    u8    Lac[2];              ///< Main Cell LAC 
    u8    cellavailable;       ///< cellidavailable
    u8    CellId[2];           ///< Main Cell CI 
    u8    RxLev;               ///< Main Cell RxLev 
} mmi_ven_util_CellInfo_t;
#define MMI_VEN_NBMAX_NEAR (6)
typedef struct
{
    mmi_ven_util_CellInfo_t Serving;                        ///< Serving Cell inforamtion               
    u32                     nNeighbor;                      ///< Number of nearby cells in Neighbor table  
    mmi_ven_util_CellInfo_t Neighbor[MMI_VEN_NBMAX_NEAR];   ///< Neighbor Cell information   
} mmi_ven_util_CellInfoRsp_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    mmi_ven_util_get_cell_info_t *pCellInfoReq;
    mmi_ven_util_CellInfoRsp_t *pCellInfoData;
    u32* pRetCode;                //output: only useful if the ReqBase.bSync is TRUE
} mmi_ven_util_get_cellinfo_req_t;

typedef struct
{
    u8  apId;
    u32 userData;
}mmi_ven_get_usbInfo_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
    u32 nEventMask;
    void *pCBFunc;
    u32 UserData;
    u32 *pRetCode; //for sync
}mmi_ven_mm_register_listener_req_t;

#if defined (__G_SENSOR__)
typedef struct
{
    mmi_ven_req_base_t venderData;
	u32 nDelay;
	bool bListenOnPowerSavingMode;
	void *pGsensorNotify;
	u32 usrData;
    u32 *pRetCode; //for sync
}mmi_ven_sen_gsensor_reg_notify_req_t;

typedef struct
{
	u16 nAxisNum;
	u16 nSensitiveLevel;
} mmi_ven_sen_gsensor_devInfo_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	mmi_ven_sen_gsensor_devInfo_t* pDevInfo;
    u32 *pRetCode; //for sync
}mmi_ven_sen_gsensor_get_devinfo_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	u32 type;
	bool bListenOnPowerSavingMode;
	void *pMotionListener;
	u32 usrData;
    u32 *pRetCode; //for sync
}mmi_ven_sen_gsensor_reg_motion_listener_req_t;

typedef struct
{
    mmi_ven_req_base_t venderData;
	u32 type;
	u32* pMotionInfo;
    u32 *pRetCode; //for sync
}mmi_ven_sen_gsensor_get_last_motion_req_t;
#endif //#if defined (__G_SENSOR__)

typedef struct
{
    mmi_ven_req_base_t venderData;
	u16* pFileUrl;
	bool bIsDelete;
    u32 *pRetCode; //for sync
}mmi_ven_sen_btapp_send_file_req_t;

#endif //__MMI_VENDORSRV_REQ_ST_H__


