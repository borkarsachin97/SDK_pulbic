/**
* @file mmi_mms.h
*
* State Machine Service - MMS
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_MMS
*
*
* @version $Id$
*/
#ifndef __MMI_MMSSRV_H__
#define __MMI_MMSSRV_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_applet.h"
#include "mmi_mae_class.h"
#include "mmi_common_storage_mgr.h"
#include "mmi_common_sms_master.h"
#include "mmi_req_cdmms.h"
#define MMS_INVALID_ID                      0xFFFF


typedef enum
{
    MMS_NOTIFY_MASK_NONE = 0
   ,MMS_NOTIFY_MASK_SEND = 0x00000001
   ,MMS_NOTIFY_MASK_RETRIEVE = 0x00000002
   ,MMS_NOTIFY_MASK_NEW_RECEIVED_IND = 0x00000004
   ,MMS_NOTIFY_MASK_SEND_IND = 0x00000008
   ,MMS_NOTIFY_MASK_RETRIEVE_IND = 0x00000010
   ,MMS_NOTIFY_MASK_SERVICE_STATUS_IND = 0x00000020
   ,MMS_NOTIFY_MASK_DELIVERY_REPORT_IND = 0x00000040
   ,MMS_NOTIFY_MASK_READ_REPORT_IND = 0x00000080
   ,MMS_NOTIFY_MASK_ALL = MMS_NOTIFY_MASK_SEND | MMS_NOTIFY_MASK_RETRIEVE | MMS_NOTIFY_MASK_NEW_RECEIVED_IND | MMS_NOTIFY_MASK_SEND_IND | MMS_NOTIFY_MASK_RETRIEVE_IND | MMS_NOTIFY_MASK_SERVICE_STATUS_IND | MMS_NOTIFY_MASK_DELIVERY_REPORT_IND | MMS_NOTIFY_MASK_READ_REPORT_IND,
} MMS_Notify_Mask_e;

typedef enum
{
    MMS_MSG_STATUS_NOT_FOUND
   ,MMS_MSG_STATUS_SENDING
   ,MMS_MSG_STATUS_RETRIEVING
   ,MMS_MSG_STATUS_QUEUED_FOR_SENDING
   ,MMS_MSG_STATUS_QUEUED_FOR_RETRIEVING
   ,MMS_MSG_STATUS_QUEUED_BUT_SUSPENDED
} MMS_Message_Status_e;

/**
 * External Events
 */
#define MMS_EVT_CancelFailed                (CLSID_MMS << 16 | 1)
#define MMS_EVT_CancelRetrieving                (CLSID_MMS << 16 | 2)
#define MMS_EVT_CancelSending               (CLSID_MMS << 16 | 3)
#define MMS_EVT_CancelSuccess               (CLSID_MMS << 16 | 4)
#define MMS_EVT_NewMessageReceivedInd               (CLSID_MMS << 16 | 5)
#define MMS_EVT_NewNotifyReceivedInd                (CLSID_MMS << 16 | 6)
#define MMS_EVT_RetrieveFailed              (CLSID_MMS << 16 | 7)
#define MMS_EVT_RetrieveMessage             (CLSID_MMS << 16 | 8)
#define MMS_EVT_RetrieveSuccess             (CLSID_MMS << 16 | 9)
#define MMS_EVT_RetrievingDoneInd               (CLSID_MMS << 16 | 10)
#define MMS_EVT_RetrievingStartInd              (CLSID_MMS << 16 | 11)
#define MMS_EVT_SendFailed              (CLSID_MMS << 16 | 12)
#define MMS_EVT_SendingDoneInd              (CLSID_MMS << 16 | 13)
#define MMS_EVT_SendingStartInd             (CLSID_MMS << 16 | 14)
#define MMS_EVT_SendMessage             (CLSID_MMS << 16 | 15)
#define MMS_EVT_SendSuccess             (CLSID_MMS << 16 | 16)
#define MMS_EVT_SendFailedCountInd              (CLSID_MMS << 16 | 17)
#define MMS_EVT_RetrieveFailedCountInd              (CLSID_MMS << 16 | 18)
#define MMS_EVT_ServiceReadyInd             (CLSID_MMS << 16 | 19)
#define MMS_EVT_ServiceNotReadyInd              (CLSID_MMS << 16 | 20)
#define MMS_EVT_ServiceSuspendInd               (CLSID_MMS << 16 | 21)
#define MMS_EVT_ServiceResumedInd               (CLSID_MMS << 16 | 22)
#define MMS_EVT_NewMessageDownloadedInd             (CLSID_MMS << 16 | 23)
#define MMS_EVT_MessageReSyncStartInd               (CLSID_MMS << 16 | 24)
#define MMS_EVT_MessageReSyncEndInd             (CLSID_MMS << 16 | 25)
#define MMS_EVT_DeliveryReportInd               (CLSID_MMS << 16 | 26)
#define MMS_EVT_ReadReportInd               (CLSID_MMS << 16 | 27)
#define MMS_EVT_RetrieveFailedNoStorageInd               (CLSID_MMS << 16 | 28)
#define MMS_EVT_RetrieveFailedOverSize                (CLSID_MMS << 16 | 29)



/**
 * IMMS Interfaces
 */
#define INHERIT_IMMS(IName) \
    INHERIT_IHandler(IName); \
	MAE_Ret		(*AddSMSPushData)		( IName * , MMI_NewMmsNote_t* pNewMmsNote); \
    MAE_Ret     (*CancelRetrieving)     ( IName * , u16 nMsgId);  \
    MAE_Ret     (*CancelSending)        ( IName * , u16 nMsgId);  \
    MAE_Ret     (*Deregister_Notification)      ( IName * , void* pInst, MMS_Notify_Mask_e mask);  \
    u16     (*GetCurrentMessageID)      ( IName * );  \
    boolean     (*IsActive)     ( IName * );  \
    MMS_Message_Status_e        (*QueryMessageStatus)       ( IName * , u16 nMsgId);  \
    MAE_Ret     (*Register_Notification)        ( IName * , void* pInst, MMS_Notify_Mask_e mask);  \
    MAE_Ret     (*RetrieveMessage)      ( IName * , u16 nMsgId);  \
    MAE_Ret     (*SendMessage)      ( IName * , u16 nMsgId, u8 nModId);  \
    MAE_Ret     (*SendReadReply)      ( IName * , u16 nMsgId, u8 nModId);  \
    boolean     (*IsServiceReady)       ( IName * );  \
    void        (*ServiceSuspend)       ( IName * , void* pUsrData);  \
    void        (*ServiceResume)        ( IName * , void* pUsrData);  \
	boolean		(*IsReloading)		( IName * );  \
	MAE_Ret		(*SetStorage)		( IName * , VFS_VOL_TYPE eStorageDeviceType, boolean bNeedReload); \
	MAE_Ret		(*RetrySendMessage)		( IName * , SMI_MsgID_t nMsgId, u8 nSimModId); \
	u32		    (*IsEditorReady)		( IName * )	; \
	MAE_Ret		(*SendSDKMessage)		( IName * , u8 nModuleId, u8* pAppId, u8* pReplyToAppId, MMI_MMS_SendReq_t* pSendReq, pfnMmsSendCnf_t fnSendCnf, u32 nCallerID)
DEFINE_INTERFACE(IMMS);


#define IMMS_QueryInterface(pICntlr, id, pp, po)            GET_FUNCTBL((pICntlr), IMMS)->QueryInterface(pICntlr, id, pp, po)
#define IMMS_HandleEvent(pICntlr, e, p1, p2)                GET_FUNCTBL((pICntlr), IMMS)->HandleEvent(pICntlr, e, p1, p2)
/**
 
Add a SMS push data to queue as a working item.
This item will be processed when MMS service is ready.

@param MMI_NewMmsNote_t*
       A pointer of date type MMI_NewMmsNote_t. The data is allocated from MOI.
@return
       Return the result of method call.
 */
#define IMMS_AddSMSPushData(pICntlr, p1)	GET_FUNCTBL((pICntlr), IMMS)->AddSMSPushData( pICntlr, p1)
/**

Cancel the retrieve request of specified message id.
This is an asynchronous method. So, if the return value is #MAE_RET_SUCCESS, the processed result
will be sent to the registered listener later. In order to receive the processed result, the caller
should register a listener via the method IMMS_Register_Notification with mask value
#MMS_NOTIFY_MASK_RETRIEVE first.

@param nMsgId
       The message id for this request.
@return
       Return the result of method call.
@result
       #MMS_EVT_CancelSuccess
           The retrieve request has been canceled successfully.
       #MMS_EVT_CancelFailed
           The retrieve request has been canceled unsuccessfully.

 */
#define IMMS_CancelRetrieving(pICntlr, p1)  GET_FUNCTBL((pICntlr), IMMS)->CancelRetrieving( pICntlr, p1)
/**

Cancel the send request of specified message id.
This is an asynchronous method. So, if the return value is #MAE_RET_SUCCESS, the processed result
will be sent to the registered listener later. In order to receive the processed result, the caller
should register a listener via the method IMMS_Register_Notification with mask value
#MMS_NOTIFY_MASK_SEND first.

@param nMsgId
       The message id for this request.
@return
       Return the result of method call.
@result
       #MMS_EVT_CancelSuccess
           The send request has been canceled successfully.
       #MMS_EVT_CancelFailed
           The send request has been canceled unsuccessfully.

 */
#define IMMS_CancelSending(pICntlr, p1) GET_FUNCTBL((pICntlr), IMMS)->CancelSending( pICntlr, p1)
/**

Remove the listener associated with the specified instance.

@param pInst
        A pointer to a specified instance.
@param mask
       This value is used for un-defining event filter rules. The mask value is composited by following
       #MMS_NOTIFY_MASK_SEND
           Bit mask for the event of sending state.
       #MMS_NOTIFY_MASK_RETRIEVE
           Bit mask for the event of retrieving state.
       #MMS_NOTIFY_MASK_NEW_RECEIVED_IND
           Bit mask for the indication of new received state.
       #MMS_NOTIFY_MASK_SEND_IND
           Bit mask for the indication of sending state.
       #MMS_NOTIFY_MASK_RETRIEVE_IND
           Bit mask for the indication of retrieving state.
@return
       Return the result of method call.

 */
#define IMMS_Deregister_Notification(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), IMMS)->Deregister_Notification( pICntlr, p1, p2)
/**

@return
       Return the id of current handling message. If no message is handling, then the value MMS_INVALID_ID will be returned.

 */
#define IMMS_GetCurrentMessageID(pICntlr)   GET_FUNCTBL((pICntlr), IMMS)->GetCurrentMessageID( pICntlr)
/**

@return
       Return the result of method call. If the MMS Service is active then return TRUE else return FALSE.

 */
#define IMMS_IsActive(pICntlr)  GET_FUNCTBL((pICntlr), IMMS)->IsActive( pICntlr)
/**

@param nMsgId
       The message id for this request.
@return
       Return the message status of specified id. One of following values is returned as status.
       #MMS_MSG_STATUS_NOT_FOUND
           The message of specified id is not in queue.
       #MMS_MSG_STATUS_SENDING
           The message of specified id is sending.
       #MMS_MSG_STATUS_RETRIEVING
           The message of specified id is retrieving.
       #MMS_MSG_STATUS_QUEUED_FOR_SENDING
           The message of specified id is queued for sending.
       #MMS_MSG_STATUS_QUEUED_FOR_RETRIEVING
           The message of specified id is queued for retrieving.

 */
#define IMMS_QueryMessageStatus(pICntlr, p1)    GET_FUNCTBL((pICntlr), IMMS)->QueryMessageStatus( pICntlr, p1)
/**

Add the listener associated with the specified instance.

@param pInst
        A pointer to a specified instance.
@param mask
       This value is used for defining event filter rules. The mask value is composited by following
       #MMS_NOTIFY_MASK_SEND
           Bit mask for the event of sending state.
       #MMS_NOTIFY_MASK_RETRIEVE
           Bit mask for the event of retrieving state.
       #MMS_NOTIFY_MASK_NEW_RECEIVED_IND
           Bit mask for the indication of new received state.
       #MMS_NOTIFY_MASK_SEND_IND
           Bit mask for the indication of sending state.
       #MMS_NOTIFY_MASK_RETRIEVE_IND
           Bit mask for the indication of retrieving state.
@return
       Return the result of method call.

 */
#define IMMS_Register_Notification(pICntlr, p1, p2) GET_FUNCTBL((pICntlr), IMMS)->Register_Notification( pICntlr, p1, p2)
/**

Request to retrieve a message by a specified id.
This is an asynchronous method. So, if the return value is #MAE_RET_SUCCESS, the processed result
will be sent to the registered listener later. In order to receive the processed result, the caller
should register a listener via the method IMMS_Register_Notification with mask value
#MMS_NOTIFY_MASK_RETRIEVE first.

@param nMsgId
       The message id for this request.
@return
       Return the result of method call.
@result
       #MMS_EVT_RetrieveSuccess

       #MMS_EVT_RetrieveFailed


 */
#define IMMS_RetrieveMessage(pICntlr, p1)   GET_FUNCTBL((pICntlr), IMMS)->RetrieveMessage( pICntlr, p1)
/**

Request to send a message by a specified id.
This is an asynchronous method. So, if the return value is #MAE_RET_SUCCESS, the processed result
will be sent to the registered listener later. In order to receive the processed result, the caller
should register a listener via the method IMMS_Register_Notification with mask value
#MMS_NOTIFY_MASK_SEND first.

@param nMsgId
       The message id for this request.
@return
       Return the result of method call.
@result
       #MMS_EVT_SendMessage

       #MMS_EVT_SendFailed


 */
#define IMMS_SendMessage(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), IMMS)->SendMessage( pICntlr, p1, p2)
/**

Request to send a read reply by a specified id.

@param nMsgId
       The message id for this request.
@return
       Return the result of method call.

 */
#define IMMS_SendReadReply(pICntlr, p1, p2)   GET_FUNCTBL((pICntlr), IMMS)->SendReadReply( pICntlr, p1, p2)
/**

@return
       Return the result of method call. If the MMS Service is ready for using then return TRUE else return FALSE.
       During the time all trans-requests will not be allowed.

 */
#define IMMS_IsServiceReady(pICntlr)    GET_FUNCTBL((pICntlr), IMMS)->IsServiceReady( pICntlr)
/**

Request to suspend the MMS service for network resource control.
This is an asynchronous method. So, The processed result will be sent to the registered listener later.
In order to receive the processed result, the caller should register a listener via the method
IMMS_Register_Notification with mask value #MMS_NOTIFY_MASK_SERVICE_STATUS_IND first.

@param pUsrData
       The instance pointer of requestor.
@result
       After service is suspended, MMS_EVT_ServiceSuspendInd will send to requestor.
       The requestor MUST to wait until MMS_EVT_ServiceSuspendInd received.

 */
#define IMMS_ServiceSuspend(pICntlr, p1)    GET_FUNCTBL((pICntlr), IMMS)->ServiceSuspend( pICntlr, p1)
/**

Request to resume the MMS service for network resource control.
This is an asynchronous method. So, The processed result will be sent to the registered listener later.
In order to receive the processed result, the caller should register a listener via the method
IMMS_Register_Notification with mask value #MMS_NOTIFY_MASK_SERVICE_STATUS_IND first.

@param pUsrData
       The instance pointer of requestor.
@result
       After service is resumed, MMS_EVT_ServiceResumedInd will send to requestor.
       The requestor NO NEED to wait until MMS_EVT_ServiceResumedInd received.

 */
#define IMMS_ServiceResume(pICntlr, p1) GET_FUNCTBL((pICntlr), IMMS)->ServiceResume( pICntlr, p1)
/**

@return
       Return the result of method call. If the MMS Service is busy reloading messages for each mailbox then return TRUE else return FALSE.
       During the time all trans-requests will not be allowed.

 */
#define IMMS_IsReloading(pICntlr)   GET_FUNCTBL((pICntlr), IMMS)->IsReloading( pICntlr)
/**
 Retry to send a message by a specified id.
If the MMS in outbox isn't sending status, it will be updated as unsent status and MMS service will send it later.
@param nMsgId
       The message ID.
@param nSimModId
       SIM Module ID, (DUAL_MASTER or DUAL_SLAVE)
@return
       Return the result of method call.
 */
#define IMMS_RetrySendMessage(pICntlr, p1, p2)	GET_FUNCTBL((pICntlr), IMMS)->RetrySendMessage( pICntlr, p1, p2)
/**
 
Request to specify the storage by a specified id.

@param eStorageDeviceType
       The specified storage type.
@param bNeedReload
       Specify the raw data should be reloaded or not
@return
       Return the result of method call.

 */
#define IMMS_SetStorage(pICntlr, p1, p2)	GET_FUNCTBL((pICntlr), IMMS)->SetStorage( pICntlr, p1, p2)

/**
@return
       Return the checking editor result before opening MMS editor 
 */
#define IMMS_IsEditorReady(pICntlr)   GET_FUNCTBL((pICntlr), IMMS)->IsEditorReady( pICntlr)

/**
The Sending function for SDK(JSR-205)

@param nModuleId
       The SIM Id on which the MMS is requested to be sent
@param pAppId
       Application Id string(ASCII only) to be encoded in the sending message
@param pReplyToAppId
       Reply-To-Application-Id to be encoded in the sending message
@param pSendReq
        A pointer of date type MMI_MMS_SendReq_t. The data is allocated from Vendor service
@param fnSendCnf
       Callback function when a sending response is received 
@param nCallerID
       Caller Id
@return
       If the return value is MAE_RET_SUCCESS. It means that the sending request is accepted.
       pfnSendCnfCB will be called while a result is posted.
       Otherwise, the sending request is not accepted. (no callback will be called).

 */
#define IMMS_SendSDKMessage(pICntlr, p1, p2, p3, p4, p5, p6)	GET_FUNCTBL((pICntlr), IMMS)->SendSDKMessage( pICntlr, p1, p2, p3, p4, p5, p6)

/**
 * Functions
 */

void MMS_Init(void);

__SLDPM_FREE__ MAE_Ret MMS_New(MAE_ClsId id, void **ppObj);

#endif /* __MMI_MMSSRV_H__ */
