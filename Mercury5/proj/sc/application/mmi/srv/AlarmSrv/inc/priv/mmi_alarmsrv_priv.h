/**
* @file mmi_alarmsrv_priv.h
*
* Service without using State Machine - ALARMSRV
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_ALARMSRV
* Interface Id: IID_ALARMSRV
*
* @version $Id$
*/
#ifndef __MMI_ALARMSRV_PRIV_H__
#define __MMI_ALARMSRV_PRIV_H__

#include "mmi_mae_common_def.h"
#include "mmi_alarmsrv.h"
#include "mmi_mae_notifier.h"
#include "mmi_mae_datamodel.h"
#include "mmi_mae_arraymodel.h"
#include "mmi_mae_clock.h"
#include "mmi_evtcentersrv.h"
#include "mmi_cfgsrv.h"
#include "mmi_sys_cfg.h"
#include "mmi_alarmapp_cfg.h"
#include "mmi_common_cfg.h"
#include "mmi_mae_clock_types.h"
#include "mmi_schedulersrv.h"

#define ALARMSRV_SECONDS_PER_DAY 86400

/* Definitions */

#define ALARMSRV_INIT_SIZE 32       ///< Initial size of list, we expend twice larger if is not enough enough. It would stop after reach ALARMSRV_MAX_ALARM_SIZE.
#define ALARMSRV_EOF_LIST   0xFFFF  ///< Since we use array to pretend a linked-list, if next == ALARMSRV_EOF_LIST, we would treat this as the last node.
#define ALARMSRV_MAX_ALARM_SIZE 1800 /**<Maximum of size of alarm list. There are two constraints. One is ram and the other is the size of one alarm File.
The size limitation of RAI items is 30*1024 now. One Alarm node cost 16 bytes and the list context cost 12 bytes.
The maximum of alarm list would be (30*1024 - 12 - 6(rai overhead)/16 ~= 1918) */

#define ALARMSRV_THRESHOLD  30 /**< If one alarm is expired, the next alarm is also exired if these two alarms are too close,
we'll trigger a short alarm after expiration of the first alarm. It is 30 seconds now. */
#define ALARMSRV_SAFE_PATTERN 0xFF4D4145  ///< 0xFF M A E

#define ALARMSRV_CHECK_NEXT_ALARM_TIMER  5 // Timer for sending the next alarm which in the expired alarm list to EvtCenterSrv.
#define ALARMSRV_MAXIMUM_ALARM_LIMIT  30 // Limitation for the number of alarms that EvtCenterSrv can handle when they expired at the same time.

#define ALARMSRV_ARRAY_SIZE_INIT 50
#define ALARMSRV_ARRAY_SIZE_GROW 10

typedef struct
{
    MAE_ClsId clsID;                ///< Class ID
    u32 userCode;                   ///< User code, will passed back to user once the alarm expired.
}ExpiredAlarmInfo_t;

typedef struct
{
    MAE_ClsId clsID;                ///< Class ID
    MAE_DateTime_t dateTime;        ///< The time which alarm should be expired
    u32 userCode;                   ///< User code, will passed back to user once the alarm expired.
}Alarm_Node_t;

typedef struct
{
    u32 nCheckPattern;               ///< Check pattern in alarmInfo to prevent file corruption.
    u16 nMaxAlarmListSize;                        /**<  Record the max size of the Alarm list, when the size reach max, we reallocate more
                                                  buffer. The current limitation is 65535. */
    u16 nAlarmListSize;                    ///< The number of users who alrady set alarms, which is just the size of Alarm List.
    boolean bActived;                     ///< Indicate if alarm is actived.
    Alarm_Node_t pList[ALARMSRV_INIT_SIZE];            ///< A fake linked-list to store alarms, sorted by time duration to now from near to far.
}Alarm_Info_t;

/**
* Application structure
*/
typedef struct MMI_ALARMSRV_TAG
{
    DECLARE_FUNCTBL(IALARMSRV);   // function table pointer
    u32 refCnt;     // reference count
    /* Add custom fields below */
    void *pAppInst; // For keeping the instance of OnApp.
    IDataModel *pIAlarmModel; // A data model for storing the expired alarm alert data.
    MAE_Notifier_t *pNotifier;
    ICFGSrv *pICFGSrv;
    IEVTCENTERSRV *pIEvtCenterSrv;
    ISCHEDULERSRV *pISchSrv;
    IClock *pIClock; ///<
    IArrayModel *pIExpiredAlarmList; // List of the expired alarms.
    IArrayModel *pIActiveAlarmList; // List of the active alarms. It means the alarm is expired and the alarm dialog is not closed yet.
    IArrayModel *pIDisposedAlarmList; // List of the expired alarms.
    ArrayClass_t *pEvtIdList; // List of event ids.
    s32 nTZOffset;
    ClockListener_t IClockListener; ///< Model listener to IClock, responses when system time is changed.
    ModelListener_t stConfigListener; ///< Model listener to ICFGSRV, responses when default alarm ringtone is changed.
    u32 alarmFileID;                ///< RAI ID which stores current alarm file. We prepare 3 ID for Alarm to store a single file for security.
    MAE_WChar stAlarmToneURL[FILEMGR_MAX_FILEPATH_SIZE];
    MAE_DateTime_t stAutoPowerOffTime;
    SetOnOff_e eAutoPowerOffAlarmStatus; // Flag for checking whether or not Auto Power Off Alarm is set.
    Alarm_Info_t *pInfo;            ///< Alarm information
    SysTimeZoneType_e eCurrentTimeZone;
    ALARMSRV_ALARMALERTREPLY_e eAlarmAlertReply; // Reply value from the alarm alert dialog indicates which softkey is pressed.
    u32 nExpiredAlarmUserCode; // Reply value from the alarm alert dialog indicates the expired alarm UserCode.
    boolean bIsTerminated; // Flag for checking whether or not AlarmSrv has been terminated.
    boolean bIsDelayToNotify; // Flag for checking whether or not delay to send alarm expired notify to EvtCenterSrv to make sure alarm alert dialog can be handled before handset is auto power off.
    boolean bIsAutoPowerOffAlarmExpired; // Flag for checking if the auto power off alarm is expired.
#ifdef __APP_MMI_SOHU_UPDATER__
    MAE_DateTime_t stSohuUpdatetime;
    ALARM_STATUS_e eSohuUpdateStatus; // Flag for checking whether or not Auto Power Off Alarm is set.
    boolean bIsSohuAlarmExpired; // Flag for checking if the auto power off alarm is expired.
    boolean bIsSohuDelayToNotify; // Flag for checking whether or not delay to send alarm expired notify to EvtCenterSrv to make sure alarm alert dialog can be handled before handset is auto power off.
#endif
    boolean bIsForcePowerOff;
#ifdef __APP_MMI_AZAN__
    MAE_DateTime_t stAzanUpdatetime;
    ALARM_STATUS_e eAzanUpdateStatus; // Flag for checking whether or not Auto Power Off Alarm is set.
#endif

    u32 nActiveAlarmNum;
    u32 nSchedulerSrvConfirmCnt;

} MMI_ALARMSRV;

static MAE_Ret _ALARMSRV_SetAlarm(MMI_ALARMSRV *pThis, MAE_ClsId clsID, MAE_DateTime_t *pDateTime, u32 userCode);
static MAE_Ret _ALARMSRV_CancelAlarm(MMI_ALARMSRV *pThis, MAE_ClsId clsID, u32 userCode);
static MAE_Ret _ALARMSRV_StoreToFile(MMI_ALARMSRV *pThis);
static MAE_Ret _ALARMSRV_ReadFromFile(MMI_ALARMSRV *pThis);
static MAE_Ret _ALARMSRV_SplitAlarmQueue(MMI_ALARMSRV *pThis, Alarm_Info_t **pInfo1, Alarm_Info_t **pInfo2);
static MAE_Ret _ALARMSRV_MergeAlarmQueue(MMI_ALARMSRV *pThis, Alarm_Info_t *pInfo1, Alarm_Info_t **ppInfo2);
static void _ALARMSRV_NextAlarm(MMI_ALARMSRV *pThis);
__SLDPM_FREE__ static void _ALARMSRV_ClockListener(void *pUsrData, MAEClkItemId_t id, void *pItemData);
static void _ALARMSRV_ConfigModelListener(void *pUserData, ModelEvent_t *pModelEvent);
static MAE_Ret _ALARMSRV_HandleAlarmEvent(IALARMSRV *pIALARMSRV, ALARMSRV_PHONESTATE_e ePhoneState, ALARMSRV_ALARMCAUSE_e eAlarmCause, u32 nUserCode);
static MAE_Ret _ALARMSRV_HandleDisposedAlarmEvent(IALARMSRV *pIALARMSRV, ALARMSRV_ALARMCAUSE_e eAlarmCause, u32 nUserCode);
static void _ALARMSRV_CloseAlarmAlert_Callback(void *data);
static void _ALARMSRV_CheckAlarmExist_Callback(IBase *pObj, u32 nParam);
static void _ALARMSRV_SystemTimeChange_Callback(void *data);
__SLDPM_FREE__ static void _ALARMSRV_MinuteTick_Callback(void *data);
static void _ALARMSRV_SendNextAlarmTimeOut(void *pUser);
static void _ALARMSRV_SendNextDisposedAlarmTimeOut(void *pUser);
static void _ALARMSRV_SendNextCalendarTimeZoneChangeTimeOut(void *pUser);
static MAE_Ret _ALARMSRV_DoResetAlarmNotify(MMI_ALARMSRV *pThis, u32 nUserCode);
static MAE_Ret _ALARMSRV_SetAlarmClockAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, ALARM_RECORD_t *pAlarmRecord);
static MAE_Ret _ALARMSRV_SetAlarmClockNextAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, ALARM_RECORD_t *pAlarmRecord, boolean bIsResetOnceAlarm);
static MAE_Ret _ALARMSRV_CloseAlarmClockAlarmAlert(MMI_ALARMSRV *pThis, u32 nAlarmUID, boolean bIsSnoozed);
static MAE_Ret _ALARMSRV_HandleAlarmClockTimeZoneChange(MMI_ALARMSRV *pThis);
static MAE_Ret _ALARMSRV_HandleAlarmClockDisposedAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID);
static boolean _ALARMSRV_IsAlarmClockDisposeAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, MAE_DateTime_t *pCurrentTime, MAE_DateTime_t *pAlarmTime);
static MAE_Ret _ALARMSRV_CloseCalendarEventAlert(MMI_ALARMSRV *pThis, u32 nEventUID, boolean bIsSnoozed);
MAE_Ret _ALARMSRV_HandleCalendarTimeZoneChange(MMI_ALARMSRV *pThis, s32 nTZOffset);
MAE_Ret _ALARMSRV_HandleCalendarDisposedAlarm(MMI_ALARMSRV *pThis, u32 nEventUID);
boolean _ALARMSRV_IsCalendarDisposeAlarm(MMI_ALARMSRV *pThis, u32 nEventUID, MAE_DateTime_t *pCurrentTime, MAE_DateTime_t *pAlarmTime);
#ifdef __APP_MMI_SOHU_UPDATER__
static MAE_Ret _ALARMSRV_SetSOHUUpadatAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, SOHU_ENTITY_t *pAlarmRecord);
static MAE_Ret _ALARMSRV_SetSOHUNextAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, SOHU_ENTITY_t *pAlarmRecord, boolean bIsResetOnceAlarm);
static void _ALARMSRV_SetNextSOHUUpdateAlarm(MMI_ALARMSRV *pThis, u32 *pTime, ALARM_STATUS_e *pStatus, ALARM_SOHU_FREQUENCY_e *pFrequency, boolean bIsResetOnceAlarm);
static MAE_Ret _ALARMSRV_CloseSOHUUpdateAlert(MMI_ALARMSRV *pThis, u32 nAlarmUID, boolean bIsSnoozed);
static boolean _ALARMSRV_SOHUDisposeAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, MAE_DateTime_t *pCurrentTime, MAE_DateTime_t *pAlarmTime);
static MAE_Ret _ALARMSRV_HandleSOHUDisposedAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID);
#endif
#ifdef __APP_MMI_AZAN__
static MAE_Ret _ALARMSRV_GetNextAzanAlarm(MMI_ALARMSRV *pThis, u32 *pTime, ALARM_STATUS_e *pStatus);
static MAE_Ret _ALARMSRV_InitAzanAlarm(MMI_ALARMSRV *pThis,boolean bNextDay);
static MAE_Ret _ALARMSRV_SetupAzanAlarm(MMI_ALARMSRV *pThis, boolean bReInit);
static void _ALARMSRV_CheckAzanInit(MMI_ALARMSRV *pThis);
static MAE_Ret _ALARMSRV_GetAzanSetting(MMI_ALARMSRV *pThis, AzanSettingInfo_t *pAzanSetting);
static MAE_Ret _ALARMSRV_CloseAzanAlert(MMI_ALARMSRV *pThis, u32 nAlarmUID, boolean bIsSnoozed);
static MAE_Ret _ALARMSRV_HandleAzanTimeZoneChange(MMI_ALARMSRV *pThis);
static MAE_Ret _ALARMSRV_HandleAzanDisposedAlarm(MMI_ALARMSRV *pThis, u32 nEventUID);
static boolean _ALARMSRV_AzanisposeAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, MAE_DateTime_t *pCurrentTime, MAE_DateTime_t *pAlarmTime);
static boolean _ALARMSRV_AzanIsPoseAlarm(MMI_ALARMSRV *pThis, u32 nAlarmUID, MAE_DateTime_t *pCurrentTime, MAE_DateTime_t *pAlarmTime);
#endif
MAE_Ret _ALARMSRV_GetAlarmListFromConfig(MMI_ALARMSRV *pThis, ALARM_RECORD_t alarmList[]);
MAE_Ret _ALARMSRV_SetAlarmListToConfig(MMI_ALARMSRV *pThis, ALARM_RECORD_t alarmList[]);
static void _ALARMSRV_SyncAlarmCfgToQueue(MMI_ALARMSRV *pThis);
static void _ALARMSRV_Release(MMI_ALARMSRV *pThis);

#endif /* __MMI_ALARMSRV_PRIV_H__ */
