/**
* @file mmi_vtccsrv_priv.h
*
* State Machine Service - VTCCSRV
* Generated by XFSM v1.0, CodeVer=v0.24
*
* Class Id: CLSID_VTCCSRV
*
*
* @version $Id: mmi_vtccsrv_priv.h 38890 2009-08-29 16:22:38Z zinc.chen $
*/
#ifndef __MMI_VTCCSRV_PRIV_H__
#define __MMI_VTCCSRV_PRIV_H__

#include "mmi_mae_common_def.h"
#include "mmi_mae_sm_defs.h"
#include "mmi_vtccsrv.h"
#include "mmi_vtccsrv_sm.h"
#include "mmi_mae_datamodel.h"
#include "mmi_mae_notifier.h"
#include "mmi_cfgsrv.h"
#include "mmi_simsrv.h"
#include "mmi_vtccsrv_ctmgr.h"
#include "mmi_btsrv.h"
#include "mmi_common_util.h"
#include "mmi_mae_clock.h"
#include "mmi_mae_clock_types.h"

#ifdef __VT_3G324M__

/**
 * Application structure
 */
typedef struct MMI_VTCCSRV_TAG
{
    DECLARE_FUNCTBL(IVTCCSRV);  // function table pointer
    u32 refCnt;     // reference count
    SM_Mao_t app;       // StateMachine Application data
    SM_ModeId_t _lastActiveMode[cVTCCSRV_ModeNumbers];    // Last child, current active child
    SM_ModeId_t _currentMode[1];
    /* Add custom fields below */
    //IApplet* pVTCCApp;

    MAE_Notifier_t *pNotifier;                   //Notify the APP/Service who are interested to VTCC event
    IDataModel *pCallTableDModel; //DataModel is used to manage Call Table
    CallTable_t *pCallTableCache;   //Hold the call table pointer (This pointer won't be change in VTCC Service life cycle)
    ICFGSrv *pCfgSrv;                   // Hold the instance of Setting
    ISIMSRV *pSimSrv;                   // Hold the instance of SIM
#ifdef __BLUETOOTH_MMI__
    IBTSRV *pBTSrv;                     // to notify BT status of vtcc
#endif
    IClock *pIClock;                // Hold the instance of IClock
    ClockListener_t ClockModelListener;     // IClock model listener
    boolean bCountMinTick;          // flag for count minute tick

    boolean bTerminate;
    boolean bMisscallExisted;
    boolean bSendByHangUpCnf;           // flag to keep CLCC sending state.

    CallTableEntry_t *pEntry;           //Temp storage to keep information before write to call table
    COMMON_TotalEccList_t *pECCTbl;     // SIM ECC and Customized Emergency call table

    u8 u8DualID;
    u8 u8MakeCallIndex;     //Store entry index for make call (update CallRefID if receive MAE_EVT_VTCC_CALLREF_IND)
    u8 u8MakeCallID;        //Store call id for outgoing call
    u8 u8IncomingCallID;        //Store call id for incoming call or waiting call
    u8 u8ChldOperCallID;        //Store call id for chld operation (Ex. Release specific call by Public MMI)
    u8 u8CheckBlackListRetFlag; //A flag to distinguish the return mode for CheckBlacklist mode (1A/ 1H/ 1A1H)
    u32 u32SessionStartTime;
    u32 u32InCallDuration;
    u32 u32HangupTimeTick;
    u32 u32MinuteTick;
    boolean bHangUp;
    MMI_VtCcCall_Chld_Type_e u8ChldOperFlag;
    boolean bWaitAcceptCnfFrom1A1H1Waiting;  /*The case is:
                                               User chose to "Replace hold call", so the hold call is release first at 1A1H/waiting mode, and accept the waiting call.
                                               Before the Accept confirm is back, state machine will stay in 1A/waiting mode. VTCC_SRV will Post different event to VTCC_APP by this flag*/
    u8 u8RelHeldCallCount;  // To avoid infinite loop
    boolean bAutoRedial;        // Keep the Auto redial status for VTCCAPP.
    boolean bPreMOCall;     // Keep the PreMO call status(Check dual mode or IP call)

    MmiMakeCallReq_t *pMake2ndCall; // Cache data for Make2ndCall from 1A ( VTCCSRV will hold Active call first, then MO call)
    boolean bAccepted;
    boolean bWaitHangupCnf;
    boolean bHangupCallLater;       // Handle user accept call and hangup call at the same time.
    boolean bCMDisconnectReq; // To indicate if VT CM disconnect req
    VtCc3G324MCallState_e eCallState;
} MMI_VTCCSRV;

MAE_Ret mmi_VTCCSRV_Notify(MMI_VTCCSRV *pThis, u32 nMask, MAEEvent_t nEvt, u32 nLParam, u32 nDParam);

#endif //__VT_3G324M__
#endif /* __MMI_VTCCSRV_PRIV_H__ */
