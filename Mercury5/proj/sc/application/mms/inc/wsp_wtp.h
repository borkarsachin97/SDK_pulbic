
#ifndef __WSP_WTP_H__
#define __WSP_WTP_H__

#include <ncc_types.h>
#include <wsp_timertid.h>
#include <wsp_method.h>

#define WTP_MAX_AEC         12
#define WTP_MAX_VERICATION 4

#define WTP_PROVIDER 0
#define WTP_USER 1

#define WTP_CLASS_0 0
#define WTP_CLASS_1 1
#define WTP_CLASS_2 2

/*event definition*/
#define CRcvInvoke  0
#define CRcvResult  1
#define CRcvAck     2
#define CRcvAbort   3
#define CRcvError   4
#define CInvokeReq  5
#define CInvokeRes  6
#define CResultReq  7
#define CResultRes  8
#define CAbortReq   9
#define CTimerToR   10
#define CTimerToW   11
#define CTimerToA   12

#define USER_ACK    1
#define RE_TRANSMIT 6
#define STATE_WAIT_TIMEOUT 4

#define INVLAID_TID 2
#define NORESPONSE  8
#define PROTOERR    1
#define WTPVERSIONZERO 6

/*TPI(Transport Information Items)*/
#define WTP_TPI_ERROR               0x00
#define WTP_TPI_INFO                0x01
#define WTP_TPI_OPTION              0x02
#define WTP_TPI_PSN                 0x03 /*PACKET SEQUENCE NUMBER*/
#define WTP_TPI_SDU_BOUNDARY        0x04
#define WTP_TPI_FRAME_BOUNDARY  0x05

/*TPI OPTION*/
#define WTP_TPI_OPTION_MAXIMUM_RECEIVE_UNIT         0x01
#define WTP_TPI_OPTION_TOTAL_MESSAGE_SIZE           0x02
#define WTP_TPI_OPTION_DELAY_TRANSMISSION_TIMER 0x03
#define WTP_TPI_OPTION_MAXIMUM_GROUP                0x04
#define WTP_TPI_OPTION_CURRENT_TID                  0x05
#define WTP_TPI_OPTION_NO_CACHED_TID                    0x06
#define WTP_TPI_OPTION_NUMGROUPS                        0x07

/*PDU TYPE definition*/
#define WTP_PDU_CONCATENATED    0x00
#define WTP_PDU_INVOKE          0x01
#define WTP_PDU_RESULT          0x02
#define WTP_PDU_ACK             0x03
#define WTP_PDU_ABORT       0x04
#define WTP_PDU_SEG_INVOKE  0x05
#define WTP_PDU_SEG_RESULT  0x06
#define WTP_PDU_NACK            0x07

/*PDU Structure definition*/
#define WTP_CON                 0x07
#define WTP_PDU_TYPE            0x03
#define WTP_GTR                 0x02
#define WTP_TTR                 0x01
#define WTP_RID                 0x00

#define WTP_VERSION         0x06
#define WTP_TID_NEW         0x05
#define WTP_UP                  0x04
#define WTP_TCL                 0x00

#define WTP_PDU_TYPE_MASK       0x0f
#define WTP_TCL_MASK            0x03
#define WTP_VERSION_MASK        0x03
#define WTP_UP_MASK         0x01
#define WTP_TID_NEW_MASK        0x01

#ifdef __cplusplus
extern  "C" {
#endif

enum WTP_StateVal{
    IniNull,
    IniResultWait,
    IniResultResWait,
    IniWaitTimeout,
    ResListen,
    ResTidWait,
    ResInvokeRespWait,
    ResResultWait,
    ResResultResWait,
    ResWaitTimeout
};

extern  const struct T_WAP_EventArray gpWAP_Event[];

/**
 * Call this function to do some initialization of WTP.
 *
 *   \param  hc  a wsp instance handle.
 *   \return
 */
 void fnWTP_Init(void *hc);

/**
 * Call this function to do some cleaning for WTP .
 *
 *   \param  hc  a wsp instance handle.
 *   \return
 */
 void fnWTP_Clean(void *hc);

/**
 * The send function of WTP layer.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  event_num the event number;
 *   \param   ctl a pointer to MCB;
 *   \param   msg a pointer to WAP message.
 *   \return
 */
 void fnWTP_Send(void *hc,uint8_t event_num,T_WAP_MCB *ctrl,T_WAP_MSG_P msg);

/**
 * The function to receive in the  WTP layer .
 *
 *   \param  hc  a wsp instance handle.
 *   \param   msg where to store received data;
 *   \return
 */
 void fnWTP_Recv(void *hc,T_WAP_MSG_P msg);

/**
 * To send Acknowledgement PDU packet .
 *
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple to communicate;
 *   \param  tid_ve In the direction from the responder to the
 *                            initiator the Tve (TID Verify) means:"Do you
 *                            have an outstanding transaction with this TID?".
 *                            In the opposite direction the Tok (TID OK) flag
 *                            means: "I have an outstanding transaction with
 *                            this TID!"
 *   \param   rid Enables the receiver to differentiate between
 *                           packets duplicated by the network and packets
 *                           re-transmitted by the sender. In the original
 *                           message the RID is clear. When the message
 *                           gets re-transmitted the RID is set.
 *   \param  tid Transaction Identifier.
 *   \return
 */
 void fnWTP_SendAck(void *hc,T_WAP_AddrTuple *addr,int8_t tid_ve,int8_t rid,uint16_t tid);

/**
 * Send an Abort packet.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple to communicate;
 *   \param   abort_type  abort type;Set it to WTP_PROVIDER
 *                           when the abort was generated by the WTP
 *                           provider itself.Set it to WTP_USER when the
 *                           abort was generated by the WTP user.
 *   \param  tid The TID field is used to associate requests
 *                           with replies in the connectionless session
 *                           service. The presence of the TID isconditional.
 *                           It MUST be included in the connectionless WSP
 *                           PDUs, and MUST NOT be present in the
 *                           connectionmode PDUs. In connectionless WSP,
 *                           the TID is passed to and from the session user
 *                           as the"Transaction Id"or"Push Id"parameters of
 *                           the session primitives;
 *   \param  abort_reason the reason to abort.See Table 19 of
 *                           WTP specification 1.2 for more detail.
 *   \return
 */
 void fnWTP_SendAbort(void *hc,T_WAP_AddrTuple *addr,int8_t abort_type,uint16_t tid,uint8_t abort_reason);

/**
 * Send result PDU packet.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple to communicate;
 *   \param  rid Enables the receiver to differentiate between
 *                           packets duplicated by the network and packets
 *                           re-transmitted by the sender. In the original
 *                           message the RID is clear. When the message
 *                           gets re-transmitted the RID is set.
 *   \param  tid Transaction Identifier.
 *   \param  buf  data to send.
 *
 *   \return
 */
 void fnWTP_SendResult(void *hc,T_WAP_AddrTuple *addr,int8_t rid,T_WAP_MSG_P buf,uint16_t tid);

/**
 * Send a invoke PDU package .
 *
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple to communicate;
 *   \param   rid Enables the receiver to differentiate between packets duplicated by
 *                            the network and packets re-transmitted by the sender.
 *                            In the original message the RID is clear. When the message
 *                           gets re-transmitted the RID is set.
 *   \param  m a pointer to MCB.
 *   \param  buf  data to send.
 *   \return
 *
 */
 void fnWTP_SendInvoke(void *hc,T_WAP_AddrTuple *addr,int8_t rid,T_WAP_MCB *m,T_WAP_MSG_P buf);

/**
 * Send a Segmented Invoke PDU (optional) packet.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple to communicate;
 *   \param   rid Enables the receiver to differentiate between
 *                           packets duplicated by the network and packets
 *                           re-transmitted by the sender. In the original
 *                           message the RID is clear. When the message
 *                           gets re-transmitted the RID is set.
 *   \param  m  data to send.
 *   \return
 */
 void fnWTP_SendSegInvoke(void *hc,T_WAP_AddrTuple *addr, int8_t rid,T_WAP_MCB *m);

/**
 * The handle of the event: RcvInvoke  in the state of WTP WTP Responder LISTEN.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg the message buffer.
 *       \return
 */
 void fnWTP_RcvInvoke_ResListen(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvInvoke  in the state of WTP Responder TIDOK WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  ctl the MCB;
 *   \param  msg the message buffer.
 *   \return
 */
 void fnWTP_RcvInvoke_ResTidWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvInvoke  in the state of WTP Responder RESULT WAIT (class 2 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvInvoke_ResResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvInvoke  in the state of WTP Responder WAIT TIMEOUT (class 1 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *
 *   \return
 *
 */
 void fnWTP_RcvInvoke_ResWaitTimeout(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAck  in the state of WTP Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *
 *   \return
 */
 void fnWTP_RcvAck_IniResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAck  in the state of WTP Responder TIDOK WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvAck_ResTidWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAck  in the state of WTP Responder RESULT RESP WAIT (class 2 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvAck_ResResultResWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAck  in the state of WTP Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvNAck_IniResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAbort  in the side of WTP Initiator.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return none ;
 */
 void fnWTP_RcvAbort(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvAbort  in the state of WTP Responder TIDOK WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvAbort_ResTidWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvInvoke  in the state of WTP Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvResult_IniResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvSegResult  in the state of WTP Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvSegResult_IniResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvInvoke  in the state of WTP Initiator WAIT TIMEOUT (class 2 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvResult_IniWaitTimeout(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvError  in the other states(except WTP Responder
 *             LISTEN and WTP Responder TIDOK WAIT)of WTP Responder.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvError_ResOther(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvError  in the side of WTP Initiator.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  ctl the MCB;
 *   \param  msg the message buffer.
 *   \return
 */
 void fnWTP_RcvError_Init(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvError  in the state of WTP Responder LISTEN.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_RcvError_ResListen(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: RcvError  in the state of WTP Responder TIDOK WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 *
 */
 void fnWTP_RcvError_ResTidWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: TR-Invoke.req  in the state of WTP Initiator NULL.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_InvokeReq_IniNull(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: TR-Invoke.res  in the state of WTP
 *           Responder INVOKE RESP WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_InvokeRes_ResInvokeRespWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: ResultReq .
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_ResultReq(void *hc,void *ctl,void *msg);

/**
 * The handle of the event: ResultRes .
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_ResultRes(void *hc,void *ctl,void *msg);

/**
 * To Abort transaction and Send Abort PDU (USER).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB;
 *   \param   msg the message buffer.
 *   \return
 */
 void fnWTP_AbortReq(void *hc,void *ctl,void *msg);

/**
 * The handle of the event  TimerToR at the state of Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *   \return
 */
 void fnWTP_TimerToR_IniResultWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event  TimerToR at the state of Responder RESULT RESP WAIT (class 2 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *   \return
 */
 void fnWTP_TimerToR_ResResultResWait(void *hc,void *ctl,void *msg);

/**
 * This sets a bound for the amount of time to wait before
 * state information about a transaction is released..
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *   \return
 */
 void fnWTP_TimerToW(void *hc,void *ctl,void *msg);

/**
 * The handle of the event  TimerToR at the state of Initiator RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *   \return
 */
 void fnWTP_TimerToA_IniResultResWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event  TimerToA at the state Responder RESULT RESP WAIT (class 2 only).
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *   \return
 */
 void fnWTP_TimerToA_ResInvokeRespWait(void *hc,void *ctl,void *msg);

/**
 * The handle of the event  TimerToA  at the state of Responder RESULT WAIT.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   ctl the MCB.
 *   \param   msg unused parameter.
 *
 *   \return
 *
 */
 void fnWTP_TimerToA_ResResultWait(void *hc,void *ctl,void *msg);

/**
 * Get next TID .
 *
 *   \param  hc  a wsp instance handle.
 *   \return Return the next TID ;
 */
 uint16_t fnWTP_NextTid(void *hc);

/**
 * Call this function to process timers event.
 *
 *   \param  hc  a wsp instance handle.
 *   \return
 */
 void fnWTP_ProcessTimerEvent(void *hc);

/**
 * This fucntion check if a MCB is used. if not ,it will ifree the message buffer.
 *
 *   \param  m the message control block to check;
 *   \param  packet the message to deal with.
 *   \return Return TRUE if the checked MCB is used;elseand return FALSE.
 */
 int32_t CanContinue(T_WAP_MCB *m,T_WAP_MSG_P packet);

/**
 * Use this function to detect if  the packets have been lost.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  pRcv the message packet received;
 *   \param  Result the received the Segmented Packet Result packet.
 *   \return If no packet lost ,return 0;else return 1.
 */
 uint8_t fnWTP_IsMissingPacket(T_WAP_MSG_P pRcv,T_WAP_Sar_SegPacketResult *Result);

/**
 * Send group ack .
 *   \param  hc  a wsp instance handle.
 *   \param  addr the address tuple for communication;
 *   \param  tid_ve In the direction from the responder to the initiator the Tve (TID Verify)
 *                           means:"Do you have an outstanding transaction with this TID?".
 *                            In the opposite direction the Tok (TID OK) flag means: "I have an
 *                            outstanding transaction with this TID!"
 *   \param  rid Enables the receiver to differentiate between
 *                           packets duplicated by the network and packets
 *                           re-transmitted by the sender. In the original
 *                           message the RID is clear. When the message
 *                           gets re-transmitted the RID is set.
 *   \param  tid Transaction Identifier.
 *   \param  group_num   the group number to ack.
 *   \return
 */
 void fnWTP_SendGroupAck(void *hc,T_WAP_AddrTuple *addr,int8_t tid_ve,int8_t rid,uint16_t tid,uint8_t group_num);

/**
 * Call this function to send Negative Acknowledgement PDU packet.
 *
 *   \param  hc  a wsp instance handle.
 *   \param   rid Enables the receiver to differentiate between packets duplicated by
 *    the network and packets re-transmitted by the sender. In the original message
 *    the RID is clear. When the message gets re-transmitted the RID is set;
 *   \param  m the message to send.
 *   \return
 */
 void fnWTP_SendNegativeAck(void *hc,int8_t rid,T_WAP_MCB *m);

/**
 * When the receiver has received a complete packet group and the last packet has
 *    the TTR flag set, it SHOULD be able to re-assemble the complete message.
 *
 *   \param  Message the MCB.
 *   \param  Result the segment packet result.
 *   \return
 */
 void fnWTP_ReAssembGroupPacket(T_WAP_MSG_P Message,T_WAP_Sar_SegPacketResult *Result);

/**
 * Set pdu length for sending Segmented Invoke.
 *
 *   \param  hc  a wsp instance handle.
 *   \param  len the segment PDU length(>300 and <1300)
 *   \return If success,return TRUE.else return FALSE.
 */
 int32_t  fnWap_SetSegPduLen(void *hc,int16_t  len);


#ifdef __cplusplus
}
#endif

#endif /* __WSP_WTP_H__ */

