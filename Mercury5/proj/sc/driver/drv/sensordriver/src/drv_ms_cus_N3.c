////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2006-2009 MStar Semiconductor, Inc.
// All rights reserved.
//
// Unless otherwise stipulated in writing, any and all information contained
// herein regardless in any format shall remain the sole proprietary of
// MStar Semiconductor Inc. and be kept in strict confidence
// (ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½MStar Confidential Informationï¿½ï¿½ï¿½ï¿½ï¿½ï¿½) by the recipient.
// Any unauthorized act including without limitation unauthorized disclosure,
// copying, use, reproduction, sale, distribution, modification, disassembling,
// reverse engineering and compiling of the contents of MStar Confidential
// Information is unlawful and strictly prohibited. MStar hereby reserves the
// rights to any and all damages, losses, costs and expenses resulting therefrom.
//
////////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
extern "C"
{
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include "drv_SensorIF_pub.h"
#include "drv_ms_cus_sensor.h"
#include "drv_i2c_common.h"

#ifdef __cplusplus
}
#endif

#include <sensor_log.h>

#if defined(__RTK_OS__)
#include "cam_os_wrapper.h"
#if defined(__GNUC__)
#include "vm_types.ht"
#endif
#include "libcamera.h"
#include "AIT_Init.h"
#include "Config_SDK.h" //By project.
#else //#if defined(__RTK_OS__)

#include "isp_config.h"
#if (SENSOR0 == N3)
#define BIND_SENSOR_N3 (1)
#endif
#endif //#if defined(__RTK_OS__)

#if defined(BIND_SENSOR_N3) && (BIND_SENSOR_N3 == 1)
#define N3_SUPPORT_720P     1
#define N3_SUPPORT_1080P    0
#define SENSOR_PAD_GROUP_SET CUS_SENSOR_PAD_GROUP_B
#define SENSOR_CHANNEL_NUM (1)  // sync with RAWS_COMP_IDX
#define SENSOR_CHANNEL_MODE CUS_SENSOR_CHANNEL_MODE_RAW_STORE

//============================================
//BT656 config begin.
#define SENSOR_BT656_CH_TOTAL_NUM (1)
#define SENSOR_BT656_CH_DET_ENABLE CUS_SENSOR_FUNC_DISABLE
#define SENSOR_BT656_CH_DET_SEL CUS_VIF_BT656_EAV_DETECT
#define SENSOR_BT656_BIT_SWAP CUS_SENSOR_FUNC_DISABLE
#define SENSOR_BT656_8BIT_MODE CUS_SENSOR_FUNC_ENABLE
#define SENSOR_BT656_VSYNC_DELAY CUS_VIF_BT656_VSYNC_DELAY_AUTO
#define SENSOR_HSYCN_INVERT CUS_SENSOR_FUNC_DISABLE
#define SENSOR_VSYCN_INVERT CUS_SENSOR_FUNC_DISABLE
#define SENSOR_CLAMP_ENABLE CUS_SENSOR_FUNC_DISABLE
//BT656 config end.
//============================================

#define SENSOR_ISP_TYPE     ISP_EXT                   //ISP_EXT, ISP_SOC
#define F_number  22                                  // CFG, demo module
//#define SENSOR_DATAFMT      CUS_DATAFMT_BAYER        //CUS_DATAFMT_YUV, CUS_DATAFMT_BAYER
#define SENSOR_IFBUS_TYPE   CUS_SENIF_BUS_BT656      //CFG //CUS_SENIF_BUS_PARL, CUS_SENIF_BUS_MIPI
//#define SENSOR_MIPI_DELAY   0x1212                  //CFG
#define SENSOR_DATAPREC     CUS_DATAPRECISION_16    //CUS_DATAPRECISION_8, CUS_DATAPRECISION_10
#define SENSOR_DATAMODE     CUS_SEN_10TO12_9000     //CFG
#define SENSOR_BAYERID      CUS_BAYER_RG            //CFG //CUS_BAYER_GB, CUS_BAYER_GR, CUS_BAYER_BG, CUS_BAYER_RG
#define SENSOR_ORIT         CUS_ORIT_M0F0           //CUS_ORIT_M0F0, CUS_ORIT_M1F0, CUS_ORIT_M0F1, CUS_ORIT_M1F1,
//#define SENSOR_YCORDER      CUS_SEN_YCODR_YC       //CUS_SEN_YCODR_YC, CUS_SEN_YCODR_CY
#define lane_number 2
#define vc0_hs_mode 3   //0: packet header edge  1: line end edge 2: line start edge 3: packet footer edge
#define long_packet_type_enable 0x00 //UD1~UD8 (user define)
#define SENSOR_MAX_GAIN     (64 * 1024)                  // max sensor again, a-gain * conversion-gain*d-gain
#define SENSOR_MIN_GAIN      (1 * 1024)
#define SENSOR_GAIN_DELAY_FRAME_COUNT         (2)
#define SENSOR_SHUTTER_DELAY_FRAME_COUNT      (2)

#define Preview_MCLK_SPEED  CUS_CMU_CLK_27MHZ       //CFG //CUS_CMU_CLK_12M, CUS_CMU_CLK_16M, CUS_CMU_CLK_24M, CUS_CMU_CLK_27M
#define Preview_line_period 30000                  ////HTS/PCLK=4455 pixels/148.5MHZ=30usec
#define Prv_Max_line_number 1080                    //maximum exposure line munber of sensor when preview
#define vts_30fps 1125//1346,1616                      //for 29.1fps
#if (N3_SUPPORT_720P == 1)
#define Preview_WIDTH       1280                    //resolution Width when preview
#define Preview_HEIGHT      720                    //resolution Height when preview
#elif (N3_SUPPORT_1080P == 1)
#define Preview_WIDTH       1920                    //resolution Width when preview
#define Preview_HEIGHT      1080                    //resolution Height when preview
#else
#define Preview_WIDTH       1280                   //resolution Width when preview
#define Preview_HEIGHT      720                    //resolution Height when preview
#endif
#define Preview_MAX_FPS     25                    //fastest preview FPS
#define Preview_MIN_FPS     8                      //slowest preview FPS
#define Preview_CROP_START_X     1                      //CROP_START_X
#define Preview_CROP_START_Y     1                      //CROP_START_Y

//#define Capture_MCLK_SPEED  CUS_CMU_CLK_16M     //CUS_CMU_CLK_12M, CUS_CMU_CLK_16M, CUS_CMU_CLK_24M, CUS_CMU_CLK_27M
#define Cap_Max_line_number 720                   //maximum exposure line munber of sensor when capture

//#define SENSOR_I2C_LEGACY  CUS_I2C_NORMAL_MODE     //usally set CUS_I2C_NORMAL_MODE,  if use old OVT I2C protocol=> set CUS_I2C_LEGACY_MODE
//#define SENSOR_I2C_FMT     CUS_I2C_FMT_A16D8        //CUS_I2C_FMT_A8D8, CUS_I2C_FMT_A8D16, CUS_I2C_FMT_A16D8, CUS_I2C_FMT_A16D16
#define SENSOR_I2C_ADDR     0x60//0x2d                  //I2C slave address
//#define SENSOR_I2C_ADDR       0x58//0x2c                  //I2C slave address YLK

#define SENSOR_I2C_SPEED    I2C_SLOWSPEED_MODE_200KHZ   //200KHz
#define SENSOR_I2C_CHANNEL  1                           //I2C Channel
#define SENSOR_I2C_PAD_MODE 2                           //Pad/Mode Number

#define SENSOR_I2C_LEGACY  I2C_NORMAL_MODE     //usally set CUS_I2C_NORMAL_MODE,  if use old OVT I2C protocol=> set CUS_I2C_LEGACY_MODE
#define SENSOR_I2C_FMT     I2C_FMT_A8D8        //CUS_I2C_FMT_A8D8, CUS_I2C_FMT_A8D16, CUS_I2C_FMT_A16D8, CUS_I2C_FMT_A16D16

#define SENSOR_PWDN_POL     CUS_CLK_POL_POS//CUS_CLK_POL_NEG        // if PWDN pin High can makes sensor in power down, set CUS_CLK_POL_POS
#define SENSOR_RST_POL      CUS_CLK_POL_NEG        // if RESET pin High can makes sensor in reset state, set CUS_CLK_POL_NEG

// VSYNC/HSYNC POL can be found in data sheet timing diagram,
// Notice: the initial setting may contain VSYNC/HSYNC POL inverse settings so that condition is different.

#define SENSOR_VSYNC_POL    CUS_CLK_POL_POS        // if VSYNC pin High and data bus have data, set CUS_CLK_POL_POS
#define SENSOR_HSYNC_POL    CUS_CLK_POL_POS        // if HSYNC pin High and data bus have data, set CUS_CLK_POL_POS
#define SENSOR_PCLK_POL     CUS_CLK_POL_POS        // depend on sensor setting, sometimes need to try CUS_CLK_POL_POS or CUS_CLK_POL_NEG
//static int  drv_Fnumber = 22;

static int pCus_SetAEGain(ms_cus_sensor *handle, u32 gain);
static int pCus_SetAEUSecs(ms_cus_sensor *handle, u32 us);
int n3_cus_camsensor_release_handle(ms_cus_sensor *handle);

static CUS_CAMSENSOR_CAP sensor_cap = {
    .length = sizeof(CUS_CAMSENSOR_CAP),
    .version = 0x0001,
};

typedef struct {
    struct {
        u16 pre_div0;
        u16 div124;
        u16 div_cnt7b;
        u16 sdiv0;
        u16 mipi_div0;
        u16 r_divp;
        u16 sdiv1;
        u16 r_seld5;
        u16 r_sclk_dac;
        u16 sys_sel;
        u16 pdac_sel;
        u16 adac_sel;
        u16 pre_div_sp;
        u16 r_div_sp;
        u16 div_cnt5b;
        u16 sdiv_sp;
        u16 div12_sp;
        u16 mipi_lane_sel;
        u16 div_dac;
    } clk_tree;
    struct {
        bool bVideoMode;
        u16 res_idx;
        CUS_CAMSENSOR_ORIT  orit;
    } res;

    struct {
        float sclk;
        u32 hts;
        u32 vts;
        u32 ho;
        u32 xinc;
        u32 line_freq;
        u32 us_per_line;
        u32 final_us;
        u32 final_gain;
        u32 back_pv_us;
        u32 fps;
    } expo;

    int sen_init;
    int still_min_fps;
    int video_min_fps;
    bool reg_dirty; //sensor setting need to update through I2C
} n3_params;
// set sensor ID address and data,

static I2C_ARRAY Sensor_id_table[] =
{

};

static I2C_ARRAY Sensor_init_table[] =
{
    //n3 init
    {0xFF, 0x01},           // Bank 1
    {0x82, 0x14},           // -RESERVED- ?? Clk ?? //PLL_MODE_144MHz
    {0x83, 0x2C},           // -RESERVED- ??        //PLL_MODE_144MHz
    {0x3e, 0x10},           // -RESERVED- ??
    {0x80, 0x60},           // -RESERVED- ??
    {0x80, 0x61},           // -RESERVED- ??
   // {SENSOR_DELAY_REG, 40},//100
    {0x80, 0x40},           // -RESERVED- ??
    {0x81, 0x02},           // -RESERVED- ??
    {0x97, 0x00},           // DEC_RST4  DEC_RST3  DEC_RST2  DEC_RST1
   // {SENSOR_DELAY_REG, 10},
    {0x80, 0x60},
    {0x81, 0x00},
   // {SENSOR_DELAY_REG, 10},
    {0x97, 0x0F},
    {0x38, 0x18},           // AUD_SW_RST
    {0x38, 0x08},           // AUD_SW_RST
   // {SENSOR_DELAY_REG, 0},//
    {0xCA, 0xAE},           // VCLK_1_EN  VCLK_2_EN  VDO_1_EN (11 : ENABLE)  VDO_2_EN

    //720p30fps
    {0xFF,  0x00},          ////[BANK = 0]
    {0x00,  0x0},
    {0x01,  0x0},
    {0x02,  0x20},
    {0x03,  0x3},
    {0x04,  0x0},
    {0x05,  0x0},
    {0x06,  0x0},
    {0x07,  0x0},
//N3 init ch start
    {0x08,  0x60},
    {0x09,  0x60},
    {0x0A,  0x60},
    {0x0B,  0x60},

    {0x0C,  0xf8},//0x8,// 2017-12-27 ÁÁ¶È
    {0x0D,  0x8},
    {0x0E,  0x8},
    {0x0F,  0x8},

    {0x10,  0x90},//0x88,
    {0x11,  0x88},
    {0x12,  0x88},
    {0x13,  0x88},

    {0x14,  0xc0},//0x90, // 2017-12-27  ±¥ºÍ¶È
    {0x15,  0x90},
    {0x16,  0x90},
    {0x17,  0x90},

    {0x18,  0x0f},//0x00,//0x30
    {0x19,  0x00},//0x30
    {0x1A,  0x00},//0x30
    {0x1B,  0x00},//0x30

    {0x1C,  0xaf},
    {0x1D,  0xaf},
    {0x1E,  0xaf},
    {0x1F,  0xaf},
    {0x20,  0x2f},

    {0x21,  0x92},
    {0x22,  0x0a},
    {0x23,  0x41},
    {0x24,  0x2f},
    {0x25,  0x92},
    {0x26,  0x0a},
    {0x27,  0x43},
    {0x28,  0x2f},
    {0x29,  0x92},
    {0x2A,  0x0a},
    {0x2B,  0x43},
    {0x2C,  0x2f},
    {0x2D,  0x92},
    {0x2E,  0x0a},
    {0x2F,  0x43},

    {0x30,  0x18},
    {0x31,  0x18},
    {0x32,  0x18},
    {0x33,  0x18},

    {0x34,  0x4},
    {0x35,  0x4},
    {0x36,  0x4},
    {0x37,  0x4},
    {0x38,  0x0a},
    {0x39,  0x0a},
    {0x3A,  0x0a},
    {0x3B,  0x0a},

    {0x3C,  0x90},
    {0x3D,  0x90},
    {0x3E,  0x90},
    {0x3F,  0x90},

    {0x40,  0x00},//0xfd
    {0x41,  0x00},//0xfd
    {0x42,  0x00},//0xfd
    {0x43,  0x00},//0xfd

    {0x44,  0x40},//0x00,//0x20,//0x30, // 2017-12-27 // 2017-12-27-1 ugain // 2018-1-31
    {0x45,  0x30},
    {0x46,  0x30},
    {0x47,  0x30},

    {0x48,  0x30},//0x00,//0xd0,//0x30, // 2017-12-27 // 2017-12-27-1  vgain // 2018-1-31
    {0x49,  0x30},
    {0x4A,  0x30},
    {0x4B,  0x30},

    {0x4C,  0x08},//0x00,//0x30,//0x4,// 2017-12-27  // 2018-1-31
    {0x4D,  0x4},
    {0x4E,  0x4},
    {0x4F,  0x4},

    {0x50,  0x08},//0x00,//0xf8,//0x4, // 2017-12-27 // 2018-1-31
    {0x51,  0x4},
    {0x52,  0x4},
    {0x53,  0x4},

    {0x54,  0x01},//0xf1

    {0x55,  0x10},
    {0x56,  0x32},
    {0x57,  0x0},

    {0x58,  0x80},//0x90
    {0x59,  0x80},//0x90
    {0x5A,  0x80},//0x90
    {0x5B,  0x80},//0x90

    {0x5C,  0x9e},
    {0x5D,  0x9e},
    {0x5E,  0x9e},
    {0x5F,  0x9e},

    {0x60,  0x0},
    {0x61,  0x0},
    {0x62,  0x0},
    {0x63,  0x0},

    {0x64,  0xb1},//0xb2
    {0x65,  0xb1},//0xb2
    {0x66,  0xb1},//0xb2
    {0x67,  0xb1},//0xb2


    {0x68,  0x0},
    {0x69,  0x0},
    {0x6A,  0x0},
    {0x6B,  0x0},
    {0x6C,  0x0},
    {0x6D,  0x0},
    {0x6E,  0x0},
    {0x6F,  0x0},
    {0x70,  0x0},
    {0x71,  0x0},
    {0x72,  0x0},
    {0x73,  0x0},
    {0x74,  0x0},
    {0x75,  0x0},
    {0x76,  0x0},
    {0x77,  0x0},
    {0x78,  0xaa},//0xaa,//0x88, // 2018-1-3  0xaa ===>7²Ê
    {0x79,  0xaa},//0xaa,//0x88, // 2018-1-3
    {0x7A,  0x11},
    {0x7B,  0x11},
    {0x7C,  0xff},
    {0x7D,  0xff},
    {0x7E,  0xff},
    {0x7F,  0xff},
    {0x80,  0x0f},

    {0x81,  0x07},//0x06 - 30P
    {0x82,  0x07},//0x06 - 30P
    {0x83,  0x07},//0x06 - 30P
    {0x84,  0x07},//0x06 - 30P


    {0x85,  0x00},
    {0x86,  0x00},
    {0x87,  0x00},
    {0x88,  0x00},

    {0x89,  0x10},
    {0x8A,  0x10},
    {0x8B,  0x10},
    {0x8C,  0x10},

    {0x8D,  0x77},

    {0x8E,  0x0d},
    {0x8F,  0x0d},
    {0x90,  0x0d},
    {0x91,  0x0d},

    {0x92,  0x00},

    {0x93,  0x00},
    {0x94,  0x00},
    {0x95,  0x00},
    {0x96,  0x00},

    {0x97,  0x00},

    {0x98,  0x07},//0x04
    {0x99,  0x07},//0x04
    {0x9A,  0x07},//0x04
    {0x9B,  0x07},//0x04

    {0x9C,  0x00},
    {0x9D,  0x00},
    {0x9E,  0x00},
    {0x9F,  0x00},

    {0xA0,  0x00},
    {0xA1,  0x00},
    {0xA2,  0x00},
    {0xA3,  0x00},

    {0xA4,  0x00},//0x01
    {0xA5,  0x00},//0x01
    {0xA6,  0x00},//0x01
    {0xA7,  0x00},//0x01

    {0xA8,  0x11},
    {0xA9,  0x11},
    {0xAA,  0x0},
    {0xAB,  0x0},
    {0xAC,  0x0},
    {0xAD,  0x0},
    {0xAE,  0x0},
    {0xAF,  0x0},
    {0xB0,  0x0},
    {0xB1,  0x0},
    {0xB2,  0x0},
    {0xB3,  0x0},
    {0xB4,  0x0},
    {0xB5,  0x0},
    {0xB6,  0x0},
    {0xB7,  0x0},
    {0xB8,  0x0e},
    {0xB9,  0x0},
    {0xBA,  0x1},
    {0xBB,  0x1},
    {0xBC,  0xff},
    {0xBD,  0x0},
    {0xBE,  0x1},
    {0xBF,  0x0},
    {0xC0,  0x0f},
    {0xC1,  0x1},
    {0xC2,  0x0f},
    {0xC3,  0x0f},
    {0xC4,  0xff},
    {0xC5,  0x0},
    {0xC6,  0x3},
    {0xC7,  0x0f},
    {0xC8,  0x0},
    {0xC9,  0x0},
    {0xCA,  0x0},
    {0xCB,  0x0},
    {0xCC,  0xff},
    {0xCD,  0xff},
    {0xCE,  0xff},
    {0xCF,  0xff},
    {0xD0,  0x4},
    {0xD1,  0x0},
    {0xD2,  0x0},
    {0xD3,  0x0},
    {0xD4,  0xff},
    {0xD5,  0xff},
    {0xD6,  0xff},
    {0xD7,  0xff},
    {0xD8,  0x8},
    {0xD9,  0xff},
    {0xDA,  0xff},
    {0xDB,  0xff},
    {0xDC,  0xff},
    {0xDD,  0xff},
    {0xDE,  0xff},
    {0xDF,  0xff},
    {0xE0,  0x0},
    {0xE1,  0x0},
    {0xE2,  0x0},
    {0xE3,  0x0},
    {0xE4,  0x1b},
    {0xE5,  0x40},
    {0xE6,  0x40},
    {0xE7,  0x40},
    {0xE8,  0x42},
    {0xE9,  0x47},
    {0xEA,  0x47},
    {0xEB,  0x47},
    {0xEC,  0x1},
    {0xED,  0x0f},
    {0xEE,  0x0f},
    {0xEF,  0x55},
    {0xF0,  0xbf},
    {0xF1,  0xcd},
    {0xF2,  0x0},
    {0xF3,  0x0e},
    {0xF4,  0x86},
    {0xF5,  0x0},
    {0xF6,  0x0},
    {0xF7,  0x0},
    {0xF8,  0x0},
    {0xF9,  0x0},
    {0xFA,  0x0},
    {0xFB,  0x0},
    {0xFC,  0x0},
    {0xFD,  0x66},
    {0xFE,  0x66},
    {0xFF,  0x0},

    {0xFF,  0x01},  //[BANK = 1]
    {0x00,  0x2},
    {0x01,  0x0f},
    {0x02,  0x0f},
    {0x03,  0x0f},
    {0x04,  0x0f},
    {0x05,  0x0f},
    {0x06,  0x19},
    {0x07,  0x80},
    {0x08,  0x3},
    {0x09,  0x0},
    {0x0A,  0x10},
    {0x0B,  0x32},
    {0x0C,  0x54},
    {0x0D,  0x76},
    {0x0E,  0x0},
    {0x0F,  0x98},
    {0x10,  0xba},
    {0x11,  0xdc},
    {0x12,  0xfe},
    {0x13,  0x0},
    {0x14,  0x0},
    {0x15,  0x0},
    {0x16,  0x88},
    {0x17,  0x88},
    {0x18,  0x88},
    {0x19,  0x88},
    {0x1A,  0x88},
    {0x1B,  0x88},
    {0x1C,  0x88},
    {0x1D,  0x88},
    {0x1E,  0x88},
    {0x1F,  0x88},
    {0x20,  0x88},
    {0x21,  0x88},
    {0x22,  0x3},
    {0x23,  0x10},
    {0x24,  0x14},
    {0x25,  0x15},
    {0x26,  0x0},
    {0x27,  0x0},
    {0x28,  0x0},
    {0x29,  0x88},
    {0x2A,  0xff},
    {0x2B,  0x40},
    {0x2C,  0xaa},
    {0x2D,  0xaa},
    {0x2E,  0xaa},
    {0x2F,  0xaa},
    {0x30,  0xaa},
    {0x31,  0x82},
    {0x32,  0x0},
    {0x33,  0x0},
    {0x34,  0x0},
    {0x35,  0x8c},
    {0x36,  0xa0},
    {0x37,  0x0},
    {0x38,  0x9},
    {0x39,  0x1},
    {0x3A,  0x80},
    {0x3B,  0x30},
    {0x3C,  0x0},
    {0x3D,  0x0},
    {0x3E,  0x10},
    {0x3F,  0x0},
    {0x40,  0x0f},
    {0x41,  0x0f},
    {0x42,  0x0f},
    {0x43,  0x0f},
    {0x44,  0x11},
    {0x45,  0x0},
    {0x46,  0x0},
    {0x47,  0x0},
    {0x48,  0x0},
    {0x49,  0x0},
    {0x4A,  0x0},
    {0x4B,  0x0},
    {0x4C,  0x0},
    {0x4D,  0x0},
    {0x4E,  0x0},
    {0x4F,  0x0},
    {0x50,  0xff},
    {0x51,  0xff},
    {0x52,  0xff},
    {0x53,  0xff},
    {0x54,  0xff},
    {0x55,  0xff},
    {0x56,  0xff},
    {0x57,  0xff},
    {0x58,  0xff},
    {0x59,  0xff},
    {0x5A,  0xff},
    {0x5B,  0xff},
    {0x5C,  0xff},
    {0x5D,  0xff},
    {0x5E,  0xff},
    {0x5F,  0xff},
    {0x60,  0xff},
    {0x61,  0xff},
    {0x62,  0xff},
    {0x63,  0xff},
    {0x64,  0xff},
    {0x65,  0xff},
    {0x66,  0xff},
    {0x67,  0xff},
    {0x68,  0xff},
    {0x69,  0xff},
    {0x6A,  0xff},
    {0x6B,  0xff},
    {0x6C,  0xff},
    {0x6D,  0xff},
    {0x6E,  0xff},
    {0x6F,  0xff},
    {0x70,  0xff},
    {0x71,  0xff},
    {0x72,  0xff},
    {0x73,  0xff},
    {0x74,  0xff},
    {0x75,  0xff},
    {0x76,  0xff},
    {0x77,  0xff},
    {0x78,  0xff},
    {0x79,  0xff},
    {0x7A,  0xff},
    {0x7B,  0xff},
    {0x7C,  0xff},
    {0x7D,  0xff},
    {0x7E,  0xff},
    {0x7F,  0xff},
    {0x80,  0x60},
    {0x81,  0x0},

    {0x82,  0x14}, //PLL_MODE_144MHz
    {0x83,  0x2c}, //PLL_MODE_144MHz

    {0x84,  0x0},
    {0x85,  0x0},
    {0x86,  0x0},
    {0x87,  0x0},

    {0x88,  0x1},
    {0x89,  0x1},
    {0x8A,  0x1},
    {0x8B,  0x1},

    {0x8C,  0x40},
    {0x8D,  0x40},
    {0x8E,  0x40},
    {0x8F,  0x40},

    {0x90,  0x0},
    {0x91,  0x0},
    {0x92,  0x0},
    {0x93,  0x0},
    {0x94,  0x0},
    {0x95,  0x0},
    {0x96,  0x0},
    {0x97,  0x0f},
    {0x98,  0x0c},
    {0x99,  0x0},
    {0x9A,  0x0},
    {0x9B,  0x0},
    {0x9C,  0x0},
    {0x9D,  0x0},
    {0x9E,  0x0},
    {0x9F,  0x0},

    {0xA0,  0x1},
    {0xA1,  0x1},
    {0xA2,  0x1},
    {0xA3,  0x1},

    {0xA4,  0xff},
    {0xA5,  0xff},
    {0xA6,  0xff},
    {0xA7,  0xff},

    {0xA8,  0xa5}, // 0x55 - 30P    MPP_TST_SEL1 //0x55

    {0xA9,  0xff},
    {0xAA,  0xff},
    {0xAB,  0xff},
    {0xAC,  0xff},
    {0xAD,  0xff},
    {0xAE,  0xff},
    {0xAF,  0xff},
    {0xB0,  0x0},
    {0xB1,  0x0},
    {0xB2,  0x0},
    {0xB3,  0x0},
    {0xB4,  0x40},
    {0xB5,  0x30},
    {0xB6,  0x40},
    {0xB7,  0x30},
    {0xB8,  0x0},
    {0xB9,  0x0},
    {0xBA,  0x0},
    {0xBB,  0x0},

    {0xBC,  0x80},
    {0xBD,  0x80}, // 0x80 -30P

    {0xBE,  0xdd},
    {0xBF,  0x0d},
    {0xC0,  0x0},
    {0xC1,  0x0},
    {0xC2,  0x0},
    {0xC3,  0x0},
    {0xC4,  0x11},
    {0xC5,  0x11},
    {0xC6,  0x11},
    {0xC7,  0x11},
    {0xC8,  0x0},
    {0xC9,  0x0},
    {0xCA,  0x22},
    {0xCB,  0xff},
    {0xCC,  0x43},
    {0xCD,  0x50},//0x16 MH alter
    {0xCE,  0x43},
    {0xCF,  0x43}, // 1Port _ 1CH
    {0xD0,  0x0},
    {0xD1,  0x0},
    {0xD2,  0x0},
    {0xD3,  0xf0},
    {0xD4,  0x0},
    {0xD5,  0x1},
    {0xD6,  0x0},

    {0xD7,  0x0f},
    {0xD8,  0x0},
    {0xD9,  0x0},
    {0xDA,  0x0},
    {0xDB,  0x0},
    {0xDC,  0x0},
    {0xDD,  0x0},
    {0xDE,  0x0},
    {0xDF,  0x0},
    {0xE0,  0x0},
    {0xE1,  0x0},
    {0xE2,  0x0},
    {0xE3,  0x0},
    {0xE4,  0x0},
    {0xE5,  0x0},
    {0xE6,  0x0},
    {0xE7,  0x0},
    {0xE8,  0xff},
    {0xE9,  0xff},
    {0xEA,  0xff},
    {0xEB,  0xff},
    {0xEC,  0xff},
    {0xED,  0xff},
    {0xEE,  0xff},
    {0xEF,  0xff},
    {0xF0,  0xff},
    {0xF1,  0xff},
    {0xF2,  0xff},
    {0xF3,  0xff},
    {0xF4,  0xff},
    {0xF5,  0xff},
    {0xF6,  0xff},
    {0xF7,  0xff},
    {0xF8,  0xff},
    {0xF9,  0xff},
    {0xFA,  0xff},
    {0xFB,  0xff},
    {0xFC,  0xff},
    {0xFD,  0xff},
    {0xFE,  0xff},
    {0xFF,  0x1},

    {0xFF,  0x02},  //[BANK = 2]
    {0x00,  0x13},
    {0x02,  0x13},
    {0x04,  0x13},
    {0x06,  0x13},

    {0xFF,  0x03},  //[BANK = 3]
    {0x6B,  0x00},
    {0xEB,  0x00},

    {0xFF,  0x04},  //[BANK = 4]
    {0x6B,  0x00},
    {0xEB,  0x00},

    {0xFF,  0x05},  //[BANK = 5/]
    {0x00,  0xc0},
    {0x01,  0x0e},
    {0x02,  0x0c},
    {0x03,  0x1f},
    {0x04,  0x0},
    {0x05,  0x24},
    {0x06,  0x40},
    {0x07,  0x80},
    {0x08,  0x50},
    {0x09,  0x38},
    {0x0A,  0x0f},
    {0x0B,  0x0},
    {0x0C,  0x4},
    {0x0D,  0x10},
    {0x0E,  0x30},
    {0x0F,  0x0},
    {0x10,  0x6},
    {0x11,  0x6},
    {0x12,  0x0},
    {0x13,  0x80},
    {0x14,  0x37},
    {0x15,  0x80},
    {0x16,  0x49},
    {0x17,  0x37},
    {0x18,  0xef},
    {0x19,  0xdf},
    {0x1A,  0xdf},
    {0x1B,  0x8},
    {0x1C,  0x50},
    {0x1D,  0x0c},
    {0x1E,  0x1},
    {0x1F,  0x88},
    {0x20,  0x80},//0x84,
    {0x21,  0x20},
    {0x22,  0x23},
    {0x23,  0x0},
    {0x24,  0x2a},
    {0x25,  0xdc}, //0xdb s
    {0x26,  0xF0}, //0xf0
    {0x27,  0x57},
    {0x28,  0x90},
    {0x29,  0x70},
    {0x2A,  0x52},
    {0x2B,  0xA0},//0x78, // 2017-12-27 ±¥ºÍ¶È
    {0x2C,  0x08},//0x08,//0x0, // 2018-1-19
    {0x2D,  0x68},
    {0x2E,  0x0},
    {0x2F,  0x7},
    {0x30,  0x0},
    {0x31,  0x1},
    {0x32,  0x64},

    {0x33,  0x82}, // 0x82 - 30P
    {0x34,  0xec}, // 0xEC - 30P    - MPP_V_S
    {0x35,  0x19}, // 0x1B - 30P    - MPP_V_E  //0x1B
    {0x36,  0xd2}, // 0xCF - 30P    - MPP_V_DLY //0xcf

    {0x37,  0x00},
    {0x38,  0x0},
    {0x39,  0x2},
    {0x3A,  0x2},

    {0x3B,  0x04}, //0x04 -30P MPP_V_MODE

    {0x3C,  0x10}, //0x10 -30P MPP_OUT_SEL1
    {0x3D,  0x0},
    {0x3E,  0x0},
    {0x3F,  0x0},
    {0x40,  0xef}, //0xEF - 30P     MPP1 : H_BLK, MPP2 : V_BLK
    {0x41,  0x0},
    {0x42,  0x00}, // 0x00 -30P FULL_TST_SEL1
    {0x43,  0x0},
    {0x44,  0x0},
    {0x45,  0x0},
    {0x46,  0x0},
    {0x47,  0x4},
    {0x48,  0x0},
    {0x49,  0x44},
    {0x4A,  0xaa},
    {0x4B,  0x0},
    {0x4C,  0x0},
    {0x4D,  0x0},
    {0x4E,  0x0},
    {0x4F,  0x0},
    {0x50,  0x84},
    {0x51,  0xff},
    {0x52,  0xff},
    {0x53,  0x0},
    {0x54,  0x0},
    {0x55,  0x0},
    {0x56,  0x0},
    {0x57,  0x0},
    {0x58,  0x03},//0x0,
    {0x59,  0x0},
    {0x5A,  0x0},
    {0x5B,  0x0},
    {0x5C,  0x0},
    {0x5D,  0x0},
    {0x5E,  0x0},
    {0x5F,  0x30},
    {0x60,  0x53},
    {0x61,  0x53},
    {0x62,  0x20},
    {0x63,  0x0},
    {0x64,  0x2},
    {0x65,  0x0},
    {0x66,  0x0},
    {0x67,  0x0},
    {0x68,  0x0},
    {0x69,  0x0},
    {0x6A,  0x0},
    {0x6B,  0x0},
    {0x6C,  0x0},
    {0x6D,  0x0},
    {0x6E,  0x0},
    {0x6F,  0x0},
    {0x70,  0xc0},
    {0x71,  0x1},
    {0x72,  0x6},
    {0x73,  0x6},
    {0x74,  0x11},
    {0x75,  0x0},
    {0x76,  0x1},
    {0x77,  0x81},
    {0x78,  0x1},
    {0x79,  0x1},
    {0x7A,  0x1},
    {0x7B,  0x81},
    {0x7C,  0x11},
    {0x7D,  0x80},
    {0x7E,  0x0},
    {0x7F,  0x0},
    {0x80,  0x0},
    {0x81,  0x0},
    {0x82,  0x0},
    {0x83,  0x0},
    {0x84,  0x0},
    {0x85,  0x0},
    {0x86,  0x0},
    {0x87,  0x0},
    {0x88,  0x0},
    {0x89,  0x0},
    {0x8A,  0x0},
    {0x8B,  0x0},
    {0x8C,  0x0},
    {0x8D,  0x0},
    {0x8E,  0x0},
    {0x8F,  0x0},
    {0x90,  0x1},
    {0x91,  0x0},
    {0x92,  0x0},
    {0x93,  0x0},
    {0x94,  0x0},
    {0x95,  0x0},
    {0x96,  0x0},
    {0x97,  0x0},
    {0x98,  0x48},
    {0x99,  0x84},
    {0x9A,  0x0},
    {0x9B,  0x80},
    {0x9C,  0x00}, // 0x00 -30P MPP_H_START
    {0x9D,  0xc1}, // 0xbb
    {0x9E,  0x0a}, // 0x0A - 30P    MPP_H_END
    {0x9F,  0xc0}, // 0xba
    {0xA0,  0x10},
    {0xA1,  0x30},
    {0xA2,  0x0c},
    {0xA3,  0x50},
    {0xA4,  0x10},
    {0xA5,  0x34},
    {0xA6,  0x70},
    {0xA7,  0x5c},
    {0xA8,  0x20},
    {0xA9,  0x20},
    {0xAA,  0x30},
    {0xAB,  0x40},
    {0xAC,  0x20},
    {0xAD,  0x20},
    {0xAE,  0x14},
    {0xAF,  0xa0},
    {0xB0,  0x40},
    {0xB1,  0x50},
    {0xB2,  0x0e},
    {0xB3,  0x0},
    {0xB4,  0x0},
    {0xB5,  0x80},
    {0xB6,  0x0},
    {0xB7,  0x0},
    {0xB8,  0x38},
    {0xB9,  0xb2},
    {0xBA,  0x5},
    {0xBB,  0x0},
    {0xBC,  0xa0},
    {0xBD,  0x0},
    {0xBE,  0x0},
    {0xBF,  0x0},
    {0xC0,  0x16},
    {0xC1,  0x13},
    {0xC2,  0x0},
    {0xC3,  0x0},
    {0xC4,  0x1},
    {0xC5,  0x4},
    {0xC6,  0x0},
    {0xC7,  0x55},
    {0xC8,  0x4},
    {0xC9,  0x0},
    {0xCA,  0x0},
    {0xCB,  0x0},
    {0xCC,  0x0},
    {0xCD,  0x0},
    {0xCE,  0x0},
    {0xCF,  0x0},
    {0xD0,  0x0},
    {0xD1,  0x0},
    {0xD2,  0x0},
    {0xD3,  0x0},
    {0xD4,  0x0},
    {0xD5,  0x0},
    {0xD6,  0x0},
    {0xD7,  0x0},
    {0xD8,  0x0c},
    {0xD9,  0x0e},
    {0xDA,  0x12},
    {0xDB,  0x14},
    {0xDC,  0x1c},
    {0xDD,  0x2c},
    {0xDE,  0x34},
    {0xDF,  0x0},
    {0xE0,  0x0},
    {0xE1,  0x0},
    {0xE2,  0x0},
    {0xE3,  0x44},
    {0xE4,  0x0},
    {0xE5,  0x0},
    {0xE6,  0x0},
    {0xE7,  0x0},
    {0xE8,  0x1},
    {0xE9,  0xbb},
    {0xEA,  0x1},
    {0xEB,  0xbb},
    {0xEC,  0x40},
    {0xED,  0x40},
    {0xEE,  0x2},
    {0xEF,  0xf5},
    {0xF0,  0x20},
    {0xF1,  0xff},
    {0xF2,  0xb0},
    {0xF3,  0x4},
    {0xF4,  0xf6},
    {0xF5,  0x2},
    {0xF6,  0x7e},
    {0xF7,  0x68},
    {0xF8,  0x0d},
    {0xF9,  0x75},
    {0xFA,  0x0a},
    {0xFB,  0x26},
    {0xFC,  0x3},
    {0xFD,  0x0},
    {0xFE,  0x0},
    {0xFF,  0x5},

#if 1
    //-----------------------------------
    {0xFF,  0x06},  //[BANK = 6]
    {0x00,  0xc0},
    {0x01,  0x0e},
    {0x02,  0x0c},
    {0x03,  0x1f},
    {0x04,  0x0},
    {0x05,  0x24},
    {0x06,  0x40},
    {0x07,  0x80},
    {0x08,  0x50},
    {0x09,  0x38},
    {0x0A,  0x0f},
    {0x0B,  0x0},
    {0x0C,  0x4},
    {0x0D,  0x10},
    {0x0E,  0x30},
    {0x0F,  0x0},
    {0x10,  0x6},
    {0x11,  0x6},
    {0x12,  0x0},
    {0x13,  0x80},
    {0x14,  0x37},
    {0x15,  0x80},
    {0x16,  0x49},
    {0x17,  0x37},
    {0x18,  0xef},
    {0x19,  0xdf},
    {0x1A,  0xdf},
    {0x1B,  0x8},
    {0x1C,  0x50},
    {0x1D,  0x0c},
    {0x1E,  0x1},
    {0x1F,  0x88},
    {0x20,  0x84},
    {0x21,  0x20},
    {0x22,  0x23},
    {0x23,  0x0},
    {0x24,  0x2a},
    {0x25,  0xdb},
    {0x26,  0xf0},
    {0x27,  0x57},
    {0x28,  0x90},
    {0x29,  0x70},
    {0x2A,  0x52},
    {0x2B,  0x78},
    {0x2C,  0x0},
    {0x2D,  0x68},
    {0x2E,  0x0},
    {0x2F,  0x7},
    {0x30,  0x0},
    {0x31,  0x1},
    {0x32,  0x64},

    {0x33,  0x82}, // 0x82 - 30P
    {0x34,  0xec}, // 0xEC - 30P
    {0x35,  0x19}, // 0x1B - 30P MPP_V_E   //0x1b
    {0x36,  0xd2}, // 0xCF - 30P    MPP_V_DLY //0xcf

    {0x37,  0x00},
    {0x38,  0x0},
    {0x39,  0x2},
    {0x3A,  0x2},
    {0x3B,  0x04}, // 0x04  MPP_V_MODE
    {0x3C,  0x10}, // 0x10 -30P MPP_OUT_SEL1
    {0x3D,  0x00},
    {0x3E,  0x00},
    {0x3F,  0x00},
    {0x40,  0xef}, // 0xEF -30P H_BLK, MPP2 : V_BLK
    {0x41,  0x00},
    {0x42,  0x00}, // 0x00 - 30P    FULL_TST_SEL1
    {0x43,  0x0},
    {0x44,  0x0},
    {0x45,  0x0},
    {0x46,  0x0},
    {0x47,  0x4},
    {0x48,  0x0},
    {0x49,  0x44},
    {0x4A,  0xaa},
    {0x4B,  0x0},
    {0x4C,  0x0},
    {0x4D,  0x0},
    {0x4E,  0x0},
    {0x4F,  0x0},
    {0x50,  0x84},
    {0x51,  0xff},
    {0x52,  0xff},
    {0x53,  0x0},
    {0x54,  0x0},
    {0x55,  0x0},
    {0x56,  0x0},
    {0x57,  0x0},
    {0x58,  0x0},
    {0x59,  0x0},
    {0x5A,  0x0},
    {0x5B,  0x0},
    {0x5C,  0x0},
    {0x5D,  0x0},
    {0x5E,  0x0},
    {0x5F,  0x30},
    {0x60,  0x53},
    {0x61,  0x53},
    {0x62,  0x20},
    {0x63,  0x0},
    {0x64,  0x2},
    {0x65,  0x0},
    {0x66,  0x0},
    {0x67,  0x0},
    {0x68,  0x0},
    {0x69,  0x0},
    {0x6A,  0x0},
    {0x6B,  0x0},
    {0x6C,  0x0},
    {0x6D,  0x0},
    {0x6E,  0x0},
    {0x6F,  0x0},
    {0x70,  0xc0},
    {0x71,  0x1},
    {0x72,  0x6},
    {0x73,  0x6},
    {0x74,  0x11},
    {0x75,  0x0},
    {0x76,  0x1},
    {0x77,  0x81},
    {0x78,  0x1},
    {0x79,  0x1},
    {0x7A,  0x1},
    {0x7B,  0x81},
    {0x7C,  0x11},
    {0x7D,  0x80},
    {0x7E,  0x0},
    {0x7F,  0x0},
    {0x80,  0x0},
    {0x81,  0x0},
    {0x82,  0x0},
    {0x83,  0x0},
    {0x84,  0x0},
    {0x85,  0x0},
    {0x86,  0x0},
    {0x87,  0x0},
    {0x88,  0x0},
    {0x89,  0x0},
    {0x8A,  0x0},
    {0x8B,  0x0},
    {0x8C,  0x0},
    {0x8D,  0x0},
    {0x8E,  0x0},
    {0x8F,  0x0},
    {0x90,  0x1},
    {0x91,  0x0},
    {0x92,  0x0},
    {0x93,  0x0},
    {0x94,  0x0},
    {0x95,  0x0},
    {0x96,  0x0},
    {0x97,  0x0},
    {0x98,  0x48},
    {0x99,  0x84},
    {0x9A,  0x0},
    {0x9B,  0x80},
    {0x9C,  0x00}, // 0x00  MPP_H_START
    {0x9D,  0xc1}, // 0xbb
    {0x9E,  0x0a}, // 0x0A  MPP_H_END
    {0x9F,  0xc0}, // 0xba
    {0xA0,  0x10},
    {0xA1,  0x30},
    {0xA2,  0x0c},
    {0xA3,  0x50},
    {0xA4,  0x10},
    {0xA5,  0x34},
    {0xA6,  0x70},
    {0xA7,  0x5c},
    {0xA8,  0x20},
    {0xA9,  0x20},
    {0xAA,  0x30},
    {0xAB,  0x40},
    {0xAC,  0x20},
    {0xAD,  0x20},
    {0xAE,  0x14},
    {0xAF,  0xa0},
    {0xB0,  0x40},
    {0xB1,  0x50},
    {0xB2,  0x0e},
    {0xB3,  0x0},
    {0xB4,  0x0},
    {0xB5,  0x80},
    {0xB6,  0x0},
    {0xB7,  0x0},
    {0xB8,  0x38},
    {0xB9,  0xb2},
    {0xBA,  0x5},
    {0xBB,  0x0},
    {0xBC,  0xa0},
    {0xBD,  0x0},
    {0xBE,  0x0},
    {0xBF,  0x0},
    {0xC0,  0x16},
    {0xC1,  0x13},
    {0xC2,  0x0},
    {0xC3,  0x0},
    {0xC4,  0x1},
    {0xC5,  0x4},
    {0xC6,  0x0},
    {0xC7,  0x55},
    {0xC8,  0x4},
    {0xC9,  0x0},
    {0xCA,  0x0},
    {0xCB,  0x0},
    {0xCC,  0x0},
    {0xCD,  0x0},
    {0xCE,  0x0},
    {0xCF,  0x0},
    {0xD0,  0x0},
    {0xD1,  0x0},
    {0xD2,  0x0},
    {0xD3,  0x0},
    {0xD4,  0x0},
    {0xD5,  0x0},
    {0xD6,  0x0},
    {0xD7,  0x0},
    {0xD8,  0x0c},
    {0xD9,  0x0e},
    {0xDA,  0x12},
    {0xDB,  0x14},
    {0xDC,  0x1c},
    {0xDD,  0x2c},
    {0xDE,  0x34},
    {0xDF,  0x0},
    {0xE0,  0x0},
    {0xE1,  0x0},
    {0xE2,  0x0},
    {0xE3,  0x44},
    {0xE4,  0x0},
    {0xE5,  0x0},
    {0xE6,  0x0},
    {0xE7,  0x0},
    {0xE8,  0x1},
    {0xE9,  0xbb},
    {0xEA,  0x1},
    {0xEB,  0xbb},
    {0xEC,  0x40},
    {0xED,  0x40},
    {0xEE,  0x2},
    {0xEF,  0xf5},
    {0xF0,  0x20},
    {0xF1,  0xff},
    {0xF2,  0xb0},
    {0xF3,  0x4},
    {0xF4,  0xf6},
    {0xF5,  0x2},
    {0xF6,  0x7e},
    {0xF7,  0x68},
    {0xF8,  0x0d},
    {0xF9,  0x75},
    {0xFA,  0x0a},
    {0xFB,  0x26},
    {0xFC,  0x3},
    {0xFD,  0x0},
    {0xFE,  0x0},
    {0xFF,  0x6},
#endif

#if 0
    //-----------------------------------
    0xFF,   0x07,   //[BANK = 7]
    0x00,   0xc0,
    0x01,   0x0e,
    0x02,   0x0c,
    0x03,   0x1f,
    0x04,   0x0,
    0x05,   0x24,
    0x06,   0x40,
    0x07,   0x80,
    0x08,   0x50,
    0x09,   0x38,
    0x0A,   0x0f,
    0x0B,   0x0,
    0x0C,   0x4,
    0x0D,   0x10,
    0x0E,   0x30,
    0x0F,   0x0,
    0x10,   0x6,
    0x11,   0x6,
    0x12,   0x0,
    0x13,   0x80,
    0x14,   0x37,
    0x15,   0x80,
    0x16,   0x49,
    0x17,   0x37,
    0x18,   0xef,
    0x19,   0xdf,
    0x1A,   0xdf,
    0x1B,   0x8,
    0x1C,   0x50,
    0x1D,   0x0c,
    0x1E,   0x1,
    0x1F,   0x88,
    0x20,   0x84,
    0x21,   0x20,
    0x22,   0x23,
    0x23,   0x0,
    0x24,   0x2a,
    0x25,   0xdb,
    0x26,   0xf0,
    0x27,   0x57,
    0x28,   0x90,
    0x29,   0x70,
    0x2A,   0x52,
    0x2B,   0x78,
    0x2C,   0x0,
    0x2D,   0x68,
    0x2E,   0x0,
    0x2F,   0x7,
    0x30,   0x0,
    0x31,   0x1,
    0x32,   0x64,
    0x33,   0x2,
    0x34,   0x1,
    0x35,   0x1c,
    0x36,   0xcf,
    0x37,   0x0,
    0x38,   0x0,
    0x39,   0x2,
    0x3A,   0x2,
    0x3B,   0x4,
    0x3C,   0x0,
    0x3D,   0x0,
    0x3E,   0x0,
    0x3F,   0x0,
    0x40,   0xef,
    0x41,   0x0,
    0x42,   0x0,
    0x43,   0x0,
    0x44,   0x0,
    0x45,   0x0,
    0x46,   0x0,
    0x47,   0x4,
    0x48,   0x0,
    0x49,   0x44,
    0x4A,   0xaa,
    0x4B,   0x0,
    0x4C,   0x0,
    0x4D,   0x0,
    0x4E,   0x0,
    0x4F,   0x0,
    0x50,   0x84,
    0x51,   0xff,
    0x52,   0xff,
    0x53,   0x0,
    0x54,   0x0,
    0x55,   0x0,
    0x56,   0x0,
    0x57,   0x0,
    0x58,   0x3,
    0x59,   0x0,
    0x5A,   0x0,
    0x5B,   0x0,
    0x5C,   0x0,
    0x5D,   0x0,
    0x5E,   0x0,
    0x5F,   0x30,
    0x60,   0x53,
    0x61,   0x53,
    0x62,   0x20,
    0x63,   0x0,
    0x64,   0x2,
    0x65,   0x0,
    0x66,   0x0,
    0x67,   0x0,
    0x68,   0x0,
    0x69,   0x0,
    0x6A,   0x0,
    0x6B,   0x0,
    0x6C,   0x0,
    0x6D,   0x0,
    0x6E,   0x0,
    0x6F,   0x0,
    0x70,   0xc0,
    0x71,   0x1,
    0x72,   0x6,
    0x73,   0x6,
    0x74,   0x11,
    0x75,   0x0,
    0x76,   0x1,
    0x77,   0x81,
    0x78,   0x1,
    0x79,   0x1,
    0x7A,   0x1,
    0x7B,   0x81,
    0x7C,   0x11,
    0x7D,   0x80,
    0x7E,   0x0,
    0x7F,   0x0,
    0x80,   0x0,
    0x81,   0x0,
    0x82,   0x0,
    0x83,   0x0,
    0x84,   0x0,
    0x85,   0x0,
    0x86,   0x0,
    0x87,   0x0,
    0x88,   0x0,
    0x89,   0x0,
    0x8A,   0x0,
    0x8B,   0x0,
    0x8C,   0x0,
    0x8D,   0x0,
    0x8E,   0x0,
    0x8F,   0x0,
    0x90,   0x1,
    0x91,   0x0,
    0x92,   0x0,
    0x93,   0x0,
    0x94,   0x0,
    0x95,   0x0,
    0x96,   0x0,
    0x97,   0x0,
    0x98,   0x48,
    0x99,   0x84,
    0x9A,   0x0,
    0x9B,   0x80,
    0x9C,   0x0,
    0x9D,   0xbb,
    0x9E,   0x0a,
    0x9F,   0xba,
    0xA0,   0x10,
    0xA1,   0x30,
    0xA2,   0x0c,
    0xA3,   0x50,
    0xA4,   0x10,
    0xA5,   0x34,
    0xA6,   0x70,
    0xA7,   0x5c,
    0xA8,   0x20,
    0xA9,   0x20,
    0xAA,   0x30,
    0xAB,   0x40,
    0xAC,   0x20,
    0xAD,   0x20,
    0xAE,   0x14,
    0xAF,   0xa0,
    0xB0,   0x40,
    0xB1,   0x50,
    0xB2,   0x0e,
    0xB3,   0x0,
    0xB4,   0x0,
    0xB5,   0x80,
    0xB6,   0x0,
    0xB7,   0x0,
    0xB8,   0x38,
    0xB9,   0xb2,
    0xBA,   0x5,
    0xBB,   0x0,
    0xBC,   0xa0,
    0xBD,   0x0,
    0xBE,   0x0,
    0xBF,   0x0,
    0xC0,   0x16,
    0xC1,   0x13,
    0xC2,   0x0,
    0xC3,   0x0,
    0xC4,   0x1,
    0xC5,   0x4,
    0xC6,   0x0,
    0xC7,   0x55,
    0xC8,   0x4,
    0xC9,   0x0,
    0xCA,   0x0,
    0xCB,   0x0,
    0xCC,   0x0,
    0xCD,   0x0,
    0xCE,   0x0,
    0xCF,   0x0,
    0xD0,   0x0,
    0xD1,   0x0,
    0xD2,   0x0,
    0xD3,   0x0,
    0xD4,   0x0,
    0xD5,   0x0,
    0xD6,   0x0,
    0xD7,   0x0,
    0xD8,   0x0c,
    0xD9,   0x0e,
    0xDA,   0x12,
    0xDB,   0x14,
    0xDC,   0x1c,
    0xDD,   0x2c,
    0xDE,   0x34,
    0xDF,   0x0,
    0xE0,   0x0,
    0xE1,   0x0,
    0xE2,   0x0,
    0xE3,   0x44,
    0xE4,   0x0,
    0xE5,   0x0,
    0xE6,   0x0,
    0xE7,   0x0,
    0xE8,   0x1,
    0xE9,   0xbb,
    0xEA,   0x1,
    0xEB,   0xbb,
    0xEC,   0x40,
    0xED,   0x40,
    0xEE,   0x2,
    0xEF,   0xf5,
    0xF0,   0x20,
    0xF1,   0xff,
    0xF2,   0xb0,
    0xF3,   0x4,
    0xF4,   0xf6,
    0xF5,   0x2,
    0xF6,   0x7e,
    0xF7,   0x68,
    0xF8,   0x0d,
    0xF9,   0x75,
    0xFA,   0x0a,
    0xFB,   0x26,
    0xFC,   0x3,
    0xFD,   0x0,
    0xFE,   0x0,
    0xFF,   0x5,

    0xFF,   0x08,   //[BANK = 8]
    0x00,   0xc0,
    0x01,   0x0e,
    0x02,   0x0c,
    0x03,   0x1f,
    0x04,   0x0,
    0x05,   0x24,
    0x06,   0x40,
    0x07,   0x80,
    0x08,   0x50,
    0x09,   0x38,
    0x0A,   0x0f,
    0x0B,   0x0,
    0x0C,   0x4,
    0x0D,   0x10,
    0x0E,   0x30,
    0x0F,   0x0,
    0x10,   0x6,
    0x11,   0x6,
    0x12,   0x0,
    0x13,   0x80,
    0x14,   0x37,
    0x15,   0x80,
    0x16,   0x49,
    0x17,   0x37,
    0x18,   0xef,
    0x19,   0xdf,
    0x1A,   0xdf,
    0x1B,   0x8,
    0x1C,   0x50,
    0x1D,   0x0c,
    0x1E,   0x1,
    0x1F,   0x88,
    0x20,   0x84,
    0x21,   0x20,
    0x22,   0x23,
    0x23,   0x0,
    0x24,   0x2a,
    0x25,   0xdb,
    0x26,   0xf0,
    0x27,   0x57,
    0x28,   0x90,
    0x29,   0x70,
    0x2A,   0x52,
    0x2B,   0x78,
    0x2C,   0x0,
    0x2D,   0x68,
    0x2E,   0x0,
    0x2F,   0x7,
    0x30,   0x0,
    0x31,   0x1,
    0x32,   0x64,
    0x33,   0x2,
    0x34,   0x1,
    0x35,   0x1c,
    0x36,   0xcf,
    0x37,   0x0,
    0x38,   0x0,
    0x39,   0x2,
    0x3A,   0x2,
    0x3B,   0x4,
    0x3C,   0x0,
    0x3D,   0x0,
    0x3E,   0x0,
    0x3F,   0x0,
    0x40,   0xef,
    0x41,   0x0,
    0x42,   0x0,
    0x43,   0x0,
    0x44,   0x0,
    0x45,   0x0,
    0x46,   0x0,
    0x47,   0x4,
    0x48,   0x0,
    0x49,   0x44,
    0x4A,   0xaa,
    0x4B,   0x0,
    0x4C,   0x0,
    0x4D,   0x0,
    0x4E,   0x0,
    0x4F,   0x0,
    0x50,   0x84,
    0x51,   0xff,
    0x52,   0xff,
    0x53,   0x0,
    0x54,   0x0,
    0x55,   0x0,
    0x56,   0x0,
    0x57,   0x0,
    0x58,   0x3,
    0x59,   0x0,
    0x5A,   0x0,
    0x5B,   0x0,
    0x5C,   0x0,
    0x5D,   0x0,
    0x5E,   0x0,
    0x5F,   0x30,
    0x60,   0x53,
    0x61,   0x53,
    0x62,   0x20,
    0x63,   0x0,
    0x64,   0x2,
    0x65,   0x0,
    0x66,   0x0,
    0x67,   0x0,
    0x68,   0x0,
    0x69,   0x0,
    0x6A,   0x0,
    0x6B,   0x0,
    0x6C,   0x0,
    0x6D,   0x0,
    0x6E,   0x0,
    0x6F,   0x0,
    0x70,   0xc0,
    0x71,   0x1,
    0x72,   0x6,
    0x73,   0x6,
    0x74,   0x11,
    0x75,   0x0,
    0x76,   0x1,
    0x77,   0x81,
    0x78,   0x1,
    0x79,   0x1,
    0x7A,   0x1,
    0x7B,   0x81,
    0x7C,   0x11,
    0x7D,   0x80,
    0x7E,   0x0,
    0x7F,   0x0,
    0x80,   0x0,
    0x81,   0x0,
    0x82,   0x0,
    0x83,   0x0,
    0x84,   0x0,
    0x85,   0x0,
    0x86,   0x0,
    0x87,   0x0,
    0x88,   0x0,
    0x89,   0x0,
    0x8A,   0x0,
    0x8B,   0x0,
    0x8C,   0x0,
    0x8D,   0x0,
    0x8E,   0x0,
    0x8F,   0x0,
    0x90,   0x1,
    0x91,   0x0,
    0x92,   0x0,
    0x93,   0x0,
    0x94,   0x0,
    0x95,   0x0,
    0x96,   0x0,
    0x97,   0x0,
    0x98,   0x48,
    0x99,   0x84,
    0x9A,   0x0,
    0x9B,   0x80,
    0x9C,   0x0,
    0x9D,   0xbb,
    0x9E,   0x0a,
    0x9F,   0xba,
    0xA0,   0x10,
    0xA1,   0x30,
    0xA2,   0x0c,
    0xA3,   0x50,
    0xA4,   0x10,
    0xA5,   0x34,
    0xA6,   0x70,
    0xA7,   0x5c,
    0xA8,   0x20,
    0xA9,   0x20,
    0xAA,   0x30,
    0xAB,   0x40,
    0xAC,   0x20,
    0xAD,   0x20,
    0xAE,   0x14,
    0xAF,   0xa0,
    0xB0,   0x40,
    0xB1,   0x50,
    0xB2,   0x0e,
    0xB3,   0x0,
    0xB4,   0x0,
    0xB5,   0x80,
    0xB6,   0x0,
    0xB7,   0x0,
    0xB8,   0x38,
    0xB9,   0xb2,
    0xBA,   0x5,
    0xBB,   0x0,
    0xBC,   0xa0,
    0xBD,   0x0,
    0xBE,   0x0,
    0xBF,   0x0,
    0xC0,   0x16,
    0xC1,   0x13,
    0xC2,   0x0,
    0xC3,   0x0,
    0xC4,   0x1,
    0xC5,   0x4,
    0xC6,   0x0,
    0xC7,   0x55,
    0xC8,   0x4,
    0xC9,   0x0,
    0xCA,   0x0,
    0xCB,   0x0,
    0xCC,   0x0,
    0xCD,   0x0,
    0xCE,   0x0,
    0xCF,   0x0,
    0xD0,   0x0,
    0xD1,   0x0,
    0xD2,   0x0,
    0xD3,   0x0,
    0xD4,   0x0,
    0xD5,   0x0,
    0xD6,   0x0,
    0xD7,   0x0,
    0xD8,   0x0c,
    0xD9,   0x0e,
    0xDA,   0x12,
    0xDB,   0x14,
    0xDC,   0x1c,
    0xDD,   0x2c,
    0xDE,   0x34,
    0xDF,   0x0,
    0xE0,   0x0,
    0xE1,   0x0,
    0xE2,   0x0,
    0xE3,   0x44,
    0xE4,   0x0,
    0xE5,   0x0,
    0xE6,   0x0,
    0xE7,   0x0,
    0xE8,   0x1,
    0xE9,   0xbb,
    0xEA,   0x1,
    0xEB,   0xbb,
    0xEC,   0x40,
    0xED,   0x40,
    0xEE,   0x2,
    0xEF,   0xf5,
    0xF0,   0x20,
    0xF1,   0xff,
    0xF2,   0xb0,
    0xF3,   0x4,
    0xF4,   0xf6,
    0xF5,   0x2,
    0xF6,   0x7e,
    0xF7,   0x68,
    0xF8,   0x0d,
    0xF9,   0x75,
    0xFA,   0x0a,
    0xFB,   0x26,
    0xFC,   0x3,
    0xFD,   0x0,
    0xFE,   0x0,
    0xFF,   0x5,
#endif

    {0xFF,  0x09},  //[BANK = 9]
    {0x40,  0x00},
    {0x41,  0x00},
    {0x42,  0x00},
    {0x43,  0x00},
    {0x44,  0x00},

    //0xFF, 0x00,
    //0x78, 0xAA,

    {0xFF,  0x05},  //20170802 color lock finish
    {0x23,  0x80},
    {0x27,  0x30},
    {0x23,  0x00},
    {0x27,  0x57},

    {0xFF,  0x06},
    {0x23,  0x80},
    {0x27,  0x30},
    {0x23,  0x00},
    {0x27,  0x57},

};

static I2C_ARRAY TriggerStartTbl[] =
{

};

static I2C_ARRAY PatternTbl[] =
{

};

/////////////////////////////////////////////////////////////////
//       @@@@@@                                                                                    //
//                 @@                                                                                    //
//             @@@                                                                                      //
//       @       @@                                                                                    //
//         @@@@                                                                                        //
//                                                                                                          //
//      Step 3 --  complete camera features                                              //
//                                                                                                         //
//                                                                                                         //
//  camera set EV, MWB, orientation, contrast, sharpness                          //
//   , saturation, and Denoise can work correctly.                                     //
//                                                                                                          //
/////////////////////////////////////////////////////////////////

typedef struct
{
    short reg;
    char startbit;
    char stopbit;
} COLLECT_REG_SET;

static I2C_ARRAY mirror_reg[] =
{

};

static I2C_ARRAY gain_reg[] =
{

};

static CUS_GAIN_GAP_ARRAY gain_gap_compensate[16] =
{

};

static I2C_ARRAY expo_reg[] =
{

};

static I2C_ARRAY vts_reg[] =
{

};

/*
static CUS_INT_TASK_ORDER def_order =
{
    .RunLength = 9,
    .Orders =
    {
        CUS_INT_TASK_AE|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_AWB|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_AE|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_AWB|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_AE|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_AWB|CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
        CUS_INT_TASK_VDOS|CUS_INT_TASK_AF,
    },
};*/

/////////// function definition ///////////////////

/////////////////// sensor hardware dependent //////////////
static int pCus_poweron(ms_cus_sensor *handle)
{
    ISensorIfAPI *sensor_if = &handle->sensor_if_api;

    //Sensor power on sequence
    //DrvSensorIFHWSetIOPad(0/*TBD*/, CUS_SENIF_BUS_BT656, CUS_SR_PAD_CFG_6);//call sensor if
    sensor_if->SetIOPad(SENSOR_PAD_GROUP_SET, CUS_SENIF_BUS_BT656, CUS_SR1_BT656_MODE_1);

    sensor_if->MCLK(SENSOR_PAD_GROUP_SET, 1, handle->mclk);
    MsSleep(RTK_MS_TO_TICK(50));

    SENSOR_DMSG("[%s] reset low\n", __FUNCTION__);
    sensor_if->Reset(SENSOR_PAD_GROUP_SET, handle->reset_POLARITY);
    MsSleep(RTK_MS_TO_TICK(100));//usleep(500);

    SENSOR_DMSG("[%s] power low\n", __FUNCTION__);
    sensor_if->PowerOff(SENSOR_PAD_GROUP_SET, handle->pwdn_POLARITY);
    MsSleep(RTK_MS_TO_TICK(5));//usleep(500);

    // power -> high, reset -> high
    SENSOR_DMSG("[%s] power high\n", __FUNCTION__);
    sensor_if->PowerOff(SENSOR_PAD_GROUP_SET, !handle->pwdn_POLARITY);
    MsSleep(RTK_MS_TO_TICK(5));//usleep(500);
    SENSOR_DMSG("[%s] reset high\n", __FUNCTION__);

    sensor_if->Reset(SENSOR_PAD_GROUP_SET, !handle->reset_POLARITY);
    MsSleep(RTK_MS_TO_TICK(200));//usleep(500);

    //sensor_if->Set3ATaskOrder( def_order);
    // pure power on
    sensor_if->PowerOff(SENSOR_PAD_GROUP_SET, !handle->pwdn_POLARITY);
	sensor_if->SWReset(handle->channel_num, FALSE);
	MsSleep(RTK_MS_TO_TICK(100));//usleep(500);

    MMPF_PIO_Enable(DRV_IO_PM_GPIO2, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(DRV_IO_PM_GPIO2, MMP_TRUE, MMP_TRUE);
    MMPF_PIO_SetData(DRV_IO_PM_GPIO2, MMP_TRUE, MMP_TRUE);

    return SUCCESS;
}

static int pCus_poweroff(ms_cus_sensor *handle)
{
    ISensorIfAPI *sensor_if = &handle->sensor_if_api;
    //sensor_if->MIPISamplingDelay(handle, false, handle->mipi_sampling_delay);
    SENSOR_DMSG("[%s] power low\n", __FUNCTION__);
	sensor_if->SWReset(handle->channel_num, TRUE);
	sensor_if->PowerOff( 1, handle->pwdn_POLARITY);

    MsSleep(RTK_MS_TO_TICK(5));//usleep(1000);
    sensor_if->SetCSI_Clk(handle->snr_pad_group, CUS_CSI_CLK_DISABLE, handle->PCLK_POLARITY);     //Set_csi_if(0, 0);
    sensor_if->MCLK(0, 0, handle->mclk);

    return SUCCESS;
}

/////////////////// image function /////////////////////////
//Get and check sensor ID
//if i2c error or sensor id does not match then return FAIL
static int pCus_GetSensorID(ms_cus_sensor *handle, u32 *id)
{
    int i,n;

    int table_length= ARRAY_SIZE(Sensor_id_table);
    I2C_ARRAY id_from_sensor[ARRAY_SIZE(Sensor_id_table)];
    unsigned short id_temp=0;

    while (1) {
        SensorReg_Write(0xFF, 0x00); //change to bank 0
        if (SensorReg_Read(0xF4, &id_temp) == SUCCESS) {
            // NOP
        }
        else {
            MsSleep(RTK_MS_TO_TICK(10));
        }

        if (id_temp==0x86)
        {
            break;
        }
    }

    if (n >= 3) {
        SENSOR_EMSG("##read chip id error\n");
        return FAIL;
    }

    *id = id_temp;

    SENSOR_IMSG("[%s] %s get sensor id:0x%x, SUCCESS!\n", __FUNCTION__, handle->model_id, ( int )*id);
    return SUCCESS;
}

static int n3_SetPatternMode(ms_cus_sensor *handle,u32 mode)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);

    return SUCCESS;
}

static int pCus_I2CWrite(ms_cus_sensor *handle, unsigned short usreg, unsigned short usval)
{
    unsigned short sen_data;

    SensorReg_Write(usreg, usval);

    return SUCCESS;
}

static int pCus_I2CRead(ms_cus_sensor *handle, unsigned short usreg, unsigned short* pusval)
{
    unsigned short usReadData = 0;

    if (SUCCESS != SensorReg_Read(usreg, &usReadData)) {
        *pusval = 0;
        return FAIL;
    }

    *pusval = usReadData;

    return SUCCESS;
}

static int pCus_init(ms_cus_sensor *handle)
{
    int i,cnt=0;
    unsigned short sen_data;

    ISensorIfAPI *sensor_if = &(handle->sensor_if_api);
#if 0
    sensor_if->PCLK(CUS_SNR_PCLK_SR_PAD);
#endif

    UartSendTrace("\n===== N3 init. =====\n");

    for (i = 0; i < ARRAY_SIZE(Sensor_init_table); i++)
    {
        if (Sensor_init_table[i].reg==0xffff)
        {
            MsSleep(RTK_MS_TO_TICK(1));//usleep(1000*Sensor_init_table[i].data);
        }
        else
        {
            cnt = 0;

            while (SensorReg_Write(Sensor_init_table[i].reg, Sensor_init_table[i].data) != SUCCESS)
            {
                cnt++;
                SENSOR_DMSG("[%s] set Sensor_init_table retry : %d...\n",__FUNCTION__,cnt);

                if (cnt >= 10)
                {
                    SENSOR_EMSG("[%s:%d] retry FAIL!!\n", __FUNCTION__, __LINE__);
                    //return FAIL;
                }
                MsSleep(RTK_MS_TO_TICK(1));//usleep(10*1000);
                break;
            }
        }
    }

    usleep(50*1000);
    pCus_SetAEGain(handle,2048);
    pCus_SetAEUSecs(handle, 25000);

    return SUCCESS;
}

static int pCus_GetVideoResNum( ms_cus_sensor *handle, u32 *ulres_num)
{
    *ulres_num = handle->video_res_supported.num_res;
    return SUCCESS;
}

static int pCus_GetVideoRes(ms_cus_sensor *handle, cus_camsensor_res **res)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
    //return current resolution
    *res = &handle->video_res_supported.res[handle->video_res_supported.ulcur_res];
    return SUCCESS;
}

static int pCus_SetVideoRes(ms_cus_sensor *handle, u32 res)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
    handle->video_res_supported.ulcur_res = 0; //TBD
    //TODO: Set sensor output resolution
    return SUCCESS;
}

static int pCus_GetOrien(ms_cus_sensor *handle, CUS_CAMSENSOR_ORIT *orit)
{
    char sen_data;

    sen_data = mirror_reg[0].data;
    SENSOR_DMSG("[%s] mirror:%x\r\n", __FUNCTION__, sen_data & 0x03);
    switch(sen_data & 0x03)
    {
        case 0x00:
            *orit = CUS_ORIT_M0F0;
            break;
        case 0x02:
            *orit = CUS_ORIT_M1F0;
            break;
        case 0x01:
            *orit = CUS_ORIT_M0F1;
            break;
        case 0x03:
            *orit = CUS_ORIT_M1F1;
            break;
    }
    return SUCCESS;
}

static int pCus_SetOrien(ms_cus_sensor *handle, CUS_CAMSENSOR_ORIT orit)
{
    char index=0;
    n3_params *params = (n3_params *)handle->private_data;

    switch(orit)
    {
        case CUS_ORIT_M0F0:
            index = 0;
            break;
        case CUS_ORIT_M1F0:
            index = 1;
            break;
        case CUS_ORIT_M0F1:
            index = 2;
            break;
        case CUS_ORIT_M1F1:
            index = 3;
            break;
    }
    SENSOR_DMSG("[%d] CUS_CAMSENSOR_ORIT orit : %x\r\n",__FUNCTION__, orit);
    if (index != mirror_reg[0].data)
    {
        mirror_reg[0].data = index;
        SensorRegArrayW((I2C_ARRAY*)mirror_reg, sizeof(mirror_reg)/sizeof(I2C_ARRAY));
        params->reg_dirty = true;
    }
    return SUCCESS;
}

static int pCus_GetFPS(ms_cus_sensor *handle)
{
    n3_params *params = (n3_params *)handle->private_data;
    int ifps = 0;
    unsigned short usreg = 0, usval = 0;

    SENSOR_DMSG("[%s] FPS %d\n", __FUNCTION__, params->expo.fps);

 /*   if(pCus_I2CRead == NULL){
        SENSOR_EMSG("[%s] I2C function is not ready!\n", __FUNCTION__);
        return FAIL;
    }

    usreg = 0x0;
    pCus_I2CRead(handle, usreg, &usval);

    if ((usval & 0x10) == 0) { // if Reg0x00[4] == 0, signal in
        if (usval & 0x01) { // Reg0x00[0] == 1, 720P30
            ifps = 30;
        }
        else { // Reg0x00[0] == 0, 720P25
            ifps = 25;
        }
    }
*/
    return 25;
}
static int pCus_SetFPS(ms_cus_sensor *handle, u32 fps)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);

    return SUCCESS;
}
static int pCus_GetSensorCap(ms_cus_sensor *handle, CUS_CAMSENSOR_CAP *cap)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);

    return SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// auto exposure
///////////////////////////////////////////////////////////////////////
// unit: micro seconds
//AE status notification
static int pCus_AEStatusNotify(ms_cus_sensor *handle, CUS_CAMSENSOR_AE_STATUS_NOTIFY status)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
    return SUCCESS;
}

static int pCus_GetAEUSecs(ms_cus_sensor *handle, u32 *us)
{
    return SUCCESS;
}

static int pCus_SetAEUSecs(ms_cus_sensor *handle, u32 us)
{
    return SUCCESS;
}

// Gain: 1x = 1024
static int pCus_GetAEGain(ms_cus_sensor *handle, u32* gain)
{
    //int rc = SensorRegArrayR((I2C_ARRAY*)gain_reg, ARRAY_SIZE(gain_reg));
    return SUCCESS;
}

static int pCus_SetAEGain_cal(ms_cus_sensor *handle, u32 gain)
{
    return SUCCESS;
}

static int pCus_SetAEGain(ms_cus_sensor *handle, u32 gain)
{
    return SUCCESS;
}

static int pCus_GetAEMinMaxUSecs(ms_cus_sensor *handle, u32 *min, u32 *max)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
    *min = 1;
    *max = 1000000/4;
    return SUCCESS;
}

static int pCus_GetAEMinMaxGain(ms_cus_sensor *handle, u32 *min, u32 *max)
{
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
    *min = SENSOR_MIN_GAIN;
    *max = SENSOR_MAX_GAIN;
    return SUCCESS;
}

static int pCus_GetDGainRemainder(ms_cus_sensor *handle, u32 *dgain_remainder)
{
    *dgain_remainder = handle->dgain_remainder;

    return SUCCESS;
}

static int pCus_setCaliData_gain_linearity(ms_cus_sensor* handle, CUS_GAIN_GAP_ARRAY* pArray, u32 num)
{
    return SUCCESS;
}

static int n3_GetShutterInfo(struct __ms_cus_sensor* handle,CUS_SHUTTER_INFO *info)
{
    return SUCCESS;
}

static int pCus_BT656_GetSrcType(ms_cus_sensor *handle, CUS_SNR_ANADEC_SRC_TYPE *psrc_type)
{
    unsigned short usreg, usval;
    unsigned short usData = 0,usData_B8 = 0;
    static u8 temp=0x00;
    static unsigned short cnt;
    *psrc_type = CUS_SNR_ANADEC_SRC_NO_READY;

    if (pCus_I2CRead == NULL) {
        SENSOR_EMSG("[%s] I2C function is not ready!\n", __FUNCTION__);
        return FAIL;
    }

    usreg = 0x0;
    pCus_I2CWrite(handle, 0xFF, 0x00);
    pCus_I2CRead(handle, 0xD0, &usData_B8); // check rear in /out
    pCus_I2CRead(handle, 0xe8, &usData); // val:0x42

    SENSOR_DMSG("usData_B8=0x%02x\r\n",usData_B8);
    SENSOR_DMSG("usData=0x%x\n",usData);

    if(0x42 != usData)
    {
        SENSOR_DMSG("CLK0x%02x\r\n",usData);
        pCus_I2CWrite(handle, 0xFF, 0x05);
        pCus_I2CWrite(handle, 0x25, 0xdc);
        MsSleep(RTK_MS_TO_TICK(30));
        pCus_I2CWrite(handle, 0x25, 0xdb);
    }

    pCus_I2CRead(handle, 0xb8, &usData); // val:0x42
    SENSOR_DMSG("usData=0x%x\n",usData);

    if(usData_B8 & 0x08)//(usData == 0x08)//(usData_B8 & 0x0e)//(usData & 0x08)//(usData & 0x04) // HD TVBS signal input  only test set 1
    {
        *psrc_type = CUS_SNR_ANADEC_SRC_HD;
    }
    else  // No TVBS signal
    {
        *psrc_type = CUS_SNR_ANADEC_SRC_NO_READY;
    }

    return SUCCESS;
}

int n3_cus_camsensor_init_handle(ms_cus_sensor* handle)
{
#if defined(__RTK_OS__)
    CamOsRet_e                  eCamOsRet = CAM_OS_OK;
    void*                       pvBufVirt = NULL;
    u64                 u64BufPhy = 0;
    u64                 u64BufMiu = 0;
    u8                   str[20];
#endif
    if (!handle)
    {
        SENSOR_EMSG("[%s] not enough memory!\n", __FUNCTION__);
        return FAIL;
    }
    SENSOR_DMSG("[%s]\n", __FUNCTION__);
#if defined(__RTK_OS__)
    sprintf(str, "N3");
    eCamOsRet = CamOsDirectMemAlloc(str, sizeof(n3_params), &pvBufVirt, &u64BufMiu, &u64BufPhy);
    if (eCamOsRet != CAM_OS_OK) {
        UartSendTrace("[%s:%d] fail!\n", __FUNCTION__, __LINE__);
        return FAIL;
    }
    handle->private_data = (n3_params *)pvBufVirt;
    memset(handle->private_data, 0, sizeof(n3_params));
#else
    handle->private_data = calloc(1, sizeof(n3_params));
#endif
    n3_params *params = (n3_params *)handle->private_data;

    ////////////////////////////////////
    //    sensor model ID                           //
    ////////////////////////////////////
    sprintf(handle->model_id,"n3_PARL");

    ////////////////////////////////////
    //    sensor interface info       //
    ////////////////////////////////////
    //SENSOR_DMSG("[%s] entering function with id %d\n", __FUNCTION__, id);
    handle->isp_type    = SENSOR_ISP_TYPE;  //ISP_SOC;
    //handle->data_fmt    = SENSOR_DATAFMT;   //CUS_DATAFMT_YUV;
    handle->sif_bus     = SENSOR_IFBUS_TYPE;//CUS_SENIF_BUS_PARL;
    handle->data_prec   = SENSOR_DATAPREC;  //CUS_DATAPRECISION_8;
    handle->data_mode   = SENSOR_DATAMODE;
    handle->bayer_id    = SENSOR_BAYERID;   //CUS_BAYER_GB;
    handle->orient      = SENSOR_ORIT;      //CUS_ORIT_M1F1;
    //handle->YC_ODER     = SENSOR_YCORDER;   //CUS_SEN_YCODR_CY;
    //handle->attr_mipi.mipi_sampling_delay = SENSOR_MIPI_DELAY;

    ////////////////////////////////////
    //    resolution capability       //
    ////////////////////////////////////

    handle->video_res_supported.num_res = 1;
    handle->video_res_supported.ulcur_res = 0; //default resolution index is 0.
    handle->video_res_supported.res[0].width = Preview_WIDTH;
    handle->video_res_supported.res[0].height = Preview_HEIGHT;
    handle->video_res_supported.res[0].max_fps = Preview_MAX_FPS;
    handle->video_res_supported.res[0].min_fps = Preview_MIN_FPS;
    handle->video_res_supported.res[0].crop_start_x = Preview_CROP_START_X;
    handle->video_res_supported.res[0].crop_start_y = Preview_CROP_START_Y;
    handle->video_res_supported.res[0].nOutputWidth = 1280;//Preview_WIDTH;
    handle->video_res_supported.res[0].nOutputHeight = 736;//Preview_HEIGHT;

    handle->video_res_supported.res[1].max_fps= Preview_MAX_FPS;
    handle->video_res_supported.res[1].min_fps= Preview_MIN_FPS;
    handle->video_res_supported.res[1].crop_start_x= Preview_CROP_START_X;
    handle->video_res_supported.res[1].crop_start_y= Preview_CROP_START_Y;

    // i2c
    handle->i2c_cfg.mode                = SENSOR_I2C_LEGACY;    //(CUS_ISP_I2C_MODE) FALSE;
    handle->i2c_cfg.fmt                 = SENSOR_I2C_FMT;       //CUS_I2C_FMT_A16D16;
    handle->i2c_cfg.address             = SENSOR_I2C_ADDR;      //0x5a;
    handle->i2c_cfg.speed               = SENSOR_I2C_SPEED;     //200000;
    handle->i2c_cfg.nChannel            = SENSOR_I2C_CHANNEL;   //Channel 1
    handle->i2c_cfg.nPadNum             = SENSOR_I2C_PAD_MODE;  //pad mode 2

    // mclk
    handle->mclk                        = Preview_MCLK_SPEED;

    //polarity
    /////////////////////////////////////////////////////
    handle->pwdn_POLARITY               = SENSOR_PWDN_POL;  //CUS_CLK_POL_NEG;
    handle->reset_POLARITY              = SENSOR_RST_POL;   //CUS_CLK_POL_NEG;
    handle->VSYNC_POLARITY              = SENSOR_VSYNC_POL; //CUS_CLK_POL_POS;
    handle->HSYNC_POLARITY              = SENSOR_HSYNC_POL; //CUS_CLK_POL_POS;
    handle->PCLK_POLARITY               = SENSOR_PCLK_POL;  //CUS_CLK_POL_POS);    // use '!' to clear board latch error
    /////////////////////////////////////////////////////



    ////////////////////////////////////////////////////
    // AE parameters
    ////////////////////////////////////////////////////
    handle->ae_gain_delay       = SENSOR_GAIN_DELAY_FRAME_COUNT;//0;//1;
    handle->ae_shutter_delay    = SENSOR_SHUTTER_DELAY_FRAME_COUNT;//1;//2;

    ///calibration
    handle->sat_mingain = SENSOR_MIN_GAIN;//g_sensor_ae_min_gain;
    handle->dgain_remainder = 0;
    handle->pCus_sensor_release     = n3_cus_camsensor_release_handle;
    handle->pCus_sensor_init        = pCus_init    ;
    handle->pCus_sensor_poweron     = pCus_poweron ;
    handle->pCus_sensor_poweroff    = pCus_poweroff;

    // Normal
    handle->pCus_sensor_GetSensorID     = pCus_GetSensorID;
    handle->pCus_sensor_GetVideoResNum  = pCus_GetVideoResNum;
    handle->pCus_sensor_GetVideoRes     = pCus_GetVideoRes;
    handle->pCus_sensor_SetVideoRes     = pCus_SetVideoRes;
    handle->pCus_sensor_GetOrien        = pCus_GetOrien;
    handle->pCus_sensor_SetOrien        = pCus_SetOrien;
    handle->pCus_sensor_GetFPS          = pCus_GetFPS;
    handle->pCus_sensor_SetFPS          = pCus_SetFPS;
    handle->pCus_sensor_GetSensorCap    = pCus_GetSensorCap;
    handle->pCus_sensor_SetPatternMode  = n3_SetPatternMode;
    ///////////////////////////////////////////////////////
    // AE
    ///////////////////////////////////////////////////////
    // unit: micro seconds
    handle->pCus_sensor_AEStatusNotify = pCus_AEStatusNotify;
    handle->pCus_sensor_GetAEUSecs      = pCus_GetAEUSecs;
    handle->pCus_sensor_SetAEUSecs      = pCus_SetAEUSecs;
    handle->pCus_sensor_GetAEGain       = pCus_GetAEGain;
    handle->pCus_sensor_SetAEGain_cal   = pCus_SetAEGain_cal;
    handle->pCus_sensor_SetAEGain       = pCus_SetAEGain;
    handle->pCus_sensor_GetShutterInfo = n3_GetShutterInfo;

    handle->pCus_sensor_GetAEMinMaxGain = pCus_GetAEMinMaxGain;
    handle->pCus_sensor_GetAEMinMaxUSecs= pCus_GetAEMinMaxUSecs;
    handle->pCus_sensor_GetDGainRemainder = pCus_GetDGainRemainder;

    //sensor calibration
    handle->pCus_sensor_setCaliData_gain_linearity=pCus_setCaliData_gain_linearity;
#if 1//defined(__MV5_FPGA__)
    handle->pCus_sensor_I2CWrite = pCus_I2CWrite; //Andy Liu
    handle->pCus_sensor_I2CRead = pCus_I2CRead; //Andy Liu
#endif
    params->expo.vts=vts_30fps;
    params->expo.fps = 30;
    params->reg_dirty = false;

    handle->snr_pad_group = SENSOR_PAD_GROUP_SET;

    handle->channel_num = SENSOR_CHANNEL_NUM;
    handle->channel_mode = SENSOR_CHANNEL_MODE;

    //============================================
    //BT656 config begin.
    handle->interface_attr.attr_bt656.bt656_total_ch = SENSOR_BT656_CH_TOTAL_NUM;
    handle->interface_attr.attr_bt656.bt656_cur_ch = 0;
    handle->interface_attr.attr_bt656.bt656_ch_det_en = SENSOR_BT656_CH_DET_ENABLE;
    handle->interface_attr.attr_bt656.bt656_ch_det_sel = SENSOR_BT656_CH_DET_SEL;
    handle->interface_attr.attr_bt656.bt656_bit_swap = SENSOR_BT656_BIT_SWAP;
    handle->interface_attr.attr_bt656.bt656_8bit_mode = SENSOR_BT656_8BIT_MODE;
    handle->interface_attr.attr_bt656.bt656_vsync_delay = SENSOR_BT656_VSYNC_DELAY;
    handle->interface_attr.attr_bt656.bt656_hsync_inv = SENSOR_HSYCN_INVERT;
    handle->interface_attr.attr_bt656.bt656_vsync_inv = SENSOR_VSYCN_INVERT;
    handle->interface_attr.attr_bt656.bt656_clamp_en = SENSOR_CLAMP_ENABLE;
    handle->interface_attr.attr_bt656.pCus_sensor_bt656_get_src_type = pCus_BT656_GetSrcType;
    //BT656 config end.
    //============================================
    return SUCCESS;
}

int n3_cus_camsensor_release_handle(ms_cus_sensor *handle)
{
#if defined(__RTK_OS__)
    CamOsRet_e                  eCamOsRet = CAM_OS_OK;
#endif

    //SENSOR_DMSG("[%s]\n", __FUNCTION__);
    if (handle && handle->private_data)
    {
       //SENSOR_IMSG("[%s] release handle 0x%x, private data %x\n",__FUNCTION__,(int)handle,(int)handle->private_data);
#if defined(__RTK_OS__)
        eCamOsRet = CamOsDirectMemRelease((void*)handle->private_data, sizeof(n3_params));
        if (eCamOsRet != CAM_OS_OK) {
            handle->private_data = NULL;
            UartSendTrace("[%s:%d] fail!\n", __FUNCTION__, __LINE__);
            return FAIL;
        }

#else
        free(handle->private_data);
#endif
        handle->private_data = NULL;
    }
    return SUCCESS;
}

#if defined(__RTK_OS__)
struct SensorMapTable_t gsensor_map_n3 = {
    SENSOR_CHANNEL_NUM,
    n3_cus_camsensor_init_handle,
    n3_cus_camsensor_release_handle
};

int N3_Module_Init(void)
{
    cameraSensorRegister(&gsensor_map_n3);
    return 0;
}

void N3_Module_Exit(void)
{
    cameraSensorUnRegister(&gsensor_map_n3);
}

#if defined(__GNUC__)
__section__(initcall6)
#endif
ait_module_init(N3_Module_Init);
#endif //#if defined(__RTK_OS__)

#endif //#if defined(BIND_SENSOR_N3) && (BIND_SENSOR_N3 == 1)
